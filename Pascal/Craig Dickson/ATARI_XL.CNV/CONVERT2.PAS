{ ----------------------- ST/XE Text File Converter 2 ----------------------- }›{ ----------- utility to convert atascii text files to pure ascii ----------- }›{ ------------------- (ignores all ctrl chars except eol) ------------------- }›{                                                                             }›{ ----------- by Craig Dickson, Sequoia Software, 9 February 1986 ----------- }›{ ---------------------- Written in OSS Personal Pascal --------------------- }›{                                                                             }›{ ----------- This program is Copyright (c) 1986 Sequoia Software. ---------- }›{ -- It may be freely distributed among users of Atari ST-series computers -- }›{ ---------- provided only that it is not to be modified in any way --------- }›{ ------------------ without the permission of the author. ------------------ }››program convert_prg ;››  const››    {$I gemconst.pas}››    as_cr =      13 ;›    as_lf =      10 ;›    at_eol =    155 ;›    ignore =      1 ;›    low =        32 ;›    mask =      127 ;›    space =      32 ;›    soft_space = 30 ;››  type››    {$I gemtype.pas}››    txt_buf = array[ 1..12288 ] of char ;››  var›    first_word : boolean ;›    ch,›    dummy,›    mode,›    twhich,›    which : integer ;›    bin_path,›    bin_title,›    out_title : path_name ;›    alert : str255 ;›    bin_file,›    out_file : text ;›    buffer : txt_buf ;››  {$I gemsubs.pas}››  procedure show_off ;›    begin›      alert := '[0][ST/XE Text  File Converter 2|      by Craig Dickson' ;›      alert := concat( alert, '| | Compuserve PPN: 72257,1604| ]' ) ;›      alert := concat( alert, '[  OK  ]' ) ;›      dummy := do_alert( alert, 1 ) ;›      alert := '[0][ (C) 1986  Sequoia Software.|Portions of ' ;›      alert := concat( alert, 'this product are|    (C) 1986 OSS ' );›      alert := concat( alert, 'and CCD.| Used by  Permission of OSS.| ]' ) ;›      alert := concat( alert, '[  OK  ]' ) ;›      dummy := do_alert( alert, 1 ) ;›      alert := '[0][This program is not to be sold|but may be ' ;›      alert := concat( alert, ' distributed freely|   provided only ' );›      alert := concat( alert, 'that it is|      in no way modified.| ]' ) ;›      alert := concat( alert, '[  NO PROBLEM  ]' ) ;›      dummy := do_alert( alert, 1 ) ;›    end ;››  procedure set_titles ;›    begin›      alert := '[2][Convert a file or quit?][ Convert | Quit ]' ;›      mode := do_alert( alert, 2 ) ;›      if mode <> 2 then›      begin›        alert := '[2][Convert to 1st Word format?][ Yes | No ]' ;›        first_word := (do_alert( alert, 2 ) = 1) ;›        bin_path := 'A:*.*' ;›        if length( bin_title ) > 0 then›          delete( bin_title, 1, length( bin_title ) ) ;›        if length( out_title ) > 0 then›          delete( out_title, 1, length( out_title ) ) ;›        if get_in_file( bin_path, bin_title ) then›          if not get_out_file( 'Enter output pathname:', out_title ) then›            mode := 2 ;›      end ;›    end ;››  procedure translate ;››    procedure op_files ;›      begin›        reset( bin_file, bin_title ) ;›        rewrite( out_file, out_title ) ;›      end ;››    procedure cl_files ;›      begin›        close( bin_file ) ;›        close( out_file ) ;›      end ;››    procedure load_file ;›      begin›        which := 0 ;›        repeat›          which := which + 1 ;›          if not eof( bin_file ) then›            begin›              read( bin_file, buffer[ which ] ) ;›              if (buffer[ which ] = chr( at_eol )) then›                which := which + 1 ;›            end›          else buffer[ which ] := chr( as_cr ) ;›        until (eof( bin_file )) or (which > 12287) ;›      end ;››    procedure save_file ;›      begin›        twhich := 0 ;›        repeat›          twhich := twhich + 1 ;›          if buffer[ twhich ] <> chr( ignore ) then›            write( out_file, buffer[ twhich ] ) ;›        until twhich = which ;›      end ;››    procedure load_ch ;›      begin›        ch := ord( buffer[ twhich ] ) ;›        if ch <> at_eol then›          ch := ch & mask ;›      end ;››    procedure save_ch( ch_p : integer ) ;›      begin›        buffer[ twhich ] := chr( ch_p ) ;›      end ;››    begin { translate }›      op_files ;›      repeat›        load_file ;›        twhich := 0 ;›        repeat›          twhich := twhich + 1 ;›          load_ch ;›          case ch of›            at_eol : begin›                       save_ch( as_cr ) ;›                       twhich := twhich + 1 ;›                       save_ch( as_lf ) ;›                     end ;›            space  : begin›                       if first_word then›                         save_ch( soft_space )›                       else save_ch( space ) ;›                     end ;›            otherwise : begin›                          if ch < low then›                            save_ch( ignore )›                          else save_ch( ch ) ;›                        end ;›          end ;›        until twhich = which ;›        save_file ;›      until eof( bin_file ) ;›      cl_files ;›    end ;››  begin { convert_prg }›    if init_gem >= 0 then›      begin›        show_off ;›        repeat›          set_titles ;›          if mode <> 2 then›            translate ;›        until mode = 2 ;›      exit_gem ;›      end ;›  end.››{ ---------------------------- end of convert_prg --------------------------- }››