                             Turbo-Ass V1.1
                              Ω1989 ‰-soft
                    von Markus Fritze & Sîren Hellwig

1.1 Einleitung
Nach   langem   hin   und   her   haben   wir  uns  entschlossen  unser
Assembler-Paket  als  Shareware  auf den Markt zu werfen. Der Assembler
wurde  vormals durch OMIKRON.Software unter dem Namen OMIKRON.Assembler
verkauft.  Die Shareware-Version ist jedoch eine erweiterte Version des
OMIKRON.Assemblers.  Sie  enthÑlt  weniger Fehler, weitere Features und
ist  noch  ein  wenig  schneller. Zum Paket gehîrt (natÅrlich) auch ein
Debugger,  der Bugaboo (vormals OMIKRON.Debugger). Somit kann nun jeder
User  in  den Genuû eines schnellen und leistungsfÑhigen Assemblers und
Debuggers kommen; zumal es zwar viele Programmiersprachen als Shareware
bzw. PD gibt, aber noch keinen (vernÅnftigen) Assembler.

DIE  FIRMA  OMIKRON.SOFTWARE  HAT  NICHTS MIT DIESEM ASSEMBLER-PAKET ZU
TUN.  ‰-SOFT  IST  ALLEINIGER  INHABER  ALLER  RECHTE  AM ASSEMBLER UND
DEBUGGER!

Dieser  Text  ist  nicht  als  eine  Anleitung gedacht, sondern nur als
KurzeinfÅhrung  in den Assembler. Die vollstÑndig Anleitung auf ca. 240
Seiten gibt es bei den Autoren.
Zur  Not  kann auch das ST-Magazin 11/89 und 12/89 herangezogen werden.
Dort hat die Referenzkarte den Assembler und Debugger zum Thema.

Nachtrag:  Es fehlen ziemlich viele Features in diesem READ_ME, es wird
           mir einfach zu viel... (Markus)

1.2 Features des Turbo-Ass
-Einfache und durchdachte (!) Bedienung.
-Der Assembler Åbersetzt durchschnittlich 1 300 000 Zeilen pro Minute.
-Syntax-Check bereits bei der Eingabe. Teilweise sogar Semantik-Check!
 Es  werden  sowohl  Tippfehler, wie auch doppelt vergebene Symbolnamen
 bereits bei der Eingabe gemeldet.
-Viele  besonders  leistungsfÑhige  Funktionen  des Editors, z.B. Suche
 von  Symbolen,  Ersetzen  von  Symbolen,  Einklappen vonProgrammteilen
 (wie in GFA-Basic 3.0), u.v.a.m.
-Fantastische Kombination von Debugger und Assembler. Bei einem Absturz
 eines  Programms  im  Debugger  kann  der  Assembler  automatisch  die
 Absturzadresse in eine Zeilennummer umrechnen!!!
-Eigene   Tastatur-  und  Bildschirmtreiber  =>  selbst  bei  hÑrtesten
 ProgrammabstÅrzen funktionieren Assembler und Debugger noch.
-KEINE Makros!!!
-u.v.a.m.

1.3 Was ist Shareware
-Jeder  kann/darf/muû/soll  den  Turbo-Ass kopieren! Dabei sollten aber
 stets ALLE (!) Dateien mitkopiert werden.
-Wem den Assembler gefÑllt, sollte uns fairerweise 50DM Åberweisen. Das
 hat fÅr alle Parteien vorteile:

 FÅr uns:
 -Wir  arbeiten  nicht ganz umsonst (im Turbo-Ass stecken 3 "Mannjahre"
  Arbeit)

 FÅr den User:
 -Er bekommt eine 240 Seiten starke Anleitung
 -Er bekommt die neuste Version mit persînlicher Seriennummer
 -Er bekommt das erste Update kostenlos
 -Er erhÑlt bei gefundenen Fehlern eine fehlerfreie Version
 -Er kann sich bei Problemen an uns wenden
 -Er  bekommt  fÅr  jeden User, der bei Registierung seine Seriennummer
  angibt,   10DM   (allerdings   maximal   10  mal,  wir  wollen  keine
  PD-Vertriebe  finanzieren).  Das  Geld  ist also eine "EntschÑdigung"
  fÅr das VorfÅhren des Assemblers und das Kopieren.
 -Nochmal:  LÑût  sich jemand registrieren, so gibt er die Seriennummer
  des  vorher  benutzen Assemblers an. Der User, dem diese Seriennummer
  gehîrt, bekommt vom uns 10DM. Alles klar?

Wer diese Angebot annehmen will, wende sich bitte an:

                Markus Fritze
                Birkhahnkamp 38
                2000 Norderstedt 1
                Tel: 040/5223955
                     (ab 18Uhr, auch am Wochenende (NIE VOR 12UHR!!!))
                BLZ: 20069111, Norderstedter Bank
                     Kontonummer: 407860

Ich  bitte  allerdings  teilweise um etwas Geduld; ich hoffe die meiste
Post  am  selben  Tag zu erledigen, wenn aber keine Anleitungen mehr da
sind  oder  wenn  wir gerade einige Neuerungen  implementieren, kann es
schon  mal  etwas  dauern (Wenn nach 2-3 Wochen allerdings nix passiert
kann eine Anfrage klÑren, ob die Post auch angekommen ist).


1.4 Hardwarevorraussetzungen
Atari  ST mit 512k, wobei allerdings erst ab 1Mb Assembler und Debugger
gemeinsam  im  RAM  gehalten  werden kînnen, was seinerseits wieder ein
sehr  wirksames  Debugging  erst  ermîglicht. Die hohe Auflîsung bietet
sich   wohl   eher   an,   als  die  mittlere  Auflîsung  (Ist  einfach
augenfreundlicher);  aber der Turbo-Ass lÑuft sowohl in Farbe, wie auch
in S/W.

1.5 Installation
TURBOASS.PRG,  TURBOASS.CFG, TURBOASS.DAT, BUGABOO.PRG und CALL.PRG auf
eine Disk, bzw. in einen Ordner kopieren. Das war's.

1.6 Zu den Autoren
Sîren  Hellwig und ich (Markus Fritze) sind zur Zeit beide 21 Jahre alt
(nein,  nicht  zusammen...)  und studieren technische Informatik an der
FH-Wedel  bei  Hamburg.  Deswegen  bitte  wir  auch  teilweise um etwas
Geduld,  wenn  Anfragen  nach  Updates,  etc.  kommen; das Studium geht
leider vor. Zudem beantworte ich jeden Brief, der RÅckporto beinhaltet.
Post  ohne  RÅckporto  wird  nur  in  AusnahmefÑllen  beantwortet  (Zur
Registrierung ist KEIN RÅckporto nîtig!)

1.7 Haftung/Rechte
Alle  Rechte  am  Turbo-Ass  liegen  bei  ‰-soft.  Wobei  jeder  seinen
Assembler  beliebig  kopieren  darf.  Auch  das Upload in Mailboxen ist
erlaubt.  Der  Turbo-Ass  und  das Handbuch wurden mit grîûter Sorgfalt
erstellt.  Leider  sind  Fehler nie auzuschlieûen, deswegen mîchten wir
sie   darauf   hinweisen,   daû   wir   weder  eine  Garantie  fÅr  die
Fehlerfreiheit  geben, noch die Haftung fÅr irgendwelche Folgen, gleich
ob  durch  Fehler  im  Handbuch,  in  der Software oder in der Hardware
verursacht,  Åbernehmen  kînnen.  Es wird wohl jeder verstehen, daû wir
keine  besondere  Begeisterung  verspÅren,  wenn  jemand behauptet, der
Assembler  habe  im seine Platte mit Sourcetexten im Werte von mehreren
Millionen  Mark  zerstîrt,  uns auf Schadenersatz verklagen will. Also:
Benutzung  auf  eigene  Gefahr!  (Dieser  Abschnitt gilt wohl bei allen
Softwarefirmen.


2 Der Assembler

2.1 BenutzeroberflÑche
Die  BenutzeroberflÑche  ist  nicht  von  GEM  o.Ñ.  abhÑngig, d.h. neu
programmiert,  das  hat  den  Vorteil, daû der Assembler sicherer gegen
AbstÅrze  und  auch  schneller ist. Zudem konnten einige nette Features
implementiert werden. Trotzdem sollte die Umstellung von GEM wohl nicht
ins  Gewicht fallen. Die kleinen Buchstaben in den Buttons bewirken mit
ALT zusammen gedrÅckt, das Anklicken des Buttons wie mit der Maus.

2.2 Die Maus im Assembler
Man  kann  mit  der Maus eine ganze Menge Dinge machen, hier sei jedoch
nur die Benutzung im Assembler erklÑrt:

Im Sourcetext:
Linke Maustaste:
Einfachklick: Cursor setzen
langer Klick: Block markieren (mit Scrollen)
Doppelklick : Sprung zur Definition des angeklickten Symbols

Rechte Maustaste:
Einfachklick: Sourcetext scrollen (nur am Rand klicken!)
Doppelklick : Formel in den Rechner Åbernehmen

In der Statuszeile:
einfach alles mal mit links bzw. rechts anklicken...

2.3 Der Editor
Jede  eingegebene Zeile wird automatisch auf ihren Syntax und teilweise
auch  auf  die  Semantik ÅberprÅft. Wenn die Zeile fehlerfrei ist, wird
sie  sofort  formatiert ausgegeben. Bei einem Eingabefehler wird in der
Statuszeile die Fehlermeldung angezeigt.

2.4 Besonderheiten
Als Adressierungsart wird auch "absolut short" direkt unterstÅtzt. Dazu
ist  hinter  der  Adresse  ".w"  anzugeben.  Line-A-Routinen kînnen mit
"LINEA #Nummer" eingegeben werden. Der Assembler wandelt nicht-Motorola
Eingaben wenn mîglich automatisch in das Motorola-Format um.

2.5 Optimierungen
Der  Assembler  kann  einige  Optimierungen  selbststÑndig finden. Dazu
gehîren:
Absolut lang    -> relativ
relativ         -> relativ short
Absolut lang    -> PC-relativ
MOVE.L #xx,A0   -> LEA xx,A0 (wenn dannach PC-relativ was bringt)
MOVE.L #xx,-(SP)-> PEA xx,A0 (wenn dannach PC-relativ was bringt)
Ferner  werden  einige fÅr C-Compiler typische SprÅnge gefunden (z.B. 2
aufeinanderfolgende BRA, wobei das 2.BRA nie angesprungen werden kann)
Wenn der Assembler optimieren kann, erscheint nach dem Assemblieren ein
Button  "ANPASSEN",  welcher  die Optimierungen im Sourcetext vornimmt.
Dabei kann auch zurÅck-"optimiert" werden, wenn dies nîtig sein sollte.

2.6 Formeln
Alles was so Standard ist: + - * / ! (log.NOT) ~ (NOT bzw. EOR)
                           << (SHL) >> (SHR) | (OR) & (AND)
                           sowie Vergleiche

Als Zahlenbasis sind: . oder nix : Dezimal
                      $          : Hexadezimal
                      %          : BinÑr
                      " oder '   : ASCII

Als interne Variablen sind ^^DATE (GEMDOS-Datum), ^^TIME (GEMDOS-Zeit)
* (akt.PC), ^^RSCOUNT (akt.Wert des RS-ZÑhlers) und ^^SYMTAB (<>0, wenn
Symboltabelle erzeugt wird)

Symbole  sind  max.23  Zeichen  lang.  Alle  Zeichen  sind signifikant.
Erlaubt sind auch Umlaute und alle anderen Zeichen > 126.

2.7 Tastaturkommandos
Cursortasten, Backspace, etc. wie gewohnt
CTRL-Y, CTRL-B, etc. wie in TEMPUS
CTRL-D verdoppelt die Cursorzeile.
CTRL-M/ALT-M ermîglicht das Verschieben der Zeile.
CTRL-W Ñndert die Zahlenbasis der Zahl unter dem Cursor
CTRL-U  markiert  alle  Zeichen  mit  Warnungen,  in welchen ein Symbol
 definiert  ist,  welches  nirgends  benutzt wird. Damit kann man prima
 unbenutzt Unterprogramme finden!
ALT-Zehnerblock wie bei MS-DOS
ESC+Buchstabe AbkÅrzung fÅr einen Befehl
CTRL-ESC  Tastaturmakro beginnen. Dann zu belegende Taste drÅcken. Alle
folgenden  Tasten  (nicht  die Maus!) werden aufgezeichnet. Mit ALT-ESC
wird die Definition abgeschlossen. Die belegte Taste kann mit CTRL-ESC,
Taste, ALT-ESC wieder freigegeben werden.

2.8 Ein paar Worte zu den Drop-Down-MenÅs
Mit  "Laden..."  kann  auch  ein  ASCII-Text eingeladen werden. Er wird
dabei automatisch ins interne Format gewandelt.
"Symbol  suchen..."  und  "Symbol ersetzen..." ermîglichen das schnelle
Finden  bzw.  schnelle  Ersetzen  von  Symbolen. Dabei kînnen z.B. alle
Symbole  gefunden  werden,  die mit "M" anfangen (Maske:"M*"), ohne daû
jeder MOVE-Befehl gefunden wird (wie bei ASCII-Editoren Åblich).
"Sprung  zu  Zeile.." ermîglich auch das Springen zu Symboldefinitionen
(Eingabe:z.B."M*").
Die  Dialogboxen im "Einstellungen" MenÅ sind zum Teil selbsterklÑrend,
der  Rest  ist  entweder unwichtig oder zu kompliziert, als daû er hier
erklÑrt werden kînnte.

2.9 Der Assembler
Wird mit F1 aufgerufen. Treten bei der Assemblierung Fehler auf, werden
alle fehlerhaften Zeilen markiert. Nach der Assemblierung kann man dann
mit  CTRL-J  bzw.  Shift-CTRL-J  von  Fehler  zu  Fehler  springen. Der
Assembler  speichert  die  Fehler,  die Cursorposition, die Marker etc.
Åbrigens mit dem Sourcetext ab!

In  der Dialogbox nach (!) der Assemblierung, kînnen noch einige Extras
eingestellt werden:
-Soll  eine  Symboltabelle  an das Programm gehÑngt werden (bzw. an den
 Debugger Åbergeben werden)?
-Ferner   kann   das   erzeugte   Programm  in  verschiedenen  Formaten
 abgespeichern. Mîglich sind:
 DEBUGGER Sprung in den Debugger mit ProgrammÅbergabe (KEIN SPEICHERN)
 STANDARD Programm abspeichern (halt ganz normal...)
 DATAS    Data-Zeilen erzeugen (fÅr OMIKRON.Basic)
 ABSOLUT  Programm fÅr eine best. Adresse (z.B. EPROM) erzeugen
 BASIC    spezielles Format fÅr Basic, welches sich selbst reloziert
 OMINLINE INLINE-Zeile fÅr OMIKRON-Basic erzeugen
 PARALLEL spez.öbertragungsformat zum Amiga
 SMALLDRI DRI-Format erzeugen (allerdings OHNE Importe)
 GFAINLINE GFA-Inline-Format erzeugen.
 FSTANDARD Fast-Load-Bit im Header setzen (ST-Magazin 11/89), sonst wie
           STANDARD

2.10 Pseudo-Opcodes des Assemblers
DC,  DS,  BLK,  DCB, EVEN, ALIGN, TEXT, DATA, BSS, END, =, EQU, GLOBAL,
CNOP, ORG, ILLEGAL und REG
wie Åblich.
DXSET LÑnge[,FÅllwert] Tabelle definieren
DX 'String' Tabelleneintrag auf LÑnge mit FÅllwert aufgefÅllt
RS, RSRESET, RSSET, RSEVEN, RSBSS Relatives Segment
OPT D+ normale Symboltabelle an
OPT X+ erweiterte Symboltabelle an
OPT W+ Warnungen an
OPT P+ PC-relatives Programm muû erzeugt werden
OPT O+ Optimierungen an
Mit '-' kann etwas ausgeschaltet werden
OUTPUT 'Filename' Default-Filename
PATH 'Pfad' Pfad fÅr IBYTES setzen
IBYTES 'DEGAS.PI3',32000,34 LÑdt ein Daten-File der LÑnge 32000 ab Byte
34 der Datei ein (Hier: ein Degas-Bild)
BASE is' viel zu kompliziert...
REPT  Anzahl,  ENDR  wiederholt  Anzahl mal den Sourcetextteil zwischen
REPT und ENDR
IF, ELSE, ENDC bedingte Assemblierung
FAIL Assemblierung abbrechen


3 Der Debugger
3.1 Vorwort
Es  ist eigentlich unmîglich den Debugger KURZ zu beschreiben, deswegen
hier nur die wichtigsten Befehle (mit HELP kann man alle mal sehen bzw.
in der Anleitung)

3.2 Allgemeines
Der  Debugger  benutzt  selber  keine I/O-Routinen des TOS, d.h. er ist
ziemlich unanfÑllig gegen AbstÅrze. Bei Lade-Operationen u.Ñ. wird aber
dann natÅrlich doch auf's GEMDOS zurÅckgegriffen.

Er  verwaltet  eine eigene Bildschirmseite, sodaû Programm und Debugger
sich nicht auf einer gemeinsamen Seite tummeln.

Das Debugging kann sowohl mit Tastatur und Maus erfolgen.

Der  Debugger  kann  resident  im  RAM gehalten werden, indem er in den
AUTO-Ordner  kopiert  wird  oder mit dem Befehl RESIDENT gehalten wird.
Der  Debugger  kann  dann  mit  CALL.PRG  aufgerufen  werden.  Auch der
Assembler  kann  auf  den  Debugger  zugreifen  (Er  kann ihn aber auch
nachladen).

3.3 Die Bedienung
Die  2  oberen  Zeilen  entsprechen  den  Funktionstasten (mit und ohne
Shift).  Die  3  Folgezeilen stellen die Registerinhalte und Flags dar.
Alle Teilen in diesen 5 Zeilen kînnen mit der Maus ausgelîst werden.

Die restlichen (max.20 Zeilen) sind frei verÑnderbar. Hier erfolgen die
Eingaben, die Ausgaben. Hier tobt das Leben...

Die  Tastaturbelegung  (Cursortasten, CTRL-M, CTRL-1, etc.) ist Ñhnlich
der des Assemblers.

Eingaben  erfolgen  stets  ab  Zeilenanfang  bzw.  hinter  der Hexzahl.
Leerzeichen werden ignoriert bzw. dienen als Trenner.

Wenn  der  Assembler  den  Debugger  aufgerufen hat, kann man CTRL-HELP
zurÅckspringen.  Dabei  wird der aktuelle PC-Stand in eine Zeilennummer
UMGERECHNET.  D.h.  wenn  ein Programm beim Debuggen abgestÅrzt ist und
der  PC im Programm steht, kann man CTRL-HELP zur entsprechenden Stelle
im Sourcetext springen.

Mit  SHIFT-SHIFT  kann  ein  laufendes  Programm angehalten werden. Der
Ring-Indikator  funktioniert  allerdings  auch.  Der Debugger ist zudem
RESETFEST. Als Notbremse ab und zu sinnvoll.

F1  - FÅhrt den nÑchsten Befehl aus
SF1 - Bricht beim nÑchsten Sprungbefehl ab. Simuliert den Tracemode des
      68020 Prozessors.
F2  - Setzt hinter den nÑchsten Befehl einen Breakpoint und startet das
      Programm.  Damit  kann  z.B. schnell ein Unterprogramm ausgefÅhrt
      werden oder ein DBRA beendet werden.
SF2 - nicht weiter wichtig
F3  -  Startet  das  Programm und bricht beim nÑchsten RTS ab. ACHTUNG!
      Wenn mit MOVEM Werte auf dem Stack gerettet werden => Bomb!
SF3 - wie F3 nur bis zum nÑchsten RTE
F4  - FÅhrt den nÑchsten TRAP NICHT aus, sondern springt in ihn hinein.
SF4 - Programm ohne Endebedingung starten
F5  - nÑchsten Befehl ignorieren, d.h. Åberspringen
SF5 - Insert/Overwrite toggeln
F6  - akt.Directory anzeigen
SF6 - die umgerechneten Marker des Assemblers anzeigen.
F7  - Memorydump ab dem PC
SF7 - Breakpoints anzeigen
F8  - Disassemble mit Dump ab PC
SF8 - Info Åber die Speicherbelegung
F9  - List ab PC (mit Symbolen, wenn vorhanden)
SF9 - Screen lîschen, Warmstart
F10 - Umschalten der Bildschirmseite (Toggeln)
SF10- Quit mit Sicherheitsabfrage

3.4 Die Befehle
Alle  Befehle kînnen auf ein Minimum abgekÅrzt werden. An ALLEN Stellen
sind als Parameter beliebige AusdrÅcke erlaubt (d.h. Formeln etc.)

?Term   Rechnet den Term aus
Term   darf  (bis  auf  Vergleiche)  alle  Operationen  des  Assemblers
enthalten.  Zudem  ist mit {400}.l eine indirekte Adressierung mîglich.
".l" gibt dabei die Zugriffsbreite an.
Alle  Zahlen werden als HEXZAHLEN angesehen. Dezimalzahlen sind mit "."
einzuleiten.  Bei  einer  Symboltabelle  kann man mit ".Symbolname" auf
dieses zugreifen.

Definierte Variablen (ein Teil davon)
^D0-^D7 Die Register D0-D7
^A0-^A7 Der Register A0-A7
PC, USP, SSP, SR, CCR, SP Die gleichnamigen Register
^M0-^M9 Die umgerechneten Marker des Assemblers

Alle obigen Variablen sind mit
LET Variable=Term Ñnderbar.
LET lÑût sich mit "~" abkÅrzen.

Noch ein paar Read-Only-Variablen:
TEXT, DATA, BSS, START, END, BASEPAGE, BP, ACT_PD, MEMBASE, SAVEAREA

Es gibt noch etwa 20-30 weitere nicht so wichtige Variablen.

BREAKPOINT [Nummer=Adresse[,[*|=Wert|Anzahl|?Bedingung]|K]]
Breakpoints anzeigen, lîschen, Ñndern, setzen

B5=PC+.100 Breakpoint 5 (0-15 ist mgl) auf Adresse PC+100 setzen
B K        Alle Breakpoints lîschen
B          Alle Breakpoints anzeigen
BK3        Breakpoint 3 lîschen

B0=Adr,Anzahl   : Breakpoint bricht beim Anzahl. Erreichen ab.
B0=Adr,*        :  Breakpoint  bleibt auch nach dem Erreichen erhalten.
                  Normale Breakpoints werden automatisch gelîscht.
B0=Adr,=Wert    :  ZÑhler  auf  die  Adresse  Adr  setzen. In ^BC0 wird
                  hochgezÑhlt wie oft die Adresse erreicht wurde.
B0=Adr,?Term    : Bedingter BKPT, Abbruch, wenn Term<>0
   z.B. B0=Adr,?^D0=4711 => Abbrucht, wenn PC=Adr UND D0=$4711
GO [Adr]        : Programm an Adresse Adr, bzw. PC starten
TRACE           : Wie F1
SHOWMEMORY Term : 16 Bytes ab Term stets anzeigen
UNTRACE [Adr]   : solange Tracen, bis Bedingung erfÅllt
IF Term         : Bedingung fÅr UNTRACE
OBSERVE Trapno,Funkno : Abbruch, wenn Trapno(Funktion) ausgefÅhrt wird.
   z.B. OBSERVE 14,8  : Abbruch bei XBIOS(8) = Floprd()
CLS             : 2.Bildschirmseite lîschen
MOUSEON
MOUSEOFF        : VDI-Maus an/aus
|Befehl         : Befehl ausfÅhren (zum Testen echt prima)
LEXECUTE  "Filename"[,"Commandline"]  :  Programm  ausfÅhrbar laden (=>
                  Pexec()) Dann mit GO zu starten.
LOAD "Filename"[,Adresse] : File nicht ausfÅhrbar laden
SAVE ["Filename"[,Adresse[,Endadresse]]] : File abspeichern
DIR Pfadmaske   : Directory anzeigen
Pbefehl         : P vor einem Befehl leitet diesen zum Drucker um
FOPEN Filename
Fbefehl         : Ausgabe eines Befehls in eine Datei
FCLOSE
ERASE, KILL Filename : Datei lîschen (mit Jokern!)
FREE            : Freier Hauptspeicher
FREE Drive      : Freier Platz auf einem Laufwerk
MKDIRECTORY Name : Ordner erstellen
RMDIRECTORY Name : Ordner lîschen (wenn leer)
NAME oldname,newname : File umnennen
FATTRIBUT Filename,attribut : File-Attribut Ñndern/setzen
FORMAT DS/SS,Laufwerk : Disk formatieren
TYPE Filename   : ASCII-Datei anzeigen (SPACE hÑlt Ausgabe an)
READSEKTOR Track,Sektor,Seite,Adresse,Laufwerk (0 oder 1)
                Sektor mit XBIOS(8) einlesen
WRITESEKTOR s.o.
                Sektor mit XBIOS(9) schreiben


Alle  in  diesem  Abschnitt  angegebenden Befehle erlauben den gleichen
Syntaxbei  den  Parametern, der deswegen an dieser Stelle erklÑrt wird,
und im folgenden nur noch mit [Parameter] bezeichnet wird.Es gilt also:

[Parameter] = [Von][[,]#[Zeilen]|,Bis|[,][Bytes[]]]

Es   sind   also  alle  Parameter  wahlfrei,  d.h.  man  braucht  keine
Parameterangeben. Der Debugger nimmt dann vorgegebene interne Werte.

Wenn   der   Ausdruck  "Von"  fehlt,  wird  ab  der  aktuellen  Adresse
z.B.disassembliert.  Die aktuelle Adresse ist die Zahl am Zeilenanfang,
bzw.wenn diese fehlt, die zuletzt benutzte Adresse.

Als  Endadresse  gilt  der  Ausdruck  "Bis", der jedoch nicht angegeben
werdenmuû.  Wird  statt  "Bis"  ein "#" angegeben wird genau eine Zeile
ausgegeben. Ein dem "#" folgender Term, gilt als Zeilenanzahl.Es kînnen
somit z.B. genau 8 Zeilen ausgegeben werden. Es werden jedochmaximal 99
Zeilen  ausgegeben.Fehlt die Endangabe gÑnzlich, werden (normalerweise)
16  Zeilen ausgegeben.Die Anzahl lÑût sich jedoch einstellen, indem man
die Variable "Lines" entsprechend Ñndert.Die letzte Mîglichkeit ist die
Angabe  der  Byteanzahl  in  eckigen Klammern.Sie kann genauso, wie die
Zeilenanzahl  angegeben werden. Die "]" ist optional, d.h. man kann sie
auch weglassen.

Beispiel:
"d text #5"
Disassembliert 5 Zeilen ab Anfang des geladenen Programms.

Beispiel:
"m data[30]"
Ein Memorydump des DATA-Segments (48 Bytes lang).

DISASSEMBLE [Parameter] Disassemble mit Dump
                        Dump kann geÑndert werden!
LIST [Paramter]         Disassemble ohne Dump mit Symbolen
                        Opcodes  kînnen  geÑndert  werden (RETURN nicht
                        vergessen)
SYMBOLTABLE [Parameter] evtl. vorhandene Symboltabelle anzeigen
MEMORY[.B|.W|.L][Parameter] Memorydump mit Ausgabebreite (énderbar)
ASCII [Parameter]       ASCII-Dump (énderbar)

FIND  [Von,Bis],Terme{,Term}  geladenes  Programm  oder Speicherbereich
                        nach den Termen durchsuchen
HUNT  s.o.              wie Find, jedoch nur auf geraden Adressen
ASCFIND   [Von,Bis],String   ASCII-Suche  im  Disassemblerlisting  (mit
                        Jokern). Langsam, aber ab und zu praktisch
CONTINUE                Hunt,  Find  oder  ASCFIND fortsetzen, wenn mit
                        ESC abgebrochen
INFO                    mal ausprobieren
SYSINFO                 auch mal ausprobieren
MOVE, COPY Von,Bis,Nach Speicherblock kopieren
FILL Von,Bis,Term{,Term} Speicherblock fÅllen
CLR [Von,Bis]           Speicherblock lîschen (oder alles)
COMPARE Von,Bis,Adr     Bereich Von,Bis mit Bereich ab Adr vergleichen
EXIT, QUIT, SYSTEM      Debugger verlassen
RESIDENT                Debugger resident halten
SET, LET, ~             siehe oben
RESET ALL               Debugger-Kaltstart
HELP                    Gibt  alle  Befehle  unsortiert  aus  (wie  man
                        sieht, ein paar mehr als hier beschrieben)

4 Was bringt die Zukunft?
Nun,  daû hÑngt sehr vom Erfolg der Shareware-Konzeptes ab. Sicher, wir
machen  weiter,  aber  ob  wir  einen  68020/30  Assembler mit FPU- und
PMMU-Support (Atari TT) mit Makros, lokalen Symbolen etc. als Shareware
rausbringen? Nun, wenn es sich lohnt immer..

Was kommt denn als nÑchstes?
Erstmal  soll man fÅr das DRI-Linkformat die PC-relativen Optimierungen
Åber  Segmentgrenzen  abschalten kînnen (speziell fÅr Laurenz PrÅûner).
Dann kînnen keine Probleme mehr beim Linken auftreten.
Der Sourcecode-Debugger ist schon ganz nett (wenn auch bei Sourcetexten
mit  >10000 Zeilen recht langsam => Arbeit, Arbeit,... ), kann man doch
jederzeit gucken, an welcher Stelle der PC im Sourcetext steht, ohne in
den  Assembler  zurÅckzumÅssen.  Die Remarks zu sehen ist ja auch nicht
schlecht.  Und  das  tollste:  das  Ganze  spart  auch noch Platz! Beim
normalen    Debuggen    wird    eine   Symboltabelle   benîtigt,   beim
Sourcecode-Debugging  wird  dagegen  laufend  umgerechnet, wo der PC im
Sourcetext  steht  (und  das recht fix (bei Sourcetexten <10000 Zeilen,
s.o.)).
