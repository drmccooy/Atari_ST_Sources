;====================================================================
;
;                         DIWO's Little NET
;
;  Programm zur Kopplung 2er ATARI ST Åber die MIDI-Schnittstelle.
;
;                                              Jan 89 by Dirk Woitha
;====================================================================

NEIN        = 0
JA          = ~NEIN

TESTEN      = NEIN

; INCLUDES

            .INCLUDE 'ACC_EVNT.IS'

            .TEXT 
; Definition der Resourcekonstanten

MAIN        = 0
NETFORM     = 0
READONLY    = 3
READWRIT    = 4       ; Status enthÑlt Nummer der 3 Knîpfe
INAKTIV     = 5
DRIVEA      = 10
DRIVEB      = 11
DRIVEC      = 12
DRIVED      = 13
DRIVEE      = 14
DRIVEF      = 15
DRIVEG      = 16
DRIVEH      = 17
DRIVEI      = 18
DRIVEJ      = 19
ZEILE1      = 21
ZEILE2      = 22
SCHICKE     = 24
OK          = 25

; Sonstige Definitionen

TIME_OUT    = 30*200  ; TIME-OUT-ZEIT Netz in sec
DRIVE_N     = 'N'-'A' ; Nummer fÅr Drive N

MIDI_CNTR   = $fffc04 ; Adressen der MIDI-ACIA
MIDI_DATA   = $fffc06


; Telegrammkennungen und LÑngen
;
; Das Low-Nibble liefert jeweils den Offset fÅr die LÑngentabelle (Tele-Tab)
; Das High-Nibble ist invers dazu (Kontrolle)
; Bit 1 = 0    Telegramm fÅr E_ANF_BUF bestimmt (Anforderungstelegramm)
; Bit 1 = 1       "       "  E_ANT_BUF    "     (Antworttelegramm)

BPB_ANF     = $f0     ; Anforderung BPB
L_BPB_ANF   = 3       ; LÑnge ohne Kennung
BPB_SEND    = $d2     ; BPB senden
L_BPB_SEND  = 25
SEC_WR      = $b4     ; Sektor schreiben
L_SEC_WR    = 517
SEC_BEST    = $96     ; Sektor betÑtigen
L_SEC_BEST  = 7
SEC_ANF     = $78     ; Sektor anfordern
L_SEC_ANF   = 5
SEC_EMPF    = $5a     ; Sektor empfangen
L_SEC_EMPF  = 519
NOT_ACK     = $1e     ; negative BestÑtigung
L_NOT_ACK   = 3

MESSAGE     = $3c     ; Message Telegramm
L_MESSAGE   = 63

;-----------------------------------------------------------------------------
;
;                        Aufbau der Telegramme
;                        =====================
;
;  In den Empfangsbuffern steht die Kennung immer nur einmal.
;  Vor jedem Telegramm werden noch 2 Sync-, nach jedem Telegramm
;  3 Sync-Bytes (0) gesendet
;
;
;  1.)  BPB anfordern:
;                          3 Byte    Kennung      (F0)  -> LÑnge 3
;                          1 Byte    Laufwerk     (0...)
;                          2 Byte    Checksumme
;
;  2.)  BPB senden:
;                          3 Byte    Kennung      (D2)  -> LÑnge 25
;                          1 Byte    Laufwerk     (0...)
;                          1 Byte    Status       (0 = BPB OK / FF = kein BPB)
;                         20 Byte    BPB
;                          1 Byte    Dummy
;                          2 Byte    Checksumme
;
;  3.)  Sektor schreiben:
;                          3 Byte    Kennung      (B4)  -> LÑnge 517
;                          1 Byte    Laufwerk     (0...)
;                          2 Byte    Sektornummer (0...)
;                        512 Byte    Sektor
;                          2 Byte    Checksumme
;
;  4.)  SchreibbestÑt.:
;                          3 Byte    Kennung      (96)  -> LÑnge 7
;                          1 Byte    Laufwerk     (0...)
;                          2 Byte    Sektornummer (0...)
;                          1 Byte    Status       (0 = OK / neg. = Fehler)
;                          1 Byte    Dummy
;                          2 Byte    Checksumme
;
;  5.)  Sektor anfordern:
;                          3 Byte    Kennung      (78)  -> LÑnge 5
;                          1 Byte    Laufwerk     (0...)
;                          2 Byte    Sektornummer (0...)
;                          2 Byte    Checksumme
;
;  6.)  Sektor lesen:
;                          3 Byte    Kennung      (5A)  -> LÑnge 519
;                          1 Byte    Laufwerk     (0...)
;                          2 Byte    Sektornummer (0...)
;                          1 Byte    Status       (0 = OK / neg. = Fehler)
;                        512 Byte    Sektor
;                          1 Byte    Dummy
;                          2 Byte    Checksumme
;
;  7.)  negative BestÑt.:
;                          3 Byte    Kennung       (1E)  -> LÑnge 3
;                          1 Byte    Dummy
;                          2 Byte    Checksumme
;
;  8.)  Message senden:    3 Byte    Kennung       (3c)  -> LÑnge 63
;                         30 Byte    Zeile 1
;                         30 Byte    Zeile 2
;                          1 Byte    Dummy
;                          2 Byte    Checksumme
;
;-----------------------------------------------------------------------------



;=============================================================
;
; Programmteil vor der Accessorieanmeldung
;
;=============================================================


ACC_RTM:    move.l    #RSC_NAM,(a6)         ;Resource laden
            move.w    #RSRC_LOAD,d0
            move.l    #$00010100,d1
            bsr       AESCALL


            move.w    #R_TREE,(a5)          ; Adresse des Formulars bestimmen
            move.w    #NETFORM,2(a5)
            move.w    #RSRC_GADDR,d0
            move.l    #$02010001,d1
            bsr       AESCALL
            move.l    ADDROUT(pc),FORM_ADR

            move.w    #ZEILE1,d0            ; Strings lîschen
            bsr       CLRTXT
            move.w    #ZEILE2,d0
            bsr       CLRTXT

            st        CHANGE                ; Media-Change setzen
            move.b    #READONLY,STATUS      ; Netz-Status READ-ONLY
            clr.b     LAUFWERK              ; Lauferk A vorbelegen
            clr.w     E_ANF_ZAHL            ; Empfangsflags lîschen
            clr.w     E_ANT_ZAHL
            clr.w     E_ANT_ZAHL
            clr.w     S_ANF_ZAHL
            clr.w     S_ANT_ZAHL
            clr.w     S_MES_ZAHL

            pea       BINDE_EIN(pc)         ; Laufwerk N einbinden
            move.w    #SUPEXEC,-(sp)
            trap      #XBIOS
            addq.l    #6,sp

            move.w    #KBDVBASE,-(sp)       ; Interruptpointer holen
            trap      #XBIOS
            addq.l    #2,sp

            movea.l   d0,a0
            move.l    #MIDI_INT,28(a0)      ; eigenen Kram einbinden

            moveq.l   #0,d0                 ; Accessorie anmelden
            rts       
;--------------------------------------------------
; Laufwerksroutinen im Super-Modus einbinden
;--------------------------------------------------

BINDE_EIN:  move.l    HDV_BPB,OLD_BPB       ; neue Bios-Paramerter-Block Routine
            move.l    #NEW_BPB,HDV_BPB
            move.l    HDV_MEDIACH,OLD_MEDIA ; neue Media-Change-Routine
            move.l    #NEW_MEDIA,HDV_MEDIACH
            move.l    HDV_RW,OLD_RW         ; neue RW-Routine
            move.l    #NEW_RW,HDV_RW

            move.l    TRAP_13,OLD_BIOS      ; alte Bios-Adresse merken
            move.l    #BIOS_TEST,TRAP_13

            ori.w     #%10000000000000,DRVBITS+2 ; Drive N eintragen

            rts       

;====================================================
;
; Programmteil bei Accessorieaufruf
;
;====================================================

ACC_PGM:    move.l    FORM_ADR(pc),(a6)     ; form_center:
            move.w    #FORM_CENTER,d0       ; Formular zentrieren
            move.l    #$00050100,d1
            bsr       AESCALL
            lea.l     INTOUT(pc),a0         ; Koordinaten retten
            move.l    2(a0),OB_X
            move.l    6(a0),OB_BR

            move.w    #FORM_DIAL,d0         ; form_dial:
            move.l    #$09010100,d1         ; Bildschirm resevieren
            clr.w     (a5)                  ; Clipping setzen
            move.l    OB_X(pc),2(a5)
            move.l    OB_BR(pc),6(a5)
            move.l    2(a5),10(a5)
            move.l    6(a5),14(a5)
            bsr       AESCALL

            move.w    #WIND_UPDATE,d0       ; Mauskontrolle Åbernehmen
            move.l    #$01010100,d1
            move.w    #BEG_MCTRL,(a5)
            bsr       AESCALL

            move.w    #NETFORM,(a5)         ; objc_draw:
            move.w    #MAX_DEPTH,2(a5)      ; Formular zeichnen
            move.l    OB_X(pc),4(a5)
            move.l    OB_BR(pc),8(a5)
            move.l    FORM_ADR(pc),(a6)
            move.w    #OBJC_DRAW,d0
            move.l    #$06010100,d1
            bsr       AESCALL

; Dialog abwickeln

DO_FORM:    move.w    #FORM_DO,d0
            move.l    #$01010100,d1
            move.w    #ZEILE1,(a5)
            move.l    FORM_ADR(pc),(a6)
            bsr       AESCALL

            bclr      #15,d0                ; Doppelklick-Bit lîschen

            cmpi.w    #OK,d0                ; Klick auf OK
            beq       CLOSE_BOX             ; ja, dann fertig

            cmpi.w    #SCHICKE,d0           ; Text abschicken ?
            bne       NOT_SCHICKE

            lea.l     S_MES_BUF+2(pc),a0    ; Message Buffer aufbauen
            move.b    #MESSAGE,(a0)+        ; 3 * Kennung
            move.b    #MESSAGE,(a0)+
            move.b    #MESSAGE,(a0)+

            move.w    #ZEILE1,d0            ; Text eintragen
            bsr       GETTXT

            move.w    #ZEILE2,d0
            bsr       GETTXT

            pea       MESS_RAUS(pc)         ; Text abschicken
            move.w    #SUPEXEC,-(sp)
            trap      #XBIOS
            addq.l    #6,sp

W_LOOP:     tst.w     S_MES_ZAHL            ; warten bis abgeschickt
            bne       W_LOOP

            move.w    #OBJC_CHANGE,d0       ; Schicken Knopf wieder normal
            move.l    #$08010100,d1
            move.w    #SCHICKE,(a5)
            clr.w     2(a5)
            move.l    OB_X(pc),4(a5)
            move.l    OB_BR(pc),8(a5)
            move.w    #NORMAL,12(a5)
            move.w    #1,14(a5)
            move.l    FORM_ADR(pc),(a6)
            bsr       AESCALL

            bra       DO_FORM

NOT_SCHICKE:          
            cmpi.w    #READONLY,d0          ; Klick auf READ ONLY?
            bne       NOT_RO                ; nein
            move.b    #READONLY,STATUS      ; ja, dann Status READ ONLY setzen
            bra       DO_FORM               ; und wieder ins MenÅ
NOT_RO:     
            cmpi.w    #READWRIT,d0          ; Klick auf READ WRITE ?
            bne       NOT_RW                ; nein
            move.b    #READWRIT,STATUS      ; ja, dann status READ WRITE setzen
            bra       DO_FORM               ; und wieder ins MenÅ
NOT_RW:     
            cmpi.w    #INAKTIV,d0           ; Klick auf INAKTIV ?
            bne       NOT_INAKTIV           ; nein
            move.b    #INAKTIV,STATUS       ; ja, dann Status INAKTIV lîschen
            bra       DO_FORM               ; und wieder ins MenÅ
NOT_INAKTIV:          

            lea.l     DRIVE_TAB(pc),a0      ; Laufwerksknîpfe abfragen
            clr.b     d1                    ; LaufwerkszÑhler lîschen
NEXT_DRIVE: 
            cmp.w     (a0)+,d0              ; Laufwerk angeklickt
            beq       DRIVE_OK
            addq.b    #1,d1                 ; nein, dann nÑchstes Laufwerk
            bra       NEXT_DRIVE            ; ein Laufwerksknopf muû es ja sein
DRIVE_OK:   
            move.b    d1,LAUFWERK           ; Laufwerk merken
            bra       DO_FORM               ; und wieder ins MenÅ

; Dialog beenden

CLOSE_BOX:  
            st        CHANGE                ; Flag fÅr Media_Change setzen

            move.w    #WIND_UPDATE,d0       ; Mauskontrolle abgeben
            move.l    #$01010000,d1
            move.w    #END_MCTRL,(a5)
            bsr       AESCALL

            move.w    #FORM_DIAL,d0         ; Bildschirm freigeben
            move.l    #$09010100,d1
            move.w    #3,(a5)
            move.l    OB_X(pc),2(a5)
            move.l    OB_BR(pc),6(a5)
            move.l    2(a5),10(a5)
            move.l    6(a5),14(a5)
            bsr       AESCALL

            move.w    #OBJC_CHANGE,d0       ; OK Knopf wieder normal
            move.l    #$08010100,d1
            move.w    #OK,(a5)
            clr.w     2(a5)
            move.l    OB_X(pc),4(a5)
            move.l    OB_BR(pc),8(a5)
            move.w    #NORMAL,12(a5)
            clr.w     14(a5)
            move.l    FORM_ADR(pc),(a6)
            bsr       AESCALL

            rts       


;============================================================
;                       ACC_ETIM
;
;  Im Timer-Event schauen ob Text angekommen und darstellen
;
;============================================================

ACC_ETIM:   
            cmpi.b    #INAKTIV,STATUS       ; Netz aktiv?
            beq       END_EVNT

            tst.w     E_MES_ZAHL            ; Post da?
            beq       END_EVNT              ; nein

            clr.w     E_MES_ZAHL            ; ja, dann Flag lîschen

            lea.l     E_MES_BUF+1(pc),a0    ; Alert-Box aufbauen
            lea.l     LINE1(pc),a1
            bsr       TXTCPY

            lea.l     E_MES_BUF+31,a0
            lea.l     LINE2(pc),a1
            bsr       TXTCPY

            lea.l     POST_BOX(pc),a0       ; Meldung ausgeben
            bsr       DO_ALLERT

END_EVNT:   rts       




;================================================================
;                           ANRUF_TEST
;
;  Diese Routine wird bei jedem BIOS-Aufruf abgearbeitet und
;  beantwortet Telegrammanfragen
;
;================================================================

BIOS_TEST:  
            movea.l   sp,a0                 ; Mediach nach schreiben liefern
            btst      #5,(sp)               ; super modus aufruf
            bne.s     SMOD
            move.l    usp,a0
            subq.l    #6,a0
SMOD:       cmpi.w    #9,6(a0)              ; mediach Aufruf ?
            bne.s     KEIN_MEDIA
            move.w    8(a0),d0              ; Laufwerk holen
            andi.w    #$000f,d0             ; und maskieren
            lea.l     MEDIA_BUF(pc),a0
            tst.b     0(a0,d0.w)            ; Laufwerk beschrieben ?
            beq.s     KEIN_MEDIA            ; nî -> orginal routine
            sf        0(a0,d0.w)            ; flag zurÅcksetzen

            moveq.l   #2,d0                 ; media-change liefern
            rte                             ; und zurÅck


KEIN_MEDIA: move.l    OLD_BIOS(pc),-(sp)    ; Sprungadr. merken
TESTE_ANRUF:          
            tst.w     E_ANF_ZAHL            ; Telegramm da ?
            bne.s     DO_ANT                ; ja
NO_ANT:     rts                             ; nein -> weiter

DO_ANT:     bset      #0,BUSY_FLAG
            bne.s     NO_ANT                ; Darf nicht reentert werden
            move.l    sp,RETTE_SP           ; eigenen Stack aufbauen
            lea.l     STACK_NEU,sp
            movem.l   d0-d7/a0-a6,-(sp)
            move.l    ETV_CRITIC,RETTE_CRIT ; und Critical Error Handle
            move.l    #CRIT_NEU,ETV_CRITIC  ; sperren

            lea.l     E_ANF_BUF(pc),a0      ; Zeiger auf Empfangsbuffer

            move.w    -2(a0),d0             ; TelegrammlÑnge nach d0
            subq.w    #3,d0                 ; wegen dbra und LÑnge ohne CS
            lea.l     1(a0),a1              ; Telegrammanfang nach a1
            clr.w     d1                    ; Checksumme lîschen
            clr.w     d2

            clr.w     E_ANF_ZAHL            ; Empfangsflag lîschen
            cmpi.b    #INAKTIV,STATUS       ; Netz aktiv?
            beq       END_ANT               ; nein
CH_LOOP:    
            move.b    (a1)+,d2
            add.w     d2,d1
            dbra      d0,CH_LOOP

            cmp.w     (a1),d1               ; Checksumme testen
            beq       TELE_OK               ; ok, also verarbeiten

            lea.l     S_ANT_BUF+2(pc),a0    ; nein, also negativ antworten
            move.b    #NOT_ACK,(a0)+
            move.b    #NOT_ACK,(a0)+
            move.b    #NOT_ACK,(a0)+
            clr.b     (a0)+
            lea.l     S_ANT_BUF(pc),a0
            move.w    #L_NOT_ACK,d0
            bsr       CHECK_RAUS
            bra       END_ANT

TELE_OK:    
            cmpi.b    #BPB_ANF,(a0)         ; BPB Anforderung ?
            beq       ITS_BPBANF

            cmpi.b    #SEC_WR,(a0)          ; Sektor schreiben ?
            beq       ITS_WRITE

            cmpi.b    #SEC_ANF,(a0)         ; Sektor lesen?
            beq       ITS_READ

            bra       END_ANT               ; Unbekanntes Telegramm, also fertig

; BPB senden

ITS_BPBANF: 
            lea.l     S_ANT_BUF+2(pc),a1    ; Sendebuffer aufbauen
            move.b    #BPB_SEND,(a1)+       ; Kennung 3 mal eintragen
            move.b    #BPB_SEND,(a1)+
            move.b    #BPB_SEND,(a1)+
            move.b    1(a0),(a1)+           ; Laufwerk eintragen
            st        (a1)                  ; erst mal Fehler eintragen

            move.b    1(a0),d0              ; BPB holen
            andi.w    #$00ff,d0
            move.w    d0,-(sp)              ; Laufwerk auf Stack
            movea.l   HDV_BPB,a0
            jsr       (a0)                  ; hole bios parameter
            addq.l    #2,sp

            tst.l     d0                    ; Gibt es BPB ?
            beq       ANT_BPB               ; nein

            lea.l     S_ANT_BUF+6(pc),a1
            sf        (a1)+                 ; BPB OK eintragen
            movea.l   d0,a2                 ; und BPB Åbertragen
            move.w    #19,d0
COPY_BPB:   move.b    (a2)+,(a1)+
            dbra      d0,COPY_BPB
ANT_BPB:    
            move.w    #L_BPB_SEND,d0
            bra       SEND_ANT

; Sektor schreiben

ITS_WRITE:  lea.l     S_ANT_BUF+2(pc),a1    ; Sendebuffer aufbauen
            move.b    #SEC_BEST,(a1)+       ; Kennung 3 * eintragen
            move.b    #SEC_BEST,(a1)+
            move.b    #SEC_BEST,(a1)+
            move.b    1(a0),(a1)+           ; Laufwerk eintragen
            move.w    2(a0),(a1)+           ; Sektornummer eintragen

            cmpi.b    #READONLY,STATUS      ; Status READ-ONLY?
            beq       SEND_BEST

            move.b    1(a0),d0              ; Sektor schreiben
            andi.w    #$00ff,d0             ; Laufwerk
            move.w    d0,-(sp)
            move.w    2(a0),-(sp)           ; Sektornummer
            move.w    #1,-(sp)              ; 1 Sektor
            move.l    #E_ANF_BUF+4,-(sp)    ; Adr. Sektorbuffer
            move.w    #1,-(sp)              ; Flag: schreiben
            movea.l   HDV_RW,a0
            jsr       (a0)
            lea.l     12(sp),sp

            move.b    d0,S_ANT_BUF+8        ; Status setzen
            lea.l     MEDIA_BUF(pc),a0
            move.b    S_ANT_BUF+5(pc),d0    ; laufwerk
            andi.w    #$000f,d0
            st        0(a0,d0.w)            ; media-change merken

SEND_BEST:  move.w    #L_SEC_BEST,d0
            bra       SEND_ANT

; Sektor lesen

ITS_READ:   lea.l     S_ANT_BUF+2(pc),a1    ; Sendebuffer aufbauen
            move.b    #SEC_EMPF,(a1)+       ; Kennung 3 * eintragen
            move.b    #SEC_EMPF,(a1)+
            move.b    #SEC_EMPF,(a1)+
            move.b    1(a0),(a1)+           ; Laufwerk eintragen
            move.w    2(a0),(a1)+           ; Sektornummer eintragen

            move.b    1(a0),d0              ; Sektor lesen
            andi.w    #$00ff,d0             ; Laufwerk
            move.w    d0,-(sp)
            move.w    2(a0),-(sp)           ; Sektornummer
            move.w    #1,-(sp)              ; 1 Sektor
            move.l    #S_ANT_BUF+9,-(sp)    ; Adr. Sektorbuffer
            clr.w     -(sp)                 ; Flag: lesen

            movea.l   HDV_RW,a0
            jsr       (a0)
            lea.l     12(sp),sp

            move.b    d0,S_ANT_BUF+8        ; Status setzen

SEND_EMPF:  
            move.w    #L_SEC_EMPF,d0
SEND_ANT:   lea.l     S_ANT_BUF(pc),a0      ; BestÑtigung senden
            bsr       CHECK_RAUS
;            bra       END_ANT

END_ANT:    
            move.l    RETTE_CRIT,ETV_CRITIC
            movem.l   (sp)+,d0-d7/a0-a6
            movea.l   RETTE_SP(pc),sp
            clr.b     BUSY_FLAG
            rts       

;==========================================================
;
;            Laufwerksroutinen fÅr Drive N
;
;==========================================================

; ========= neue Media-Change-Routine ==========

NEW_MEDIA:  movea.l   OLD_MEDIA(pc),a0
            cmpi.w    #DRIVE_N,4(sp)        ; Laufwerk N ?
            beq.s     DO_MEDIA              ; ja
            jmp       (a0)                  ; zur Orginal Routine
DO_MEDIA:   
            clr.l     d0                    ; erstmal keinen Wechsel annehmen
            tst.b     CHANGE
            beq       NO_CHANGE             ; stimmt auch, also Sprung
            moveq.l   #2,d0                 ; Wechsel, also 2 liefern
NO_CHANGE:  rts                             ; und fertig

;========== neue Bios-Parameter-Block Routine ===========

NEW_BPB:    movea.l   OLD_BPB(pc),a0
            cmpi.w    #DRIVE_N,4(sp)        ; Laufwerk N ?
            beq       GET_BPB
            jmp       (a0)                  ;nein, dann alte Routine

GET_BPB:    sf        CHANGE                ; Media-Change Drive N aufheben
            lea.l     S_ANF_BUF+2(pc),a0    ; a0 Zeiger auf Sendebuffer
            move.b    #BPB_ANF,(a0)+        ; Kennung 3 mal eintragen
            move.b    #BPB_ANF,(a0)+
            move.b    #BPB_ANF,(a0)+
            move.b    LAUFWERK(pc),(a0)+    ; Laufwerk eintragen

            lea.l     S_ANF_BUF(pc),a0      ; Telegrammanfang nach a0
            move.w    #L_BPB_ANF,d0         ; TelegrammlÑnge nach d0
            move.w    #BPB_SEND,d1          ; Antwortkennung nach d1

            bsr       SEND_IT               ; Telegramm senden
            beq       NO_BPB                ; a1 zeigt auf Empfangsbuffer

            move.b    LAUFWERK(pc),d0
            cmp.b     1(a1),d0              ; Laufwerk testen
            bne       GET_BPB               ; falsch, also erneut anfordern
            tst.b     2(a1)                 ; gibt es das Laufwerk?
            bne.s     NO_BPB                ; nein

            addq.l    #3,a1                 ; a1 zeigt nun BPB
            lea.l     BPB(pc),a2            ; und BPB Åbertragen
            move.w    #19,d0                ; ZÑhler fÅr DBRA
BPB_LOOP:   move.b    (a1)+,(a2)+
            dbra      d0,BPB_LOOP

            move.l    #BPB,d0               ; BPB-Adresse zurÅckliefern
            rts       
NO_BPB:     
            moveq.l   #0,d0                 ; Bei Fehler 0 liefern
            rts       


;========== neue R/W Routine ==========

NEW_RW:     movea.l   OLD_RW(pc),a0
            cmpi.w    #DRIVE_N,14(sp)       ; Laufwerk N ?
            beq       DO_RW
            jmp       (a0)                  ; nein, dann alte Routine

DO_RW:      
            move.l    #-14,d0
            tst.b     CHANGE
            beq       RETRY
            rts       

RETRY:      move.w    4(sp),d0              ; R/W Flag
            move.l    6(sp),BUFFER          ; Bufferadr. merken
            move.w    10(sp),SEC_ANZ        ; Sektoranzahl
            move.w    12(sp),START_SEC      ; Startsektor retten

            btst      #0,d0                 ; Lesen oder Schreiben ?
            beq       READ_SEC              ; Sprung, wenn lesen

; ----------  Sektor schreiben -----------
WRITE_SEC:  
            lea.l     S_ANF_BUF+2(pc),a0    ; a0 zeigt auf Sendebuffer
            move.b    #SEC_WR,(a0)+         ; Kennung 3 * eintragen
            move.b    #SEC_WR,(a0)+
            move.b    #SEC_WR,(a0)+
            move.b    LAUFWERK(pc),(a0)+    ; Laufwerk eintragen
            move.w    START_SEC(pc),(a0)+   ; Sektornummer eintragen

            movea.l   BUFFER(pc),a1         ; Sektor eintragen
            move.w    #511,d0
SEC_LOOP1:  move.b    (a1)+,(a0)+
            dbra      d0,SEC_LOOP1

            lea.l     S_ANF_BUF(pc),a0      ; Sektor senden
            move.w    #L_SEC_WR,d0          ; LÑnge
            move.w    #SEC_BEST,d1          ; erwartete Antwortkennung
            bsr       SEND_IT
            beq       RW_ERROR              ; keine Antwort

; a1 zeigt nun auf Empfangsbuffer

            move.b    LAUFWERK(pc),d0       ; stimmt Laufwerk
            cmp.b     1(a1),d0
            bne       WRITE_SEC             ; nein, dann nochmal schreiben

            move.w    START_SEC(pc),d0      ; stimmt Sektor
            cmp.w     2(a1),d0
            bne       WRITE_SEC             ; nein, dann nochmal schreiben

            move.b    4(a1),d0              ; Status OK ?
            bne       RW_ERROR              ; nein, also Fehler anzeigen

            addi.l    #512,BUFFER
            addq.w    #1,START_SEC
            subq.w    #1,SEC_ANZ            ; Anzahl Sektoren decrementiern
            bne       WRITE_SEC             ; wenn <> 0 nÑchsten Sektor
            bra       RW_OK                 ; sonst fertig

; ---------- Sektor lesen ----------

READ_SEC:   
            lea.l     S_ANF_BUF+2(pc),a0    ; a0 zeigt auf Sendebuffer
            move.b    #SEC_ANF,(a0)+        ; Kennung 3 * eintragen
            move.b    #SEC_ANF,(a0)+
            move.b    #SEC_ANF,(a0)+
            move.b    LAUFWERK(pc),(a0)+    ; Laufwerk eintragen
            move.w    START_SEC(pc),(a0)+   ; Sektornummer eintragen

            lea.l     S_ANF_BUF,a0          ; Anforderung senden
            move.w    #L_SEC_ANF,d0         ; LÑnge
            move.w    #SEC_EMPF,d1          ; Antwortkennung
            bsr       SEND_IT
            beq       RW_ERROR

; a1 zeigt nun auf Empfangsbuffer

            move.b    LAUFWERK(pc),d0       ; stimmt Laufwerk
            cmp.b     1(a1),d0
            bne       READ_SEC              ; nein, dann nochmal lesen

            move.w    START_SEC(pc),d0      ; stimmt Sektor
            cmp.w     2(a1),d0
            bne       READ_SEC              ; nein, dann nochmal lesen

            move.b    4(a1),d0              ; Status OK ?
            bne       RW_ERROR              ; nein, also Fehler anzeigen

            addq.l    #5,a1                 ; a1 zeigt nun auf gelesenen Sek.
            movea.l   BUFFER(pc),a0         ; Sektor Åbertragen
            move.w    #511,d0               ; ZÑhler fÅr DBRA
SEK_LOOP2:  move.b    (a1)+,(a0)+
            dbra      d0,SEK_LOOP2

            addi.l    #512,BUFFER
            addq.w    #1,START_SEC
            subq.w    #1,SEC_ANZ            ; Anzahl Sektoren decrementiern
            bne       READ_SEC              ; wenn <> 0 nÑchsten Sektor
;            bra       RW_OK                 ; sonst fertig


RW_OK:      
            clr.l     d0                    ; Alles OK
            rts       
RW_ERROR:   
            moveq.l   #-1,d0
            rts       


;----------------------------------------------------------------
;                         mess_raus
;
;          Meldung im Supervisor-Modus abschicken
;
;----------------------------------------------------------------

MESS_RAUS:  
            lea.l     S_MES_BUF(pc),a0
            move.w    #L_MESSAGE,d0

;----------------------------------------------------------------
;                         check_raus
;
;  Checksumme Åber Telegramm bilden und rausschicken
;
;  Eingabe:  a0 zeigt auf Sendebuffer (Wort davor ist ZÑhler)
;            d0 enthÑlt TelegrammlÑnge
;            Low Word d1 und a0,d0 dÅrfen nicht zerstîrt werden
;----------------------------------------------------------------

CHECK_RAUS: 
            move.w    d3,-(sp)

            clr.w     (a0)                  ; 2 Sync-Bytes 0 eintragen
            swap.w    d1                    ; d1 Low retten
            clr.w     d1                    ; Checksumme lîschen
            clr.w     d3
            moveq.l   #2,d2                 ; ZÑhler setzen
CHECK_LOOP: 
            move.b    3(a0,d2.w),d3         ; Sync und Kennung Åberspringen
            add.w     d3,d1
            addq.w    #1,d2
            cmp.w     d0,d2                 ; fertig ?
            bne       CHECK_LOOP

            move.w    d1,3(a0,d2.w)         ; Checksumme eintragen
            clr.l     5(a0,d2.w)            ; FÅllbytes

            move.l    a0,-6(a0)             ; Zeiger auf Buffer setzen

            addq.w    #8,d2                 ; nun LÑnge mit Sync und Kennbytes
            move.w    d2,-2(a0)             ; setzen um Telegramm zu senden

            swap.w    d1
            move.b    #$b5,MIDI_CNTR        ; Transmitterinterrupt freigeben
            move.w    (sp)+,d3
            rts       

;----------------------------------------------------------------
;                           send_it
;
;  Telegramm absenden und auf Antwort warten. Wenn Antwort falsch
;  telegramm erneut senden.
;
;  Eingabe:  a0 zeigt auf Sendebuffer (Wort davor ist ZÑhler)
;            d0 enthÑlt TelegrammlÑnge
;            d1 enthÑlt erwartete Kennung
;  Ausgabe:  a1 zeigt auf Empfangsbuffer
;            Zero Flag = 1 wenn Fehler
;----------------------------------------------------------------

SEND_SWAP:  swap.w    d1
SEND_IT:    
            clr.w     E_ANT_ZAHL            ; Empfangsflag lîschen
            bsr       CHECK_RAUS            ; Telegramm abschicken

            move.l    HZ_200,d2             ; Timer setzen
            addi.l    #TIME_OUT,d2
WAIT_ANT:   
            cmp.l     HZ_200,d2             ; Zeit abgelaufen?
            bls       VORBEI
            movem.l   d0-d2/a0,-(sp)

            bsr       TESTE_ANRUF
            movem.l   (sp)+,d0-d2/a0
            tst.w     E_ANT_ZAHL            ; Antwort da
            beq       WAIT_ANT              ; nîh!

            lea.l     E_ANT_BUF(pc),a1      ; Zeiger auf Empfangsbuffer

            cmp.b     (a1),d1               ; stimmt Kennung ?
            bne       SEND_IT               ; nein, erneut anfordern

            swap.w    d1                    ; d1 Low retten
            move.w    d3,-(sp)
            clr.w     d1                    ; Checksumme lîschen
            clr.w     d3
            moveq.l   #2,d2                 ; ZÑhler setzen
CHECK_LOOP1:          
            move.b    -1(a1,d2.w),d3        ; Kennung Åberspringen
            add.w     d3,d1
            addq.w    #1,d2
            cmp.w     E_ANT_ZAHL(pc),d2     ; fertig ?
            bne       CHECK_LOOP1

            move.w    (sp)+,d3
            cmp.w     -1(a1,d2.w),d1        ; Checksumme testen
            bne       SEND_SWAP             ; stimmt nicht, also nochmal anford.

            swap.w    d1
            move.w    #0,ccr                ; non Zero
            rts       
VORBEI:     
            move.w    #4,ccr                ; Zero
            rts       

;=================================================================
;
;                   MIDI-Interrupt Routine
;                   ======================
;
;  Diese Routine empfÑngt und sendet Zeichen der MIDI-Schnittstelle
;  im Interrupt
;
;=================================================================

MIDI_INT:   
            btst      #7,MIDI_CNTR          ; Hat MIDI Interrupt angefordert?
            beq       INT_END               ; nein, also fertig

            btst      #0,MIDI_CNTR          ; Zeichen da ?
            beq       INT_SEND              ; nein, also senden

;----------------------------------------------------------------------
;
;                        Zeichen empfangen
;
;  Der Empfang von Zeichen richtet sich nach der Variablen EMPF_STAT.
;  EMPF_STAT kann folgende Werte annehmen
;
;  0:   nix los!  Es wird auf das erste Zeichen gewartet
;  1:   was los!  Es wird auf das zweite Zeichen gewartet
;  2:  viel los!  was wohl?
;
;        Die 3 Kennerbytes wurden nun Empfangen, und sollten alle gleich
;        sein. Ist dies nicht der Fall, wird mit 2/3 Mehrheit weitergemacht.
;        Sind alle Zeichen verschieden, oder Kennung unbekannt wieder 0.
;        Sonst, je nachdem ob Sendeanforderung oder BestÑtigung Bufferzeiger
;        setzen.
;
;  3:   Zeichen in richtigen Buffer legen bis ZÑhler abgelaufen
;       Nach letzem Zeichen FLAG setzen und Status 0
;
;----------------------------------------------------------------------

EMPFANG:    
            btst      #0,MIDI_CNTR          ; Zeichen da ?
            beq       INT_END               ; nein, also fertig

            move.b    MIDI_DATA,d0          ; Zeichen nach d0.b
            move.b    EMPF_STAT(pc),d1      ; Status nach  d1.b


; ----------------   STATUS 3   -----------------

            cmpi.b    #3,d1                 ; Status 3
            bne.s     NOT_3

            movea.l   EMPF_ZEIG(pc),a0      ; Zeichen weglegen
            move.b    d0,(a0)+
            move.l    a0,EMPF_ZEIG

            subq.w    #1,EMPF_ZAHL          ; ZÑhler decrementieren

            bne.s     EMPFANG               ; nicht 0, also nochmal versuchen

            movea.l   EMPF_FLAG(pc),a0      ; fertig, also Flag (gleichzeitig
            move.w    ZAHL_MERK,(a0)        ; Zaehler) setzen
            bra.s     INT_SEND0             ; und mit Senden weiter

; ----------------    STATUS 0    ---------------

NOT_3:      tst.b     d1                    ; Status 0?
            bne.s     NOT_0

            move.b    d0,d2                 ; Sync Byte, dann Status 0
            beq       INT_END0

            rol.b     #4,d2                 ; Test ob mîgliche Kennung
            not.b     d2
            cmp.b     d2,d0
            beq.s     B1OK
            moveq.l   #1,d0                 ; wenn nicht 1 merken
B1OK:       
            move.b    d0,ZEICHEN1           ; 1. Kennung merken
            moveq.l   #1,d1
            move.b    d1,EMPF_STAT          ; und Status 1

            btst      #0,MIDI_CNTR          ; noch ein Zeichen da ?
            beq       INT_END               ; nein, also fertig
            move.b    MIDI_DATA,d0          ; Zeichen nach d0.b

; ------------------  STATUS 1 ------------------

NOT_0:      
            cmpi.b    #1,d1                 ; Status 1?
            bne.s     NOT_1

            move.b    d0,d2                 ; Sync Byte, dann Status 0
            beq       INT_END0

            rol.b     #4,d2                 ; Test ob mîgliche Kennung
            not.b     d2
            cmp.b     d2,d0
            beq.s     B2OK
            moveq.l   #2,d0                 ; wenn nicht 2 merken
B2OK:       
            move.b    d0,ZEICHEN2           ; 2. Kennung merken
            moveq.l   #2,d1
            move.b    d1,EMPF_STAT          ; und Status 2

            btst      #0,MIDI_CNTR          ; noch ein Zeichen da ?
            beq       INT_END               ; nein, also fertig
            move.b    MIDI_DATA,d0          ; Zeichen nach d0.b

; ----------------   STATUS 2   ----------------

NOT_1:      
;            cmpi.b    #2,d1                 ; Status 2?
;            bne.s     INT_END0              ; darf es eigentlich nicht geben

            tst.b     d0                    ; Sync Byte, dann Status 0
            beq       INT_END0

            cmp.b     ZEICHEN1(pc),d0       ; 1. und 3. Kennung gleich?
            beq.s     GEWONNEN              ; schon haben wir die Mehrheit

            cmp.b     ZEICHEN2(pc),d0       ; 2. und 3. Kenuung gleich?
            beq.s     GEWONNEN              ; auch gut

            move.b    ZEICHEN2(pc),d0
            cmp.b     ZEICHEN1(pc),d0       ; 1. und 2. Kennung gleich?
            bne.s     INT_END0              ; auch nicht, dann Status 0
GEWONNEN:   
            lea.l     TELE_TAB(pc),a0       ; Zeiger auf Kenn-Tabelle
            move.b    d0,d2
            andi.w    #$000e,d2             ; Maske Åber Kenner => Nummer
            move.w    0(a0,d2.w),d1         ; ja, ZÑhler laden
            move.w    d1,EMPF_ZAHL
            move.w    d1,ZAHL_MERK

            lea.l     E_MES_BUF(pc),a0      ; richtigen Buffer nach a0
            cmpi.b    #MESSAGE,d0
            beq.s     NIMMANF
            lea.l     E_ANF_BUF(pc),a0
            btst      #1,d0
            beq.s     NIMMANF
            lea.l     E_ANT_BUF(pc),a0

NIMMANF:    move.b    d0,(a0)+
            move.l    a0,EMPF_ZEIG
            move.l    a0,EMPF_FLAG
            subq.l    #3,EMPF_FLAG
            move.b    #3,EMPF_STAT          ; Status 3
            bra       EMPFANG


; -------------  Zeichen senden  ---------------

INT_SEND0:  clr.b     EMPF_STAT             ; Empfangsstatus 0 setzen

INT_SEND:   btst      #1,MIDI_CNTR          ; kann Zeichen gesendet werden?
            beq.s     INT_END               ; nein, also Empfang versuchen

            addq.b    #1,DELAY              ; Delay ZÑhler fÅr Send-Message
            andi.b    #%00000111,DELAY      ; Modulo 7 hochzÑhlen

            move.b    SEND_SWITCH,d1
RAUS_DAMIT: 
            lea.l     S_ANF_BUF(pc),a1      ; richtigen Buffer nach a1
            tst.b     d1
            beq       SEND_SOFORT

            lea.l     S_ANT_BUF(pc),a1
            cmpi.b    #1,d1
            beq       SEND_SOFORT

            lea.l     S_MES_BUF(pc),a1
            bra       SEND_BYTE
SEND_SOFORT:          
            clr.b     DELAY                 ; nicht Message also immer senden
SEND_BYTE:  
            tst.w     -2(a1)                ; Buffer leer?
            bne.s     SENDE_BUF             ; nein, dann senden

            addq.b    #1,d1                 ; auf nÑchsten Buffer umschalten
            cmpi.b    #3,d1
            blt       SWITCH_OK
            clr.b     d1
SWITCH_OK:  
            move.b    d1,SEND_SWITCH
            move.w    S_ANF_ZAHL,d0         ; alle Buffer leer
            or.w      S_ANT_ZAHL,d0
            or.w      S_MES_ZAHL,d0
            bne       RAUS_DAMIT            ; nein, dann senden

            move.b    #$95,MIDI_CNTR        ; ja, Sendeinterrupt abschalten
            bra       INT_END               ; und weiter mit Empfang
SENDE_BUF:  
            tst.b     DELAY                 ; nur wenn DELAY=0 Meldung senden
            bne       INT_END

            movea.l   -6(a1),a0             ; Zeichen senden
            move.b    (a0)+,MIDI_DATA
            move.l    a0,-6(a1)
            subq.w    #1,-2(a1)             ; ZÑhler decrementieren
            bra       INT_END

INT_END0:   clr.b     EMPF_STAT
INT_END:    
            rts       


;=============================================================
;
;                neuer Critical Error Handler
;
;=============================================================

CRIT_NEU:   
            rts       


;-------------------------------------------------------------
;
;                  kleine Hilfsprogramme
;
;-------------------------------------------------------------
;-----------------------------------------
; do_allert: Allert Box zeichnen
;    a0 zeigt auf text
;    d0 enthÑlt Abbruchnummer
;-----------------------------------------
DO_ALLERT:  
            move.l    a0,-(sp)

            move.w    #1,(a5)               ;Default Knopf ist 1
            move.l    a0,(a6)               ;String nach ADDRIN(0)
            move.w    #FORM_ALERT,d0
            move.l    #$01010100,d1
            bsr       AESCALL

            move.w    INTOUT(pc),d0

            movea.l   (sp)+,a0
            rts       
;------------------------------------------------------
;  txtcpy
;
;  Kopiert 30 Byte Text auf die a0 zeigt nach (a1)
;  Ab einer 0 wird mit Blanks aufgefÅllt
;  | wird durch ! ersetzt !!!
;------------------------------------------------------

TXTCPY:     
            moveq.l   #29,d1
LI1:        move.b    (a0)+,(a1)+           ; Text Åbertragen
            beq       IS_NULL
            cmpi.b    #'|',-1(a1)
            bne       Z_OK
            move.b    #'!',-1(a1)
Z_OK:       
            dbra      d1,LI1
            bra       CPY_OK                ; war keine 0 drin
IS_NULL:    
            subq.l    #1,a1
LI3:        move.b    #' ',(a1)+            ; mit Blanks auffÅllen
            dbra      d1,LI3

CPY_OK:     rts       

;------------------------------------------------------
;  gettxt
;
;  kopiert 30 Zeichen aus dem Text_Object d0.w in den
;  Speicherbereich auf den a0 zeigt
;------------------------------------------------------

GETTXT:     
            movea.l   a0,a1
            bsr       OBJC_ADR              ; Adresse Object nach a0
            movea.l   12(a0),a0             ; a0 zeigt nun auf TEDINFO
            movea.l   (a0),a0               ; a0 zeigt nun auf Text

            moveq.l   #29,d1
LI2:        move.b    (a0)+,(a1)+           ; Text Åbertragen
            dbra      d1,LI2

            movea.l   a1,a0
            rts       

;------------------------------------------------------
;  clrtxt
;
;  lîscht String im Textobjekt d0.w
;
;------------------------------------------------------

CLRTXT:     
            bsr       OBJC_ADR              ; Adresse Object nach a0
            movea.l   12(a0),a0             ; a0 zeigt nun auf TEDINFO
            movea.l   (a0),a0               ; a0 zeigt nun auf Text

            clr.b     (a0)
            rts       

;------------------------------------------------------------------
;  Objc_Adresse: Berechnet Adresse des Obj. mit Index d0.w nach a0
;------------------------------------------------------------------

OBJC_ADR:   
            move.l    d0,-(sp)
            movea.l   FORM_ADR(pc),a0
            mulu.w    #24,d0
            adda.l    d0,a0
            move.l    (sp)+,d0
            rts       



;==============================================================
;
;                   DATA und BSS Bereiche
;
;==============================================================


            .DATA 

RSC_NAM:    .DC.b 'LITT_NET.RSC',0          ; Accessoriename
            .EVEN 
ACC_NAME:   .DC.b '  * Little Net * ',0     ; Name im Eintrag
            .EVEN 

SEND_SWITCH:          
            .DC.b 0   ; Flag fÅr Sendebuffer (0 = Antwortbuffer)
EMPF_STAT:  .DC.b 0   ; Empfangsstatus
BUSY_FLAG:  .DC.b 0   ; in Bios Flag
            .EVEN 

TELE_TAB:   .DC.w L_BPB_ANF                 ; LÑngen der Telegramme
            .DC.w L_BPB_SEND
            .DC.w L_SEC_WR
            .DC.w L_SEC_BEST
            .DC.w L_SEC_ANF
            .DC.w L_SEC_EMPF
            .DC.w L_MESSAGE
            .DC.w L_NOT_ACK

DRIVE_TAB:  .DC.w DRIVEA,DRIVEB,DRIVEC,DRIVED,DRIVEE ; Nummern der Laufwerke
            .DC.w DRIVEF,DRIVEG,DRIVEH,DRIVEI,DRIVEJ

ACC_MSGS:   .DC.l 0   ; Keine Meldungen ausgeben
MEDIA_BUF:  .DS.b 16  ; Merker fÅr Media-Change alle Laufwerke

ACCCLOW:    .DC.w 500 ; Timer-Event alle 500ms
ACCCHIGH:   .DC.w 0

POST_BOX:   .DC.b '[1][   Wichtige Mitteilung:    | | |'
LINE1:      .DC.b '012345678901234567890123456789|'
LINE2:      .DC.b '012345678901234567890123456789][ gelesen ]',0,0
            .EVEN 

            .IF TESTEN
            .DC.l $11223344
            .DC.l S_ANF_BUF
            .DC.l S_ANT_BUF
            .DC.l S_MES_BUF
            .DC.l E_ANF_BUF
            .DC.l E_ANT_BUF
            .DC.l E_MES_BUF
            .ENDIF 

            .BSS 

STATUS:     .DS.b 1   ; Netzstatus
LAUFWERK:   .DS.b 1   ; Laufwerknummer (0 = A  u.s.w)

ZEICHEN1:   .DS.b 1   ; 1. Kennbyte
ZEICHEN2:   .DS.b 1   ; 2. Kennbyte

CHANGE:     .DS.b 1   ; Merker fÅr Media-Change Drive N
DELAY:      .DS.b 1   ; Delay-ZÑhler fÅr Send-Message
            .EVEN 

; ZÑhler und Flags mÅssen vor den Buffern stehen

S_ANF_ZEIG: .DS.l 1   ; Zeiger auf nÑchstes Zeichen zum Senden aus Anford.
S_ANF_ZAHL: .DS.w 1   ; wenn =n <> 0 wird Telegramm mit n Bytes gesendet
S_ANF_BUF:  .DS.b 530 ; Buffer fÅr sende Anforderung

S_ANT_ZEIG: .DS.l 1   ; Zeiger auf nÑchstes Zeichen zum Senden aus Antwortbuf.
S_ANT_ZAHL: .DS.w 1
S_ANT_BUF:  .DS.b 530 ; Buffer fÅr sende Antwort

S_MES_ZEIG: .DS.l 1   ; Buffer fÅr Message senden
S_MES_ZAHL: .DS.w 1
S_MES_BUF:  .DS.b 80


E_ANF_ZAHL: .DS.w 1   ; TelegrammlÑnge wenn Telegramm empfangen, sonst 0
E_ANF_BUF:  .DS.b 530 ; Buffer fÅr empfange Anforderung

E_ANT_ZAHL: .DS.w 1
E_ANT_BUF:  .DS.b 530 ; Buffer fÅr empfange Antwort

E_MES_ZAHL: .DS.w 1   ; Buffer fÅr Message empfangen
E_MES_BUF:  .DS.b 80


BPB:        .DS.b 20  ; Buffer fÅr Bios Parameter Block

ZAHL_MERK:  .DS.w 1   ; Merker fÅr Anzahl empfangener Zeichen
EMPF_ZEIG:  .DS.l 1   ; Zeiger fÅr Empfangsbuffer
EMPF_ZAHL:  .DS.w 1   ; dito ZÑhler
EMPF_FLAG:  .DS.l 1   ; dito Empfangsflag

BUFFER:     .DS.l 1   ; Zeiger auf Datenbuffer fÅr RW
SEC_ANZ:    .DS.w 1   ; Anzahl Sektoren fÅr RW
START_SEC:  .DS.w 1   ; NÑchster Sektor fÅr RW

FORM_ADR:   .DS.l 1   ; Adresse der Resource
OB_X:       .DS.l 1   ; X/Y-Koord. des Formulars
OB_BR:      .DS.l 1   ; Breite/Hîhe des Formulars

OLD_BPB:    .DS.l 1   ; Adresse alte BPB-Routine
OLD_MEDIA:  .DS.l 1   ; Adresse der alten Media-Change-Routine
OLD_RW:     .DS.l 1   ; Adresse der alten RW-Routine

OLD_BIOS:   .DS.l 1   ; Einsprungadresse altes Bios
RETTE_SP:   .DS.l 1   ; Hier wird der SP gerettet
RETTE_PTR:  .DS.l 1   ; Hier wird der Savptr gerettet
RETTE_CRIT: .DS.l 1   ; Critical Error Handler retten

            .DS.b 512 ; neuer Stack fÅr BIOS-Einbindung
STACK_NEU:  


            .END 





