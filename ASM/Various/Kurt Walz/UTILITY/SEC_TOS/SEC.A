* zum angucken ODER RUMPFUSCHEN!
*lies von floppy einzelnen sector und gib hex/ascii auf tv und drucker
 .text
 lea  #-600(a7),a7   platz fÅr puffer
 move.L #1, -(a7)  Anzahl=1 Seite=0
 clr.w      -(a7)  track=0
 move.L #1, -(a7)  sector=1 dev=0(=laufwerkA)
 clr.L      -(a7) {filler}
 pea    18(a7)     puffer direkt Åberm stack
 move.w #8, -(a7)  code fÅr floprd
 moveq  #0,   d5   flag: NICHT auf druckerport
begi:
 move.w #8,  (a7)
 moveq  #0,    d0
 bsr    txreladr
 move.w 10(a7),d1
 bsr    dezou
 move.w 16(a7),d1
 bsr    dezou
 move.w 14(a7),d1
 bsr    dezou
 move.w 12(a7),d1
 bsr    dezou 

readtast:
 move.w #1, -(a7)  readTastaturWithEcho
 trap   #1
 addq.L #2,  a7
 or.b   #32, d0   kleinbuchstabe erzwingen
 cmp.b  #'b',d0   wars bTaste?
 beq    abbr
 cmp.b  #'a',d0
 beq    start
 cmp.b  #'w',d0
 beq    write
 cmp.b  #'g',d0   gerÑtNr Ñndern?
 bne    tstp
 lea  10(a7),a1
 bra    aendre
tstp:
 cmp.b  #'p',d0  pfusch rum im sector?
 bne    tsts
 lea  24(a7),a4  abhier buffer
pLoo:
 moveq #13,  d0
 bsr   dou
 moveq #10,  d0
 bsr   dou
 moveq #0,   d1
 move.b (a4)+,d1
 bsr   dezou
 moveq #32,  d0
 bsr   dou
 bsr   dezin
 bpl   pLoo
 beq   readtast
 move.b d1, -1(a4)
 bra   pLoo

tsts:
 cmp.b  #'s',d0   seitenNr Ñndern?
 bne    tstt
 lea  16(a7),a1
 bra    aendre
tstt:
 cmp.b  #'t',d0   trackNr Ñndern?
 bne    tstr
 lea  14(a7),a1
 bra    aendre
tstr:
 cmp.b  #'r',d0   record(sector)Nr Ñndern?
 bne    tstd
 lea  12(a7),a1
 bra    aendre
tstd:
 cmp.b  #'d',d0
 bne    tstn
 bset   #31, d5
tstn:
 cmp.b  #'n',d0
 bne    begi
 bclr   #31, d5
 bra    begi
abbr: clr.w -(a7)
     trap  #1
aendre:
 bsr    dezin
 beq    begi
 move.w d1, (a1)
 bra    begi
start:
 trap  #14
 moveq #0,  d1
 sub   d0,  d1   evtl Fehlermeldung
 bsr   dezou
 moveq #0,d6    checksum
 lea  24(a7),a4  ab dort puffer
 move.w #15,d5
n1hx32:
 bsr  hx32
 dbra d5,n1hx32
 lea  24(a7),a4
 addq.w #8,d5
n1tx64:
 bsr  tx64
 dbra d5,n1tx64
 move d6,d3
 addq #4,d5
n1hd:
 bsr hdig
 dbra d5,n1hd
 bra  begi 

write:
 move  #9, (a7)
 trap  #14
 moveq #0,  d1
 sub   d0,  d1   evtl Fehlermeldung
 bsr   dezou
 bra   begi

* hx32 gibt 16words hex auf tv
hx32:
 moveq #13,  d0
 bsr   dou
 moveq #10,  d0
 bsr   dou
 moveq  #15,  d4  somit 16words (=32 bytes)
h32l:
 move.w (a4)+,d3
 add.w d3,d6
 bsr    hdig
 bsr    hdig
 bsr    hdig
 bsr    hdig
 subq   #1,  d4
 bmi    r32x
 move.w #32, d0
 bsr    dou
 bra    h32l
r32x:
 RTS
hdig:
 rol.w  #4, d3
 moveq  #15,d0
 and.b  d3, d0
 cmp.b  #9, d0
 bls    hdok
 addq   #7, d0
hdok:
 add.b  #48,d0
 bsr dou
 RTS
* dezin liest von tastatur dezimalZiffern gibt d1.w=zahl signOFd2.b=flag ob ziffern getippt
* gibt neFLAG wenn ok, pl wenn nur return, cs wenn nichtZiffer
dezin:
 moveq  #0,  d1
 moveq  #0,  d2
dezlo:
 move.w #1, -(a7)  readTastaturWithEcho
 trap   #1
 addq.L #2,  a7
 and.w  #255,d0
 cmp.b  #13, d0   carRet?
 beq    deziok
 sub.b  #48, d0   wars 0Taste oder grîûer(cc)?
 bcs    dezno
 cmp.b  #9,  d0   wars 9 oder kleiner(ls)?
 bhi    dezno
 mulu   #10, d1
 add.w  d0,  d1
 st          d2
 bra    dezlo
deziok:
 tst.b       d2
 RTS
dezno:
 move.w #-1, ccr
 RTS
*
* dezou gibt gemÑû d1 drei dezZiffern und Blank aufs tv
dezou:
 moveq  #47, d0
dl: add #1,  d0  '0'
 sub.w #100, d1
 bcc   dl
 add.w #100, d1
 bsr   dou
 moveq  #47, d0
dm: add #1,  d0
 sub.w  #10, d1
 bcc    dm
 bsr    dou
 moveq  #58, d0
 add.w  d1,  d0
 bsr    dou
 moveq  #32, d0
 bsr    dou
 RTS
dou:
 and.w  #255,d0
 move.w d0,-(a7)
 move.w #2,-(a7) an tv
 trap   #1
 tst.L  d5
 bpl    dnd
 move.w #5, (a7) an drucker
 trap   #1
dnd:
 addq   #4,  a7
 RTS

ddru:
 cmp.b  #32,  d0 steuerzeichen?
 bls    spezdru 
 cmp.b  #-1,  d0
 beq    spezdru
 cmp.b  #127, d0
 bne    dru
 moveq  #6,   d0 piek-character zum Zeichen: deleteCode wars

dru:
 tst.L d5
 bpl   drnf
 move.w d0,-(a7)
 move.w #5,-(a7)
 trap   #1
 addq   #4, a7
drnf: RTS

spezdru:
 move.w d0,-(a7)
 moveq  #27, d0
 bsr    dru
 moveq  #4,  d0  italic
 bsr    dru
 moveq  #$B0,d0
 add.w (a7)+,d0
 bsr    dru
 moveq  #27, d0
 bsr    dru
 moveq  #5,  d0  IBMformat
 bra    dru

* tx64 gibt crRETlineFEED und 64 (nichtsteuernde) zeichen auf tv ab a4
tx64:
 moveq  #13,  d0
 bsr    dou
 moveq  #10,  d0
 bsr    dou
 moveq  #63,  d4
t64l:
 moveq  #0,   d0
 move.b (a4)+,d0
 bsr    txnur
 dbra   d4,   t64l
 RTS
* txnur gibt nur druckend(nicht steuernd) auf tv gemÑû d0
txnur:
 move.w d0,-(a7)
 bsr    ddru
 move.w #5,-(a7)
 move.w #3,-(a7)
 trap   #13
 addq   #6, a7
 RTS
*
* txtout gibt auf BSchirm text, wenn Einstieg txreladr: txt hinter RTS +d0
* (subrout)   wenn Einstieg txabsadr: txt ab (a0)
*        ! a0,d0 futsch
txreladr: LEA   #14(PC,d0.L), a0
txabsadr: move.L  a0,        -(a7)
 move.w  #9,        -(a7)
 trap    #1
 addq.L  #6,        a7
 RTS
*data
dc.b 10,13,'AnfgBeend Drck/Nich PfushWrit GerÑSeitTracRec=',0
.even
LLAST: dc.w 0
.end
