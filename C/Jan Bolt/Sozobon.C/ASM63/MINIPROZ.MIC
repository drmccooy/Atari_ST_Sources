	.LIST	; LISTING ERZEUGEN
	.FILE	; LISTING IN FILE SCHREIBEN
;************************************************************
;	MINIPROZ-BETRIEBSSYSTEM FUER HITACHI 63701
;	(c) 1988 by Prof. Dr. Th. Schiller, FH-DBP-Berlin,
;	Ringbahnstraže 130, D-1000 Berlin 42
;************************************************************

; SYSTEM UND ASSEMBLER KONSTANTEN

CTRLC	= 3	; ABBRUCHZEICHEN
CTRLQ	= $11	; AUSGABE WEITERLAUFEN LASSEN
CTRLS	= $13	; AUSGABE ANHALTEN
CTRLT	= $14	; REGISTERANZEIGE IM USER-MODE
SPACE	= $20	; ZWISCHENRAUM
BS	= $8	; RUECKSCHRITT
CR	= $D	; WAGENRUECKLAUF
LF	= $A	; ZEILENTRANSPORT
DELETE	= $7F	; LOESCH-ZEICHEN
JMP	= $7E	; OPCODE FUER JMP-BEFEHL
EQUAL	= $80+'=
RAMSTA	= $2000

; MCU-REGISTER:

P1DDR	= 0	; PORT 1 DATA DIRECTION REGISTER
P2DDR	= 1	; PORT 2 DATA DIRECTION REGISTER
P1DR	= 2	; PORT 1 DATA REGISTER
P2DR	= 3	; PORT 2 DATA REGISTER & MODE REGISTER
P4DDR	= 5	; PORT 4 DATA DIRECTION REGISTER
P4DR	= 7	; PORT 4 DATA REGISTER
TCSR	= 8	; TIMER CONTROL/STATUSREGISTER
TIMERH	= 9	; TIMER (HIGH BYTE)
TIMERL	= $A	; TIMER (LOW BYTE)
OCRH	= $B	; OUTPUT COMPARE REGISTER (HIGH)
OCRL	= $C	; OUTPUT COMPARE REGISTER (LOW)
ICRH	= $D	; INPUT CAPTURE REGISTER (HIGH)
ICRL	= $E	; INPUT CAPTURE REGISTER (LOW)
RMCR	= $10	; RATE & MODE CONTROL REGISTER
TRCSR	= $11	; TRANSMIT/RECEIVE CONTROL/STATUSREGISTER
RDR	= $12	; RECEIVE DATA REGISTER
TDR	= $13	; TRANSMIT DATA REGISTER
RCR	= $14	; RAM CONTROL REGISTER


; USER CPU-REGISTER

	.ORG	$3FB3

F	.BLKB	1	; PROCESSOR STATUSREGISTER	(USER)
A	.BLKB	1	; AKKU A			(USER)
B	.BLKB	1	; AKKU B			(USER)
XH	.BLKB	1	; X-REGISTER HIGH		(USER)
XL	.BLKB	1	; X-REGISTER LOW		(USER)
PCH	.BLKB	1	; PROGRAM COUNTER HIGH		(USER)
PCL	.BLKB	1	; PROGRAM COUNTER LOW		(USER)
SPH	.BLKB	1	; STACKPOINTER HIGH		(USER)
SPL	.BLKB	1	; STACKPOINTER LOW		(USER)

; VARIABLEN DES MINIPROZ-MONITORS

XHI	.BLKB	1	; HILFSZELLE 1 FUER
XLO	.BLKB	1	; 16 BIT OPERATIONEN
YHI	.BLKB	1	; HILFSZELLE 2 FUER
YLO	.BLKB	1	; 16 BIT OPERATIONEN
ZHI	.BLKB	1	; GHILFSZELLE 3 FUER
ZLO	.BLKB	1	; 16 BIT OPERATIONEN
SCRATW	.BLKW	1	; 16 BIT ZWISCHENSPEICHER
RXDATA	.BLKB	1	; ASCII-ZEICHEN VON SCI
CKSUM	.BLKB	1	; PRUEFSUMME
BYTECT	.BLKB	1	; BYTE ZAEHLER
SYSFLG	.BLKB	1	; SYSTEMFLAGS

;	BIT #	BEDEUTUNG BEI BIT = 1
;	-------------------------------------------
;	 0	USER-MODE
;	 1	---
;	 2	16-BIT REGISTER ADRESSIERT
;	 3	CTRL/C ABBRUCH GESPERRT
;	 4	---
;	 5	---
;	 6	ORFE (VON SCI)
;	 7	RDRF (VON SCI)

; STACK DES MINIPROZ-MONITORS

	.BLKB	31	; RAUM FUER 16 UNTERPROGRAMMEBENEN
STACK	.BLKB	1

; EINSPRUNGPUNKTE FUER INTERRUPTS (PLATZ FUER BEFEHL: "JMP ADR")

JSCI	.BLKB	3	; SCI-IRQ2			(MONITOR)
JTOF	.BLKB	3	; TOF-IRQ2
JOCF	.BLKB	3	; OCF-IRQ2
JICF	.BLKB	3	; ICF-IRQ2
JIRQ1	.BLKB	3	; IRQ1
JSWI	.BLKB	3	; SWI				(MONITOR)
JNMI	.BLKB	3	; NMI
JTRAP	.BLKB	3	; TRAP-INTERRUPT


	.PAGE
;************************************************************
;	SYSTEM UNTERPROGRAMM SPRUNGTABELLE
;************************************************************

	.ORG	$F000

COLD	JMP	START	; KALTSTART EINSPRUNG
WARM	JMP	CONTRL	; WARMSTART EINSPRUNG
TERINP	JMP	READ	; LESE ASCII-ZEICHEN VOM TERMINAL NACH AKKU A
TEROUT	JMP	WRITE	; SENDE ASCII-ZEICHEN ZUM TERMINAL AUS AKKU A
TERIO	JMP	ECHO	; LESE UND SENDE ASCII ZEICHEN
PRINT	JMP	OUTSTR	; AUSGABE EINES ASCII STRINGS INDIZIERT DURCH X
PRCRLF	JMP	OUTCL	; AUSGABE VON <CR> UND <LF>
PRSPAC	JMP	OUTS	; AUSGABE EINES <SPACE>
INPHEX	JMP	INP2HA	; EINLESEN EINES HEX-ZEICENS IN AKKU A
OUTHEX	JMP	OUT2HA	; AUSGABE EINES HEX-ZEICHENS AUS AKKU A


	.PAGE
;************************************************************
;	KALTSTARTPUNKT NACH RESET
;************************************************************

START	SEI			; INTERRUPTS ZUNAECHST SPERREN
	LDS	#STACK		; MONITOR STACK EINRICHTEN

; VOREINSTELLUNG DER PORT-REGISTER
;
;	PORT 1	IST FREI VERFUEGBAR (8 BIT I/O)
;	PORT 2	IST BELEGT DURCH SCI UND TIMER
;	PORT 3	IST BELEGT DURCH DATENBUS/ADRESSBUS (LOW)
;	PORT 4	IST BELEGT DURCH ADRESSBUS (HIGH)

;	P20	TIMER IN			CPU <--
;	P21	TIMER OUT			CPU -->
;	P22	SCI CLOCK OUT			CPU -->
;	P23	SCI RXD 			CPU <--
;	P24	SCI TXD 			CPU -->

	LDAA	#%00010110
	STAA	<P2DDR
	LDAA	#%11111111	; PORT 4 WIRD ADRESSBUS (A8 - A15)
	STAA	<P4DDR
	LDAA	#%00001001	; SCI MIT 9600 BD, 1 STOPBIT, NRZ, TAKT INTERN
	STAA	<RMCR
	LDAA	#%00011010	; SCI TX/RX FREIGEBEN MIT RX-IRQ, OHNE WAKE UP
	STAA	<TRCSR
	LDX	#PCL
	STX	SPH		; VOREINSTELLUNG EINES USER-STACKS
	DEX			; ZEIGE AUF USER-PCH
	LDD	#$2000		; STANDADRD-STARTADRESSE
	STD	,X		;    IN USER-PC SCHREIBEN
	CLR	F		; USER-F-REG LOESCHEN
	CLR	SYSFLG
	LDAA	#JMP		; VOREINSTELLUNG
	STAA	JSCI		;    DER
	STAA	JSWI		;    EINSPRUNG-
	STAA	JTRAP		;    PUNKTE
	LDX	#ABORT
	STX	JSCI+1		;    FUER
	LDX	#BREAK		;    SCI UND
	STX	JSWI+1		;    SWI INTERRUPTS,
	LDX	#OPCERR 	;    SOWIE BEI
	STX	JTRAP+1 	;    OPCODE-ERROR

; MEMORY UEBERPRUEFEN OHNE RAM-INHALT ZU ZERSTOEREN !

	LDX	#SELFT		; MELDUNG AUSGEBEN, DASS
	JSR	OUTSTR		; SELBSTTEST LAEUFT
	LDX	#RAMSTA-1	; ANFANGSADRESSE DES RAMTESTS
RAMLOP	INX
	LDAA	,X
	COMA			; KOMPLEMENT BILDEN
	COM	,X
	CMPA	,X		; FEHLER ?
	BNE	RAMERR
	COM	,X		; ORIGINALPATTERN HERSTELLEN
	COMA
	CMPA	,X		; FEHLER ?
	BNE	RAMERR
	BRA	RAMLOP		; NEIN, WEITER IM TEST

RAMERR	DEX			; LETZTE FUNKTIONSFAEHIGE RAM-ZELLE
	STX	XHI		; RETTE ENDADRESSE
	CLI			; INTERRUPTS FREIGEBEN
	LDX	#RAMMS1 	; "Ram area found from $"
	JSR	OUTSTR		; GEBE RAM-MESSAGE AUS
	LDX	XHI
	PSHX
	LDX	#RAMSTA
	JSR	OUTX		; ANFANG DES RAM-BEREICHS AUSGEBEN
	PULX
	STX	XHI	
	LDX	#TOMSG		; "to $"
	JSR	OUTSTR
	LDX	#XHI		; GEBE LETZTE RAM-ADRESSE AUS
	JSR	OUT4H		; WORT AUSGEBEN
	JSR	OUTCL		; <CR><LF>


	.PAGE
;****************************************************************
;	WARMSTART DES MONITORPROGRAMMS
;****************************************************************


; KOMMANDOSCHLEIFE

HELP	LDX	#HLPTXT 	; KOMMANDOUEBERSICHT AUSGEBEN
	JSR	OUTSTR
CONTRL	LDS	#STACK		; MONITORSTACK SETZEN
	CLI			; INTERRUPTS FREIGEBEN
	LDX	#PROMPT 	; MONITORPROMPT AUSGEBEN
	JSR	OUTSTR
	JSR	ECHO		; ASCII-ZEICHEN LESEN
	LDX	#COMTAB 	; START DER BEFEHLSTABELLE
	CLRB
SEACOM	CMPA	,X		; ZEICHEN GEFUNDEN ?
	BEQ	FOUND
	INX
	INCB
	CMPB	#COMVEK-COMTAB	; LAENGE DER BEFEHLSTABELLE
	BEQ	CONTRL		; EINGABE NICHT GEFUNDEN
	BRA	SEACOM

FOUND	ASLB			; WORTOFFSET ERZEUGEN
	LDX	#COMVEK 	; TABELLENSTART LADEN,
	ABX			;    OFFSET ADDIEREN
	LDX	,X		;    UND SPRUNGADRESSE LADEN
	JSR	,X		; KOMMANDO AUSFUEHREN
	BRA	CONTRL


	.PAGE
;****************************************************************
;	INTERRUPT PROGRAMME FUER TRAP UND SCI-IRQ
;****************************************************************


;----------------------------------------------------------------
; USER-PROGRAMM BEI OPCODE-FEHLER ABBRECHEN
;----------------------------------------------------------------

OPCERR	TSX			; X ZEIGT AUF USER-F
	XGDX
	ADDD	#6
	STD	SPH		; USER-SP VOR DEM EINSPRUNG !
	LDS	#STACK
	CLI			; INTERRUPT WIEDER FREIGEBEN
	LDX	#OPCODM 	; "Illegal opcode at PC=$"
	BRA	PCOUT



;----------------------------------------------------------------
; KOMMANDO MIT CTRL/C ABBRECHEN ODER BEI CTRL/T REGISTER AUSGEBEN
;----------------------------------------------------------------

ABORT	LDAA	<TRCSR		; DATEN VOM SCI ?
	BEQ	EXIT1		; NEIN, UNERKLAERLICHER INTERRUPT
	ANDA	#$C0		; RDRF UND ORFE BITS HERAUSLOESEN
	LDAB	SYSFLG
	ANDB	#$3F		; RDRF UND ORFE BIT LOESCHEN
	ABA			;    UND NEUE BITS EINBINDEN
	PSHA
	LDAB	<RDR		; NEUES ZEICHEN LESEN
	CMPB	#CTRLC		; ABBRUCHZEICHEN EMPFANGEN ?
	BEQ	EXIT2		; JA:
	ASRA			; NEIN: USER MODE EINGESCHALTET ?
	BCC	SAVECH		; NEIN: ZEICHEN ABSPEICHERN
	CMPB	#CTRLT		; JA:	ZEICHEN = CTRL/T ?
	BEQ	CTRLTI
SAVECH	PULA			; RDRF UND ORFE LADEN
	STAA	SYSFLG
	STAB	RXDATA		; 1 BYTE BUFFER
EXIT1	RTI

; CTRL/T GIBT IM LAUFENDEN USER-PROGRAMM ALLE CPU-REGISTER AUS

CTRLTI	INS			; JA:	STACK KORRIGIEREN
	TSX			;    UND USER STACKPOINTER RETTEN
	XGDX			; USER-SP ZEIGT NUN AUF DIE
	ADDD	#6		;    ADRESSE VOR DEM INTERRUPT !
	STD	SPH		; USER-SP SPEICHERN
	JSR	OUTCL		; IM LAUFENDEN USER-PROGRAMM
	JSR	USRREG		; ALLE CPU-REGISTER AUSGEBEN
	RTI

; AUSWERTUNG DES ABBRUCHZEICHENS CTRL/C

EXIT2	LDAA	SYSFLG
	BITA	#%00000001	; USER MODE GESETZT ?
	BNE	ABORT1		; JA:	USERPROGRAMM ABBRECHEN
	BITA	#%00001000	; CTRL/C-FLAG GESETZT ?
	BNE	SAVECH		; JA:	CTRL/C DANN ABSPEICHERN
	JMP	CONTRL		; NEIN: ABBRUCH EINES HAUPTKOMMANDOS

ABORT1	TSX			; USER STACKPOINTER RETTEN
	XGDX			; USER-SP ZEIGT NUN AUF DIE
	ADDD	#7		;    ADRESSE VOR DEM INTERRUPT !
	STD	SPH		; USER-SP SPEICHERN
	LDS	#STACK		; MONITOR STACK SETZEN
	CLI			; INTERRUPT WIEDER FREIGEBEN
	LDX	#CTRLCM 	; ABBRUCHMELDUNG AUSGEBEN
PCOUT	JSR	OUTSTR		
	LDX	SPH		; X ZEIGT NUN AUF USER-PCL
	DEX			;    UND JETZT AUF USER-PCH
	JSR	OUT4H		; USER-PC AUSGEBEN
	JMP	BREAK1


	.PAGE
;****************************************************************
;	SYSTEMUNTERPROGRAMME
;****************************************************************


;----------------------------------------------------------------
; UNTERBROCHENES USER-PROGRAMM WEITERLAUFEN LASSEN
;----------------------------------------------------------------

CONTIN	LDX	#TXTCON 	; "ontinue user-program at PC=$"
	JSR	OUTSTR
	LDX	SPH
	DEX			; USER PCH ADRESSIEREN
	LDX	,X		;   LADEN
	STX	XHI		;   ZWISCHENSPEICHERN FUER LABEL G1
	JSR	OUTX		;   UND AUSGEBEN
	JMP	G1


;----------------------------------------------------------------
; ANZEIGE EINES SPEICHERBEREICHS
;----------------------------------------------------------------

DUMP	LDX	#TXTDUM 	; "ump memory from $"
	JSR	OUTSTR
	JSR	INP4HX
	BCC	D1
DERR	LDX	#CHRERR 	; "??? Invalid character"
	JMP	OUTSTR

D1	STX	YHI		; STARTADRESSE MERKEN
	LDX	#TOMSG		; " to $"
	JSR	OUTSTR
	JSR	INP4HX
	BCS	DERR
	STX	ZHI		; ENDADRESSE RETTEN
	LDX	YHI		; STARTADRESSE LADEN
DUMP1	JSR	OUTCL		; NEUE ZEILE ANFANGEN
	XGDX
	ANDB	#$F0		; ANFANG AUF VIELFACHEN VON 16
	XGDX
	PSHX			; DIE NORMALISIERTE ADRESSE RETTEN
	JSR	OUTX		; NORMALISIERTE ADRESSE AUSGEBEN
	JSR	OUTDS		; DOPPELTER ZWISCHENRAUM
	PULX			; NORMALISIERTE ADRESSE ZURUECKLADEN
DUMP11	CPX	YHI		; NORMALISIERTE = RICHTIGE STARTADRESSE ?
	BEQ	DUMP12
	INX			; NORMALISIERTE ADRESSE ERHOEHEN
	JSR	OUTDM		; ZWEI STRICHE AUSGEBEN
	JSR	TRENNZ		; TRENNZEICHEN (1 ODER 2 SPACE) AUSGEBEN
	BRA	DUMP11

DUMP12	LDX	YHI		; DAS IST DIE RICHTIGE STARTADRESSE
DUMP2	JSR	OUT2H		; ADRESSIERTES BYTE
	JSR	TRENNZ		;    UND TRENNZEICHEN AUSGEBEN
	DEX			; KORREKTUR FUER ENDVERGLEICH
	CPX	ZHI		; ENDADRESSE ERREICHT ?
	BEQ	DUMP21		; JA
	INX			; NAECHSTE ADRESSE
	XGDX
	BITB	#$F		; EINE HEX-ZEILE FERTIG ?
	XGDX
	BNE	DUMP2		; NEIN, WEITER...
	BRA	DUMP23

DUMP21	INX			; ADRESSE+1
	XGDX			; UNTERSTES DIGIT DER STARTADRESSE
	BITB	#$F		;    IM B-REGISTER ABTRENNEN
	XGDX
	BEQ	DUMP23		; NULL: DANN KEINE AUFFUELLUNG NOETIG
	JSR	OUTDM		; ZWEI STRICHE AUSGEBEN
	JSR	TRENNZ		; TRENNZEICHEN (1 ODER 2 SPACE) AUSGEBEN
	BRA	DUMP21

DUMP23	JSR	OUTS		; ABSTANDSHALTER FUER ASCII-AUSGABE
	LDD	YHI
	ANDB	#$F0
	XGDX	
DUMP3	CPX	YHI		; NORMALISIERTE = RICHTIGE STARTADRESSE ?
	BEQ	DUMP32
	JSR	OUTS		; NEIN, DANN SPACE AUSGEBEN
	INX
	BRA	DUMP3

DUMP32	LDAA	,X		; EIN BYTE HOLEN
	INCA			; BYTE FUER ASCII-TEST ERHOEHEN
	ANDA	#$7F		;    UND STEUERZEICHEN MASKIEREN
	CMPA	#$20		; > ALS SPACE ?
	BHI	ASCOUT		; JA
	LDAA	#'.+1		; FUELL-ZEICHEN
ASCOUT	DECA			; ORIGINALZEICHEN WIEDER ERZEUGEN
	JSR	WRITE		;    UND AUSGEBEN
	CPX	ZHI		;    ENDADRESSE ERREICHT ?
	BEQ	DMPEND		; JA, DANN IST ALLES GETAN
	INX
	XGDX
	BITB	#$F		; EINE ZEILE FERTIG ?
	XGDX
	BNE	DUMP32		; NEIN...
	STX	YHI
	JMP	DUMP1

DMPEND	RTS



;----------------------------------------------------------------
; STARTEN VON USER-PROGRAMMEN
;----------------------------------------------------------------

GOTO	LDX	#TXTGOT 	; "oto user program at $"
	JSR	OUTSTR
	JSR	INP4HX		; STARTADRESSE HOLEN
	BCC	G1
	LDX	#CHRERR 	; "??? Invalid character"
	JMP	OUTSTR

G1	LDX	SPH
	DEX			; X ZEIGT AUF USER-PCH
	LDD	XHI		; STARTADRESSE NOCHEINMAL LADEN
	STD	,X		;    UND IN USER-PC SCHREIBEN
	XGDX
	SUBD	#$5		; AUF USER-F ZEIGEN
	XGDX
	SEI			; INTERRUPT SPERREN, DAMIT
	LDAA	SYSFLG		;    SYSFLG NICHT ZERSTOERT WIRD !
	ORAA	#1		; USER-MODE
	STAA	SYSFLG		;    EINSCHALTEN
	TXS			; USER-SP AUF F-1 SETZEN
	RTI			; SPRUNG ZUM ANWENDERPROGRAMM
;----------------------------------------------------------------
; HIER ZWISCHEN LAEUFT DAS USER-PROGRAMM
;----------------------------------------------------------------
BREAK	TSX			; X ZEIGT AUF USER-F
	XGDX
	ADDD	#6
	STD	SPH		; USER-SP VOR DEM EINSPRUNG !
	LDS	#STACK
	CLI			; INTERRUPT WIEDER FREIGEBEN
	JSR	OUTCL
	LDX	#BRKMSG 	; "Breakpoint entcountered at PC=$"
	JSR	OUTSTR
	LDX	SPH
	DEX			; ADRESSIERE USER-PCH
	LDX	,X
	DEX			; ADRESSE DES BREAKPOINTS (SWI)
	JSR	OUTX		;    AUSGEBEN
BREAK1	SEI			; INTERRUPT SPERREN, DAMIT
	LDAA	SYSFLG		;    SYSFLG NICHT VERAENDERT WIRD !
	ANDA	#$FE		; USER-MODE LOESCHEN
	STAA	SYSFLG
	CLI			; INTERRUPT WIEDER FREIGEBEN
	JMP	CONTRL



;----------------------------------------------------------------
; LADEN VON MOTOROLA RECORDS
;----------------------------------------------------------------

LOAD	LDX	#TXTLOA 	;"oad MOTOROLA records"
	JSR	OUTSTR
LOAD2	JSR	OUTCL
LOAD3	JSR	ECHO		; WARTE AUF EIN ZEICHEN
	CMPA	#'S		; ES MUSS DAS MOTOROLA 'S' SEIN !
	BNE	LOAD3		;    ALLES ANDERE IGNORIEREN
	JSR	ECHO		; OK, WIR HABEN ES BEKOMMEN
	CMPA	#'9		; EINE '9' KENNZEICHNET ENDE
	BEQ	LOAD17
	CMPA	#'1		; EINE '1' KENNZEICHNET DATEN
	BNE	LOAD3		; ALLES ANDERE IGNORIEREN WIR (AUCH '0')
	CLR	CKSUM		; AM ANFANG DES RECORDS: CHECKSUMME LOESCHEN
	JSR	INP2HA		; LESE EIN BYTE
	BCC	LOAD10
LOADER	LDX	#CHRERR 	; "??? Invalid character"
	BRA	LOAD16

LOAD10	SUBA	#2
	STAA	BYTECT		; BYTE ZAEHLER
	JSR	INP4HX		; STARTADRESSE ERZEUGEN (-> ADD CKSUM)
	BCS	LOADER		; FEHLER!
LOAD11	JSR	INP2HA		; LESE DATENBYTE (-> ADD CKSUM)
	BCS	LOADER		; FEHLER!
	DEC	BYTECT		; DATENBYTE ZAEHLEN, EIN RECORD FERTIG ?
	BEQ	LOAD15		; JA:	DANN CHECKSUMME TESTEN
	STAA	,X		; NEIN: SPEICHERE DATENBYTE
	CMPA	,X		; MEMORY OK ?
	BEQ	LOAD12		; JA, DANN WEITER...
	PSHX			; LETZTE ADRESSE RETTEN
	LDX	#ERRMSG 	; "??? Memory did not change"
	JSR	OUTSTR
	LDX	#AT		; " at "
	JSR	OUTSTR
	PULX
	JMP	OUTX		; FEHLERADRESSE AUSGEBEN

LOAD12	INX			; NAECHSTE ADRESSE
	BRA	LOAD11

LOAD15	INC	CKSUM		; CHECKSUMME OK ?
	BEQ	LOAD2		; JA, DANN WEITER...
	LDX	#CKSERR 	; "??? Checksum error"
LOAD16	JSR	OUTSTR
LOAD17	RTS



;----------------------------------------------------------------
; MEMORY ANSEHEN UND/ODER VERAENDERN 
;----------------------------------------------------------------

MEMORY	LDX	#TXTMEM 	; "emory display at $"
	JSR	OUTSTR
	JSR	SETBYT		; BYTE-OPERATION VOREINSTELLEN
	JSR	INP4HX		; MEMORY-ADRESSE HOLEN
	BCC	SAMEA		; GUELTIGE HEX-EINGABE
	CMPB	#'R		; REGISTER AUSGABE ?
	BEQ	SUBC
	CMPB	#'T		; TEXT EINGABE ?
	BEQ	SUBC
	RTS

SAMEA	STX	ZHI		; EINGEGEBENE ADRESSE RETTEN
	LDX	#SAMEAD 	; ADRESSE OEFFNEN
	BRA	SCALL

;-----------------------------
;	SUBCOMMAND INTERPRETER
;-----------------------------

SUBCMD	JSR	INP2HA		; HOLE BYTE ODER LETZTEN BUCHSTABEN
	BCS	SUBC		; NEUES KOMMANDO EINGEGEBEN
	LDAB	SYSFLG
	BITB	#%00000100	; BYTE-OPERATION ?
	BEQ	STOB		; JA...
	JSR	INPS4X		; NEIN: REST VOM WORT HOLEN
	BCS	SUBC		; NEUES KOMMANDO EINGEGEBEN
	LDD	ZHI		; AKTUELLE ADRESSE LADEN
	XGDX
	STD	,X		; WORT SPEICHERN
	CMPA	,X		; HIGHER BYTE IM SPEICHER OK ?
	BNE	MEMERR		; NEIN...
	INX
	CMPB	,X		; LOWER BYTE IM SPEICHER OK ?
	BNE	MEMERR		; NEIN...
	BRA	STO

STOB	LDX	ZHI		; AKTUELLE ADRESSE LADEN
	STAA	,X		; BYTE SPEICHERN
	CMPA	,X		; SPEICHER OK ?
	BEQ	STO
MEMERR	LDX	#CHGERR 	; "??? Memory did not change"
	JSR	OUTSTR
	BRA	SAME

STO	INX			; NAECHSTE ADRESSE EINSTELLEN
	STX	ZHI		;    UND ADRESSE RETTEN
	JSR	SETBYT		; BYTE-MODE SETZEN
SAME	LDX	#SAMEAD 	; ADRESSE MIT INHALT OEFFNEN
	BRA	SCALL

SUBC	LDX	#MEMTAB 	; START DER BEFEHLSTABELLE
	TBA			; EINGABE RETTEN
	CLRB
SEASC	CMPA	,X		; ZEICHEN GEFUNDEN ?
	BEQ	MFOUND
	INX
	INCB
	CMPB	#MEMVEK-MEMTAB	; LAENGE DER BEFEHLSTABELLE
	BNE	SEASC
MCERR	LDX	#CHRERR 	; "??? Invalid character"
	JSR	OUTSTR
	LDX	#SAMEAD 	; GLEICHE ADRESSE NOCHEINMAL OEFFNEN
	BRA	SCALL

MFOUND	ASLB			; WORTOFFSET ERZEUGEN
	LDX	#MEMVEK 	; TABELLENSTART LADEN,
	ABX			;    OFFSET ADDIEREN
	LDX	,X		;    UND SPRUNGADRESSE LADEN
SCALL	JSR	,X		; UNTERKOMMANDO AUSFUEHREN
	BCC	SUBCMD
	BRA	SUBC

MEMEND	INS			; RUECKSPRUNGADRESSE IN DEN SUBCOMMAND-
	INS			;    INTERPRETER ENTFERNEN UND RUECK-
	RTS			;    SPRUNG IN DIE HAUTKOMMANDOEBENE


;----------------------------------------------------------------
; AUSGABE DER USER-REGISTER
;----------------------------------------------------------------

CPUREG	LDX	#TXTREG 	; "egister dump: "
	JSR	OUTSTR
USRREG	LDX	#FREG		; "F="
	JSR	OUTSTR
	LDD	SPH		; LADE USER-SP
	SUBD	#6		; ZEIGE AUF USER-F
	XGDX
	LDAB	,X		; LADE USER-F-REGISTER
	INX
	PSHX			; X ZEIGT SCHON AUF USER-B REGISTER
	LDX	#FLAGS		; FLAG TABLE
	ASLB			; 2 BITS IM F-REGISTER
	ASLB			;    ABTRENNEN
REGLOP	LDAA	,X		; LADE FLAG-BUCHSTABEN, FERTIG ?
	BEQ	ENDFLG		; JA
	INX
	ASLB			; F-BIT GESETZT ?
	BCS	FLGOUT		; JA
	LDAA	#'.		; NEIN: LADE CLR-ZEICHEN
FLGOUT	JSR	WRITE		;    UND GEBE ES AUS
	BRA	REGLOP

ENDFLG	JSR	OUTS
	LDX	#BREG		; ASCII-TABELLE MIT REGISTERNAMEN
	STX	YHI
	PULX			; ADRESSE VOM USER-B REGISTER
CONREG	JSR	REGOUT
	ABX			; NEUE ADRESSE SETZEN
	PSHX
	LDX	YHI
	DEX
	TST	,X		; LETZE AUSGABE SP ?
	BNE	NOTSP		; NEIN...
	PULX
	LDX	SPH		; ZEIGE AUF
	DEX			;    USER-PCH
	PSHX
	LDX	YHI
	DEX
NOTSP	INX
	TST	,X		; ENDE DER REGISTERAUSGABE ?
	PULX
	BPL	CONREG		; NEIN...
DONREG	RTS


	.PAGE
;****************************************************************
;	ALLGEMEINE UNTERPROGRAMME
;****************************************************************


;----------------------------------------------------------------
; TERMINALEINGABE
;----------------------------------------------------------------

READ	LDAA	SYSFLG		; ZEICHEN EMPFANGEN ?
	BPL	READ		; NEIN...
	SEI			; JA:	SPERRE INTERRUPT
	ANDA	#$3F		; RDRF UND ORFE LOESCHEN
	STAA	SYSFLG
	LDAA	RXDATA		; ASCII-ZEICHEN LADEN
	CLI			; INTERRUPTS WIEDER FREIGEBEN	
	ANDA	#$7F		; PARITY-BIT ABTRENNEN
	RTS



;----------------------------------------------------------------
; TERMINALAUSGABE (MIT XON/XOFF HANDSHAKE)
;----------------------------------------------------------------

WRITE	PSHA			; ZEICHEN RETTEN
WR1	LDAA	TRCSR
	ANDA	#%00100000	; TX SENDEBEREIT ?
	BEQ	WR1		; NEIN...
	TST	SYSFLG		; ZEICHEN EMPFANGEN ?
	BPL	WR2		; NEIN...
	BSR	READ
	CMPA	#CTRLS		; AUSGABE ANHALTEN ?
	BNE	WR2		; NEIN...
WR3	TST	SYSFLG		; JA:	AUF CTRL/Q WARTEN
	BPL	WR3
	BSR	READ
	CMPA	#CTRLQ		; AUSGABE WEITERLAUFEN LASSEN ?
	BNE	WR3		; NEIN...
WR2	PULA
	PSHA
	ANDA	#$7F		; NUR 7 BIT ASCII SENDEN !
	STAA	TDR		; ASCII-ZEICHEN SENDEN
	PULA			; ORIGINALZEICHEN LADEN
	RTS



;----------------------------------------------------------------
; TERMINAL EIN-UND AUSGABE
;----------------------------------------------------------------

ECHO	BSR	READ		; ZEICHEN LESEN
	CMPA	#'a		; KLEINBUCHSTABEN EINGEGEBEN ?
	BCS	WRITE		; NEIN: ZEICHEN AUSGEBEN
	CMPA	#'z		; SONDERZEICHEN ?
	BHI	WRITE		; JA:	ZEICHEN AUSGEBEN
	ANDA	#%01011111	; NEIN: UMWANDLUNG IN GROSSBUCHSTABEN
	BRA	WRITE		; ZEICHEN AUSGEBEN



;----------------------------------------------------------------
; AUSGABE VON ZWISCHENRAEUMEN (SPACE)
;----------------------------------------------------------------

OUTDS	BSR	OUTS
OUTS	LDAA	#$20
	BRA	WRITE



;----------------------------------------------------------------
; AUSGABE VON VON BINDESTRICHEN (-)
;----------------------------------------------------------------

OUTDM	BSR	OUTM
OUTM	LDAA	#'-
	BRA	WRITE



;----------------------------------------------------------------
; NEUE ZEILE ANFANGEN (CR, LF)
;----------------------------------------------------------------

OUTCL	LDAA	#$D		; WAGENRUECKLAUF
	BSR	WRITE
	LDAA	#$A		; ZEILENTRANSPORT
	BRA	WRITE



;----------------------------------------------------------------
; EIN ODER ZWEI TRENNZEICHEN AUSGEBEN
;----------------------------------------------------------------

TRENNZ	PSHB
	PSHA
	PSHX
	XGDX
	ANDB	#$F		; UNTERES HALBBYTE ABTRENNEN
	CMPB	#$8		; MITTE IN DER ZEILE SCHON ERREICHT ?
	BNE	TRENNO		; NEIN: 1 SPACE AUSGEBEN
	BSR	OUTS		; JA:	2 SPACE AUSGEBEN
TRENNO	BSR	OUTS
	PULX
	PULA
	PULB
	RTS



;----------------------------------------------------------------
; AUSGABE EINES STRINGS, INDIZIERT DURCH X-REGISTER
;----------------------------------------------------------------

OUTSTR	LDAA	,X		; INDIZIERTES BYTE LADEN
	BEQ	OUTEND
	CMPA	#$80
	BEQ	OUTCL		; NEGATIVES ENDEZEICHEN = CRLF
	BSR	WRITE		; ZEICHEN AUSGEBEN
	INX			; ADRESSE ERHOEHEN
	TSTA
	BPL	OUTSTR
OUTEND	RTS



;----------------------------------------------------------------
; GEBE BYTE AUS
;----------------------------------------------------------------

OUTX	STX	XHI		; GEBE X-REGISTER AUS
OUTXHI	LDX	#XHI		; GEBE INHALT VON XHI AUS
OUT4H	BSR	OUT2H		; GEBE ADRESSIERTES WORT AUS
OUT2H	LDAA	,X		; GEBE ADRESSIERTES BYTE AUS
	INX
OUT2HA	PSHA			; GEBE BYTE IM AKKU AUS
	BSR	BUILDL		; OUT LEFT HEX CHARACTER
	BSR	WRITE
	PULA
	BSR	BUILDR		; OUT RIGHT HEX CHARACTER
	BRA	WRITE



;----------------------------------------------------------------
; AUSGABE DES BYTES IM A-REG
;----------------------------------------------------------------

BUILDL	LSRA			; LINKES NIBBLE
	LSRA			;    EINES 
	LSRA			;    BYTES
	LSRA			;    ERZEUGEN
BUILDR	ANDA	#$F		; RECHTES NIBBLE HERAUSTRENNEN
	ADDA	#'0		; ASCII-ZEICHEN ERZEUGEN
	CMPA	#'9		; ZEICHEN GROESSER ALS ASCII 9 ?
	BLS	BUILD		; NEIN, KEINE KORREKTUR NOETIG
	ADDA	#7		; PSEUDOTETRADEN ERZEUGEN (A-F)
BUILD	RTS



;----------------------------------------------------------------
; LESE EINE HEX-ZIFFER, KENNZEICHNE FEHLZEICHEN
;----------------------------------------------------------------

INPHX	JSR	ECHO
	TAB			; RETTE ZEICHEN FUER VERGLEICH
	CMPA	#'0
	BLT	INERR		; KEIN HEX
	CMPA	#'9
	BLE	IN1HG
	CMPA	#'A
	BLT	INERR		; KEIN HEX
	CMPA	#'F
	BGT	INERR		; KEIN HEX
	SUBA	#7
IN1HG	CLC			; CY=0 --> KEIN ERROR
	RTS

INERR	SEC			; CY=1 --> ERROR
	RTS



;----------------------------------------------------------------
; EINLESEN EINES BYTES IN DEN AKKU
;----------------------------------------------------------------

INP2HA	BSR	INPHX		; EIN HALBBYTE LESEN
	BCS	NBYTE2		; EINGABEFEHLER...
	ASLA
	ASLA
	ASLA
	ASLA
	PSHA			; 1. TEIL RETTEN
	BSR	INPHX		; EIN HALBBYTE LESEN
	BCS	NBYTE1		; EINGABEFEHLER...
	ANDA	#$F
	PULB
	ABA			; HEXBYTE ERZEUGEN
	PSHA			; BYTE RETTEN
	ADDA	CKSUM		; BYTE ZUR PRUEFSUMME ADDIEREN
	STAA	CKSUM		;    UND ABSPEICHERN
	CLC			; FEHLERFLAG LOESCHEN
NBYTE1	PULA			; BYTE WIEDER LADEN
NBYTE2	RTS



;----------------------------------------------------------------
; EINLESEN EINES WORTES INS X-REGISTER
;----------------------------------------------------------------

INP4HX	BSR	INP2HA		; ERSTES BYTE EINLESEN
	BCS	NADDR		; EINGABEFEHLER...
INPS4X	STAA	XHI
	BSR	INP2HA
	BCS	NADDR		; EINGABEFEHLER...
	STAA	XLO
	LDX	XHI		; 16 BIT WERT IM X-REGISTER
	CLC
NADDR	RTS



;----------------------------------------------------------------
; SETZE BYTE-OPERATION (OEFFNEN/SPEICHERN)
;----------------------------------------------------------------

SETBYT	SEI
	LDAA	SYSFLG
	ANDA	#%11111011	; BYTE-OPERATION EINSTELLEN
	STAA	SYSFLG
	CLI
	RTS



;----------------------------------------------------------------
; SETZE WORT-OPERATION (OEFFNEN/SPEICHERN)
;----------------------------------------------------------------

SETWOR	SEI
	LDAA	SYSFLG
	ORAA	#%00000100	; WORT-OPERATION EINSTELLEN
	STAA	SYSFLG
	CLI
	RTS



;----------------------------------------------------------------
; TEXTEINGABE AB AKTUELLER ADRESSE
;----------------------------------------------------------------

TXTINP	LDX	#TXTMSG 	; "ext-input. (Exit with CTRL/C)"
	JSR	OUTSTR
	SEI
	LDAA	SYSFLG
	ORAA	#%00001000	; CTRL/C-SPERRE SETZEN
	STAA	SYSFLG
	CLI
TXTIN	JSR	READ		; ASCII-ZEICHEN HOLEN
	CMPA	#CTRLC		; ABBRUCH ?
	BNE	TXTCHK		; NEIN...
	JMP	SAMEAD		; JA:	LETZTE ADRESSE OEFFNEN

TXTCHK	CMPA	#DELETE 	; LETZTES ZEICHEN LOESCHEN ?
	BNE	TXTOUT
	LDX	ZHI
	DEX			; AKTUELLE ADRESSE VERMINDERN
	STX	ZHI
	LDX	#DELTXT 	; <BS><SPACE><BS> AUSGEBEN
	JSR	OUTSTR
	BRA	TXTIN

TXTOUT	JSR	WRITE		;    UND ECHO AUSGEBEN
	LDX	ZHI		; AKTUELLE ADRESSE LADEN
	STAA	,X		;    UND ZEICHEN SPEICHERN
	CMPA	,X		; MEMORY OK ?
	BEQ	TXTOK		; JA...
	INS			; RUECKSPRUNGSADRESSE VOM
	INS			;    STACK ENTFERNEN
	SEI
	LDAA	SYSFLG
	ANDA	#%11110111	; CTRL/C-FLAG AUF NORMAL STELLEN
	STAA	SYSFLG
	CLI
	JMP	MEMERR		; FEHLER MELDEN

TXTOK	INX
	STX	ZHI
	BRA	TXTIN



;----------------------------------------------------------------
; NEUE ADRESSE OEFFNEN
;----------------------------------------------------------------

NEWADR	LDX	#TXTMEM 	; "emory display at $"
	JSR	OUTSTR
	JSR	INP4HX		; MEMORY-ADRESSE HOLEN
	BCS	NEWC		; NEUES KOMMANDO EINGEGEBEN...
	STX	ZHI		; NEUE ADRESSE SPEICHERN
	BRA	SAMEAD

NEWC	RTS



;----------------------------------------------------------------
; ADRESSE INDIREKT OEFFNEN
;----------------------------------------------------------------

INDIAD	LDX	ZHI		; AKTUELLE ADRESSE LADEN
	STX	SCRATW		;    UND RETTEN
	LDX	,X		;    UND DANN INDIREKT OEFFNEN
	STX	ZHI
	BRA	SAMEAD



;----------------------------------------------------------------
; LETZTE GEOEFFNETE ADRESSE OEFFNEN
;----------------------------------------------------------------

OFFSET	LDX	SCRATW		; LETZTE ADRESSE LADEN
	STX	ZHI
	BRA	SAMEAD



;----------------------------------------------------------------
; ADRESSE MIT 8-BIT RELATIV OEFFNEN
;----------------------------------------------------------------

RELBYT	LDX	ZHI
	STX	SCRATW		; LETZTE ADRESSE MERKEN
	CLRA			; POSITIVEN OFFSET VOREINSTELLEN
	LDAB	,X		; ADRESSIERTES BYTE LADEN
	BPL	CMPOFS
	DECA			; HIGHER BYTE AUF $FF SETZEN
CMPOFS	STX	ZHI
	ADDD	ZHI		; JETZT HABEN WIR DIE NEUE ADRESSE
	STD	ZHI

;----------------------------------------------------------------
; NAECHSTE, LETZTE ODER GLEICHE ADRESSE OEFFNEN
;----------------------------------------------------------------

NEXTAD	LDX	ZHI		; AKTUELLE ADRESSE LADEN
	INX
	INX
	STX	ZHI
	LDAA	SYSFLG		; WORT ADRESSIERT ?
	BITA	#%00000100
	BNE	SAMEAD		; JA:	ADR = ADR + 2
LASTAD	LDX	ZHI		; AKTUELLE ADRESSE LADEN
	DEX
	STX	ZHI
SAMEAD	JSR	OUTCL		; NEUE ZEILE ANFANGEN
	JSR	SETBYT		; MARKIERE NAECHSTE OPERATION ALS BYTE
	LDX	ZHI
	CPX	#SPH		; MOMENTANE ADRESSE = USER-SP ?
	BNE	TRYCPU		; NEIN...
	STX	XHI
	LDX	#SPREG		; LADE STRING-ADRESSE DES SP
	STX	YHI
	BRA	OPENRG

TRYCPU	LDD	SPH		; USER STACKPOINTER LADEN
	SUBD	#6		; AUF USER-F
	STD	XHI		;    UND ADRESSE RETTEN
	LDD	ZHI		; [MOMENTANE ADRESSE]
	SUBD	XHI		;    - [USER-REG-ADRESSE]
	BCS	OPENAD		; MOMENTANE ADRESSE IST KLEINER
	TSTA
	BNE	OPENAD		; MOMENTANE ADRESSE IST GROESSER
	CMPB	#6
	BHI	OPENAD		; MOMENTANE ADRESSE IST GROESSER
	LDX	#FREG		; ADRESSE DER REGISTERLISTE
	TBA			; OFFSET IN AKKU A RETTEN
	CLRB
NAMEF	STX	YHI
	LDX	XHI
	ABX			; AUF NAECHSTE USER-REG-ADRESSE ZEIGEN
	STX	XHI
	LDX	YHI		; STRINGPOSITION LADEN
OPENR	INX
	TST	,X		; POSITIV ?
	BPL	OPENR		; JA:	ENDE SUCHEN...
	INX			; X ZEIGT AUF REGISTERGROESSE
	LDAB	,X		; REGISTERGROESSE IN BYTE LADEN
	INX			; X ZEIGT AUF 1. REGISTERBUCHSTABEN
	SBA		
	BPL	NAMEF		; SUCHE, BIS OFFSET<0 WIRD
OPENRG	LDX	XHI		; EFFEKTIVE USER-REG-ADRESSE
	STX	ZHI		;    ALS AKTUELLE ADRESSE UEBERNEHMEN
	JSR	REGOUT		; REGISTER NAME & INHALT AUSGEBEN
	DECB			; 16-BIT REGISTER ?
	BEQ	R8BIT		; NEIN...
	JSR	SETWOR
R8BIT	CLC			; KEIN BEFEHLSBUCHSTABE EINGEGEBEN !
	RTS

; STANDARD-AUSGABE DER ADRESSE MIT BYTE-INHALT

OPENAD	LDX	ZHI		; AKTUELLE ADRESSE LADEN
	JSR	OUTX		;    UND AUSGEBEN
	LDAA	#'=		; OPEN
	JSR	TEROUT		;    INDIKATOR AUSGEBEN
	LDX	ZHI		; ADRESSE NOCHEINMAL LADEN
	JSR	OUT2H		; ADRESSIERTES BYTE
	JSR	OUTS		;    UND SPACE AUSGEBEN
	CLC			; KEIN BEFEHLSBUCHSTABE EINGEGEBEN !
	RTS



;----------------------------------------------------------------
; OEFFNEN EINES USER-REGISTERS
;----------------------------------------------------------------

CNGREG	LDX	#REGNAM 	; "egister name? "
	JSR	OUTSTR
	JSR	ECHO		; REGISTER-BUCHSTABE HOLEN
	CMPA	#'S		; STACKPOINTER ?
	BNE	CNG1		; NEIN...
	LDX	#SPREG		; JA:	LADE STRING-ADRESSE DES SP
	STX	YHI
	LDX	#SPH		; AKTUELLE ADRESSE AUF USER-SP SETZEN
	STX	XHI
	BRA	FOUNDR

CNG1	PSHA			; EINGEGEBENEN BUCHSTABEN RETTEN
	LDD	SPH		; USER STACKPOINTER LADEN
	SUBD	#6		; AUF USER-F
	STD	XHI		;    UND ADRESSE RETTEN
	LDX	#FREG		; STRINGADRESSE
	STX	YHI
	PULA			; EINGEGEBENEN BUCHSTABEN LADEN
	CLRB
SEARRG	LDX	YHI		; STRINGPOINTER LADEN
	CMPA	,X		; REGISTERNAMEN GEFUNDEN ?
	BEQ	FOUNDR
INCRP	INX
	TST	,X		; ENDE DES NAMENS GEFUNDEN ?
	BPL	INCRP
	INX			; AUF REGISTERGROESSE ZEIGEN
	LDAB	,X		;    UND LADEN
	INX
	TST	,X		; ENDE DER REGISTERLISTE ?
	BMI	NOREGF		; JA, EINGABE WAR UNGUELTIG !
	STX	YHI		; STRINGPOINTER RETTEN
	LDX	XHI
	ABX			; AUF NAECHSTE USER-REG-ADRESSE ZEIGEN
	STX	XHI
	BRA	SEARRG

NOREGF	LDX	#CHRERR 	; "? Invalid character"
	JSR	OUTSTR
	JMP	SAMEAD		; ADRESSE/REGISTER NOCHEINMAL AUSGEBEN

FOUNDR	JSR	OUTCL		; NEUE ZEILE ANFANGEN
	LDX	XHI		; ADRESSE DES USER-REGISTERS
	STX	ZHI		;    ALS AKTUELLE ADRESSE RETTEN
	BSR	REGOUT
	DECB			; 16 BIT-REGISTER ?
	BEQ	CNG8BR		; NEIN...
	JSR	SETWOR
CNG8BR	CLC			; KEIN BEFEHLSBUCHSTABE EINGEGEBEN !
	RTS



;----------------------------------------------------------------
; AUSGABE EINES USER-REGISTERS P/B/A/X/PC/SP
;----------------------------------------------------------------

REGOUT	PSHX			; ADRESSE DES USER-REGISTERS RETTEN
	LDX	YHI		; STRINGADRESSE LADEN
	JSR	OUTSTR		;    UND REGISTERNAME AUSGEBEN
	LDAB	,X		; REGISTERGROESSE IN BYTE LADEN
	INX			;    UND STRINGADRESSE ERHOEHEN
	STX	YHI		; STRINGADRESSE RETTEN
	PULX			; ADRESSE DES USER-REGISTERS LADEN
	TSTB			; AUSGABE DES SP ?
	BNE	STKREG		; NEIN...
	LDX	#SPH		; JA:	LADE USER SP
	LDAB	#2		;    UND SETZE DEN OFFSET AUF 2
STKREG	PSHB			; BYTE-ZAEHLER RETTEN
	PSHX			; REGISTERADRESSE RETTEN	
REGBYT	JSR	OUT2H		; BYTE AUSGEBEN
	DECB			; FERTIG ?
	BNE	REGBYT		; NEIN
	JSR	OUTS		; SPACE AUSGEBEN
	PULX			; RESITERADRESSE ZURUECKLADEN
	PULB			; BYTECOUNT LADEN
	RTS


	.PAGE
;****************************************************************
;	SYSTEMMELDUNGEN UND KONSTANTEN
;****************************************************************


SELFT	.BYTE	CR,LF,LF
	.ASCIZ	"System selftest running..."

RAMMS1	.BYTE	CR,LF
	.ASCIZ	"RAM-area found from $"

TOMSG	.ASCIZ	" to $"

HLPTXT	.BYTE	CR,LF,LF
	.ASCII	"Miniproz monitor V 1.1 command summary.  "
	.ASCII	"Memory subcommands:"
	.BYTE	CR,LF,LF
	.ASCII	"    C	 Continue user-program		"
	.ASCII	"    M	 Open new location"
	.BYTE	CR,LF
	.ASCII	"    D	 Display memory area		"
	.ASCII	"    R%  Open cpu-register %"
	.BYTE	CR,LF
	.ASCII	"    G	 Go to user program		"
	.ASCII	"    T	 Text input"
	.BYTE	CR,LF
	.ASCII	"    H	 Help (displays this text)	"
	.ASCII	"    =	 Open same address"
	.BYTE	CR,LF
	.ASCII	"    L	 Load MOTOROLA records		"
	.ASCII	"    +	 Open address + 1"
	.BYTE	CR,LF
	.ASCII	"    M	 Memory display/change		"
	.ASCII	"    -	 Open address - 1"
	.BYTE	CR,LF
	.ASCII	"    R	 Register display		"
	.ASCII	"    '	 Open relativ (save old addr.)"
	.BYTE	CR,LF
	.ASCII	"CTRL/C  Abort command/user-program	"
	.ASCII	"    @	 Open indirect (save old addr.)"
	.BYTE	CR,LF
	.ASCII	"CTRL/T  Show current user-cpu-regs.	"
	.ASCII	"    <	 Open old address"
	.BYTE	CR,LF,0

PROMPT	.BYTE	CR,LF
	.ASCIZ	"Miniproz> "

TXTCON	.ASCIZ	"ontinue user-program at PC=$"

TXTDUM	.ASCIZ	"ump memory from $"

TXTGOT	.ASCIZ	"oto user program at $"

TXTLOA	.ASCIZ	"oad MOTOROLA records"

TXTMEM	.ASCIZ	"emory display at $"

TXTREG	.ASCIZ	"egister dump: "

TXTMSG	.ASCII	"ext input. (Exit with CTRL/C)"
	.BYTE	$80

REGNAM	.ASCIZ	"egister name? "

DELTXT	.BYTE	BS,SPACE,BS,0

ERRMSG	.BYTE	CR,LF
CHGERR	.BYTE	7
	.ASCIZ	"? Memory did not change"

AT	.ASCIZ	" at $"

OFSERR	.BYTE	$7
	.ASCIZ	/? Offset error/

CKSERR	.BYTE	CR,LF,7
	.ASCIZ	/? Checksum error/

CHRERR	.BYTE	7
	.ASCIZ	/? Invalid character/

BRKMSG	.BYTE	CR,LF
	.ASCIZ	/Breakpoint encountered at PC=$/

CTRLCM	.BYTE	CR,LF
	.ASCIZ	"User program aborted by CTRL/C at PC=$"

OPCODM	.BYTE	CR,LF,7
	.ASCIZ	"Illegal opcode at PC=$"

; KOMMANDOTABELLE MIT VEKTOREN

COMTAB	.BYTE	'C
	.BYTE	'D
	.BYTE	'G
	.BYTE	'H
	.BYTE	'L
	.BYTE	'M	
	.BYTE	'R

COMVEK	.WORD	CONTIN
	.WORD	DUMP
	.WORD	GOTO
	.WORD	HELP
	.WORD	LOAD
	.WORD	MEMORY
	.WORD	CPUREG

; SUBCOMMANDS FUER MEMORY COMMAND

MEMTAB	.BYTE	CR	; MEMORY-COMMAND BEENDEN
	.BYTE	'M	; NEUE ADRESSE OEFFNEN
	.BYTE	'R	; REGISTER OEFFNEN
	.BYTE	'T	; TEXT EINGABE
	.BYTE	'+	; ADR+1 OEFFNEN
	.BYTE	'-	; ADR-1 OEFNNEN
	.BYTE	'=	; GLEICHE ADRESSE OEFFNEN
	.BYTE	''	; RELATIVES OEFFNEN
	.BYTE	'@	; ADRESSE INDIREKT OEFFNEN
	.BYTE	'<	; ZURUECK ZU LETZTER ADRESSE NACH @ ODER '

MEMVEK	.WORD	MEMEND
	.WORD	NEWADR
	.WORD	CNGREG
	.WORD	TXTINP
	.WORD	NEXTAD
	.WORD	LASTAD
	.WORD	SAMEAD
	.WORD	RELBYT
	.WORD	INDIAD
	.WORD	OFFSET

; TABELLE FUER REGISTER ANZEIGE

FLAGS	.ASCIZ	/HINZVC/

FREG	.BYTE	'F,	EQUAL,1
BREG	.BYTE	'B,	EQUAL,1
AREG	.BYTE	'A,	EQUAL,1
XREG	.BYTE	'X,	EQUAL,2
SPREG	.BYTE	'S,'P,	EQUAL,0
PCREG	.BYTE	'P,'C,	EQUAL,2,$FF	; $FF IST DAS LISTENENDE


	.PAGE
;*************************************************************************
;	VEKTOREN
;*************************************************************************

	.ORG	$FFEE

	.WORD	JTRAP		; TRAP
	.WORD	JSCI		; SCI-IRQ2 (RDRF, ORFE, TDRE)
	.WORD	JTOF		; TOF-IRQ2
	.WORD	JOCF		; OCF-IRQ2
	.WORD	JICF		; ICF-IRQ2
	.WORD	JIRQ1		; IRQ1
	.WORD	JSWI		; SWI
	.WORD	JNMI		; NMI
	.WORD	COLD		; RESET

	.END
