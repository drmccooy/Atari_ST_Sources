





                                         The

          MM        MM  IIIIIIIIII   CCCCCCCC   RRRRRRRR    OOOOOOOO
          MMMM    MMMM      II      CC      CC  RR     RR  OO      OO
          MM MM  MM MM      II      CC          RR     RR  OO      OO
          MM  MMMM  MM      II      CC          RR   RR    OO      OO
          MM   MM   MM      II      CC          RR RR      OO      OO
          MM        MM      II      CC          RR   RR    OO      OO
          MM        MM      II      CC      CC  RR    RR   OO      OO
          MM        MM  IIIIIIIIII   CCCCCCCC   RR     RR   OOOOOOOO


                       RRRRRRRR   TTTTTTTTTT  XX       XX
                       RR     RR      TT       XX     XX
                       RR     RR      TT        XX   XX
                       RR   RR        TT         XX XX
                       RR RR          TT          XXX          (TM)
                       RR   RR        TT         XX XX
                       RR    RR       TT        XX   XX
                       RR     RR      TT       XX     XX
                       RR     RR      TT      XX       XX

                                  operating system.

                      A Real Time MultiTasking Operating System
                        for the Atari ST Series of Computers








































                            Micro RTX Programmer's Manual

          Copyright 1986, 1987, 1988, 1989  Beckemeyer  Development  Tools.
          All rights reserved.

          This manual  describes  in  detail  the  MICRO  RTX  Multitasking
          Operating  System  for  the Atari ST Computer Series.  We've made
          every effort  in  writing  this  manual  to  ensure  that  it  is
          accurate.   However,  we can't guarantee that errors didn't creep
          in when we weren't looking.   Therefore,  Beckemeyer  Development
          Tools  will  not be liable for any damages resulting from the use
          of MICRO RTX or the information contained herein.

          MICRO RTX, MICRO  C-Shell,  MICRO  C-Tools  and  MT  C-Shell  are
          Trademarks of Beckemeyer Development Tools

          Atari, TOS, and Atari ST are Trademarks of Atari, Corp.

          GEM, GEMDOS, and DRI are Trademarks of Digital Research, Inc.

          UNIX is a trademark of Bell Labs.

          OS-9 is a trademark of Microware System Corp., and Motorola Inc.

                  Beckemeyer Development Tools
                  P.O. Box 21575
                  Oakland, CA  94620
                  (415)-530-9637

                  Revision C
                  Publication date: January 1989
                  Author: Alex Leavens
                  Contributing Editor: David Beckemeyer


                  +---------------------------------+
                  |         CALL OUR BBS!           |
                  |                                 |
                  | Beckemeyer Development Tools    |
                  | operates the BDT BBS, a public  |
                  | access, non-restricted BBS for  |
                  | users of our products.  It runs |
                  | 24 hours a day (except when     |
                  | crashed!).  You can reach it by |
                  | calling:                        |
                  |                                 |
                  |        (415)530-9682            |
                  |                                 |
                  +---------------------------------+

















                                      Chapter 1

          1.
                                    Introduction

          1.1 About this Manual

               This manual contains the basic information necessary on  how
          to  use  the  MICRO  RTX  real-time multitasking operating system
          kernel.

               We assume  that  you're  familiar  with  the  C  programming
          language, the 68000 processor, and the Atari ST's BIOS and GEMDOS
          system functions.

               CAUTION!  A lack of understanding  of  basic  single-tasking
          functions  of  the  ST,  when  trying  to  write  *multi*-tasking
          functions, will probably cause you to write code  which,  at  the
          very least, doesn't do what you intended!  So be CAREFUL!

          1.2 Note For Those Experienced with Other Multi-tasking OS's

               If you have experience with another multi-tasking  operating
          system,  such  as  UNIX  or  OS  9,  please take a moment to read
          through this manual anyway.  Although many facets  of  MICRO  RTX
          are  quite  similar  to other multi-tasking os's, and many of the
          system calls have similar names and/or functions,  THEY  ARE  NOT
          IDENTICAL  AND DO NOT DO EXACTLY THE SAME THINGS!  If you attempt
          to use the calls solely on the basis of knowledge of a like-named
          call on another system, you are likely to run into problems.

               Thus, to assume that because you're familiar with another OS
          means  that you're familiar with MICRO RTX and can begin using it
          right away may lead you into making egregious errors that will be
          difficult if not impossible to spot.  So please, read carefully!

          1.3 System Overview

               MICRO RTX is a multi-tasking kernel which you  can  use  for
          both  general  (non-real-time)  and  real-time  applications.  It
          offers you, the programmer, the following features:

               1)  It's easy to use.

               2)  It's very flexible, and has the ability to serve as  the
          basis of a wide variety of applications.

               3)  It's highly efficient, making it ideally suited for  use
          in real-time applications.





               4)  It's compatible with  the  current  (single-tasking)  ST
          BIOS  and  GEMDOS  system  calls,  making  it  easy  to transport
          currently  existing   TOS   applications   to   a   multi-tasking
          environment.








               We wanted MICRO RTX to be easy to learn  and  easy  to  use.
          Because of this design philosophy, we've made a number of choices
          about the way MICRO RTX works, which are:

               We provided it with a small set of general purpose  services
          which  can be tailored to your specific needs, rather than trying
          to guess everyone's needs  in  every  situation,  and  then  make
          specific  routines  to  address  each of those needs.  This means
          that instead of having to learn a half  dozen  routines,  all  of
          which  perform  similar functions, you'll only have to learn one,
          more general purpose, routine.   Although  a  certain  degree  of
          flexibility  is  lost  this  way  (you  won't  necessarily have a
          routine to do EXACTLY  what  you  want),  you'll  find  that  the
          learning  curve  for  MICRO  RTX  is much shorter than for other,
          similar systems.  In addition,  once  you  do  learn  MICRO  RTX,
          you'll  find  that the number of programming errors you make will
          be lessened, since there  will  be  less  confusion  about  which
          particular system routine you should use for a given function.

               We designed MICRO RTX to put very few  restrictions  on  the
          user.   Instead of locking the user away from parts of the system
          in  a  user/system  manager  type  scheme,  (where  the  user  is
          prevented  from  accessing  parts  of  the  system  that  a  more
          privileged system manager has access to), we gave all users equal
          privileges.   Thus,  instead  of having to build a complex system
          protection scheme, we were able  to  concentrate  on  building  a
          fast, flexible system.

               All of the MICRO RTX service calls use a consistent argument
          passing  convention.   In addition, we've also kept the number of
          options at a minimum.  This means that once you learn the general
          framework of argument passing for a single MICRO RTX call, you'll
          know the calling convention for ALL the system service calls.

               We designed MICRO RTX services to be invoked via a  software
          interrupt, rather than through a procedure call.  This gives you,
          the programmer,  enormous  flexibility,  because  it  means  that
          there's  no  need  to link MICRO RTX to application programs that
          call it.  Furthermore, there's no dependence upon the conventions
          of  a  particular  high-level  language,  or  linker.  High-level
          languages are  interfaced  to  MICRO  RTX  via  simple  interface
          routines that translate compiler parameter passing conventions to
          those that MICRO RTX uses.   The  result  is  development  system
          independence--rather  than being forced to use only tools that we
          support,  you  can  use  the  development  tools  that  are  most
          comfortable for you.

               Finally, we designed MICRO RTX to be  TOS  compatible  at  a
          service  call  level.   This  means  that  you  can  execute  TOS
          application programs (programs that don't make  use  of  the  GEM
          interface)  under  MICRO  RTX  without modification.  Any program
          that correctly calls TOS routines will  operate  correctly  under
          MICRO RTX.


          1.4 What is Multi-tasking?










               Multi-tasking, in the computer environment, means giving the
          computer  the  ability  to  do  more  than  one  thing at a time.
          Normally, when we're using the computer,  we're  only  performing
          one  task  at  any  given moment, and often the computer is doing
          nothing at all.  For example, when we're editing a letter on  the
          computer,  we  often  type  a  word  or two, and then stop, while
          thinking of the next thing to say.   While  we're  sitting  there
          thinking,  the  computer  is  doing  nothing at all.  It's simply
          waiting for us to type the next  character.   What's  more,  even
          when  we  ARE typing along, the very brief (to us) pauses between
          each keystroke, are, to the computer, long  periods  of  time  in
          which it's doing nothing. So for all intents and purposes, we are
          vastly underutilizing the resources of our very powerful machine.
          But  what  if  we  could  find  a  way  to  use the computer more
          efficiently?  What if there was a way to  have  the  computer  do
          more than one thing at a time?

               That's exactly what multi-tasking does.  It  allows  you  to
          have more than one task running at a time, and the computer takes
          care of the scheduling.  For example, before we start  editing  a
          document, suppose we start compiling a file.  We set the compiler
          up as a low priority, "background" task, and then start our edit.
          Now,  in  between  the time we hit keys, and while we're thinking
          about our document, the computer will be busy compiling the file.
          When  we  hit  a key, or otherwise do something that requires the
          editor to respond, the computer will put the compiler 'to sleep',
          then start the editor, process the input, then start the compiler
          back up.  In this way,  we're  making  much  fuller  use  of  the
          resources  of  the computer, and are doing so in a way that gives
          us much more computing power for essentially no increase in cost.





































          2.
                                      Chapter 2

                                  System Components


               MICRO RTX is a real-time, multi-processing, operating system
          kernel.   It  has  a multitasking scheduler, queue manager, event
          manager, time manager and memory manager.

               The scheduler is responsible for coordinating the  execution
          of processes within the system.

               The memory manager allocates and deallocates memory segments
          on behalf of processes that are running in the system.

               The remaining parts of the system work with the scheduler to
          provide interprocess communication and synchronization, real-time
          pausing, and round robin scheduling.


          2.1 Processes

               A "Process" is the atomic unit of execution in  the  system,
          i.e.,  a  single  task.   In  a  single  tasking system, only one
          process runs at a time.  Under MICRO RTX, many processes  can  be
          running  simultaneously.   All  programs that you, the user, run,
          are processes, as are a number  of  other  self-contained  system
          utilities that are discussed in detail later in the manual.  Note
          that each process competes with all other processes for both  CPU
          time and other system resources (memory space, etc.).

               Each  process  exists  in  its  own  environment,  which  is
          provided  and maintained by MICRO RTX.  A process may acquire and
          use  system  resources  for  itself  without  regard  for   other
          processes.   MICRO  RTX handles all arbitration between processes
          and the multi-processing environment.

               Processes  may  modify  certain   aspects   of   their   own
          environment,  as  well  as  certain  aspects  of other processes'
          environments.     Furthermore,    processes    can     cooperate,
          communicating with each other, and sharing resources.


          2.1.1 Process Name

               When a process is created, it may be  given  a  name.   This
          name is used by other processes when communicating with this, the
          named process. A process name consists of a maximum of 12  alpha-
          numeric characters.  The characters may be any valid ST character
          (ie, A-Z, a-z, 0-9 and various punctuation characters).


               CAUTION!!  MICRO RTX does NOT prevent two or more  processes
          from  having  identical names!  The results of naming two or more
          processes with identical names are guaranteed to be strange!


          2.1.2 Process ID







               A process is known throughout the system by its  process  ID
          (pid).  References  to a process require the pid.  When a process
          (The "Parent" process) creates a subsidiary process (known as  an
          "offspring"), the parent is given the offspring's pid at the time
          of creation.

               A pid for a process may be obtained by processes other  than
          the  parent  if  the  user knows the desired process' name.  (See
          "Process Name").

               By convention, a pid value of 0 (zero) is an alias  for  the
          currently "running" process (ie, the calling process).

               Technically, the pid for a process is actually  the  address
          of  the  Process Control Block (PCB) of that process.  The PCB is
          an internal data structure used by MICRO RTX to maintain  process
          context.


          2.1.3 Process States

               A process can be in one of several states.  The three  major
          ones are:

                  o Running (Currently being executed by the CPU)

                  o Ready-to-run (Waiting for the CPU)

                  o Blocked (Waiting for something other than the CPU)

               The  RUNNING  process  is  simply  the  one  that  has  been
          allocated  the  current  use  of  the  CPU.   Normally,  this  is
          equivalent to the process being executed by the CPU.  However,  a
          process may NOT be currently being executed by the CPU, and still
          be considered to be the "running" process if:

                  o The CPU is temporarily servicing an interrupt, or

                  o The CPU is executing a kernel service as
                    requested by the process.

          The running process becomes a ready-to-run process when:

               o It is preempted by  an  unblocked  (ready-to-run)  process
          with  a  higher priority than its own (which could happen because
          of the currently running process' own actions, or because  of  an
          interrupt service).

               o It loses the CPU to a  ready  process  of  equal  priority
          because  its  current  time-slice  share  of the CPU is exhausted
          (round-robin scheduling).


               o It lowers its own priority, or raises the  priority  of  a
          ready-to-run  process,  so  that  it  is  no  longer  the highest
          priority process.









               A READY-TO-RUN process is one that is waiting to "run",  ie,
          become the "running" process.  A ready-to-run process becomes the
          running process when:

                  o The currently running process:
                          -- blocks itself
                          -- lowers its priority
                          -- raises the ready-to-run process' priority to a
                             level higher than its own or any other
                             ready-to-run process
                          -- consumes its current time-slice allotment


               In all cases, the result is the same:  For whatever  reason,
          the  currently  running process can no longer run.  The ready-to-
          run process has the  highest  priority  of  all  the  ready  (ie,
          waiting)  processes, and so MICRO RTX moves it into the "running"
          state.

               The BLOCKED state is not  properly  considered  a  state  in
          itself;   rather,  a  process  is  considered  blocked when it is
          neither running, nor ready-to-run.  Blocking is always the result
          of some deliberate action on the part of the process itself, most
          typically a request for  a  currently  unavailable  resource.   A
          process will become blocked when:

                  o It requests a message from an empty message queue (see
                    "Message Queues").

                  o It requests a 'wait for event' condition (see "Event
                    Manager").

                  o It requests a 'wait for time' condition, ie,
                    it's waiting for a specified interval of time
                    to elapse.


               A blocked process will move to the ready-to-run  state  when
          the condition that caused it to be blocked has been removed.  For
          example, a message that was requested by a process, but that  was
          previously unavailable, may now be available;  or a 'timeout' may
          have occurred, that is, none of  the  above  conditions  happened
          within   the   specified   maximum  wait  interval  (the  timeout
          interval).

               Figure 2.1 is a simplified flow diagram of the above system.





















                 ---------------------------------------------------
                 |                                                 |
                 |                                                 |
          +-----------------+             +--------------------+   |
          | Executing Task  |<----------->|  Ready to Run      |   |
          | (One Task ONLY) |             |  (Many Tasks)      |   |
          +-----------------+             +--------------------+   |
                 |                          ^     ^                |
                 |                          |     |                |
                 |    |----------------------     |                |
                 v    v                           v                |
          +-------------------+           +--------------------+   |
          | Blocked (waiting) |---------->|  Inactive Tasks    |<---
          | (Many Tasks)      |           |  (Many Tasks)      |
          +-------------------+           +--------------------+


          Note that an executing task can move to any of  the  other  three
          states directly, either because of its own actions, or because of
          some system intervention (i.e., the executing process' time slice
          is  consumed).   A  blocked task may never move directly from the
          blocked state to the executing state.  Even if the unblocked task
          now  has  the  highest priority in the system, it must still move
          through the ready-to-run list first.

          2.1.4 Process Scheduling

               MICRO RTX uses a  real-time  process  scheduling  algorithm.
          When  a  process  is  created,  it  is  assigned  a priority.  At
          dispatch time (that is, the time  when  MICRO  RTX  must  make  a
          decision  as  to  which process to execute), the scheduler simply
          selects and executes the process with the highest  priority  from
          the group of processes that are currently in the ready or running
          state.  Note that the currently running process  is  included  in
          this  group--if  the  currently  running  process has the highest
          priority, MICRO RTX simply continues running  that  process.   If
          there  is  a process of higher priority in the ready-to-run list,
          then MICRO RTX moves the  current  process  out  of  the  running
          state, and places the ready-to-run process in the running state.

          2.1.4.1 Process Priorities

               A process may be created at one  of  255  software  priority
          levels.  255 is the highest priority a process may have, and 1 is
          the lowest priority a process may have.  A priority  level  of  0
          (zero)  is  reserved for an 'idle demon' process, a process which
          does nothing more than soak up idle CPU time.  The 'idle  process
          demon'  will  run when there are no other processes in either the
          running or ready-to-run state (This can occur if there are simply
          no  processes  in  the  system,  or if all processes are blocked,
          awaiting some event).


               The priority assigned to a process  may  be  changed  during
          run-time, both by the process itself, and by other processes.

          2.1.4.2 Round Robin Scheduling








               In addition to a priority level scheduler,  MICRO  RTX  also
          supports  "round robin" scheduling, which is quite transparent to
          the processes involved.  In round robin scheduling, each  process
          is  allotted a certain amount of time (known as a 'time-slice' or
          a 'quantum') in which to run.
           When a process is moved to the running  state,  this  time-slice
          begins  to  be consumed.  When the time-slice reaches zero, MICRO
          RTX looks at its task list to determine the next  process  to  be
          run.   When  a process occupies a priority level by itself, MICRO
          RTX will simply replenish the time-slice, and continue  executing
          the  process;  thus, time-slicing a single process has no effect.
          If two or more processes occupy the same priority level, and  the
          current process has exhausted its time-slice, then MICRO RTX will
          force the current process to  relinquish  the  CPU  to  the  next
          process.

               NOTE:  A  process  running  at  priority  255  (highest)  is
          considered to be executing 'real-time', and is never time-sliced.
          This  means  that  this  process  will  always  run,   until   it
          voluntarily blocks itself, or lowers its own priority level.

          2.1.5 Process Creation

               Process creation refers to the act of making a  process  and
          its attributes known to the MICRO RTX kernel.  After a process is
          created, it competes for the CPU and other system resources.

               When a process is created, MICRO  RTX  allocates  a  Process
          Control  Block  (PCB)  for  it  and places the new process in the
          Ready-to-Run state.  (See "Process Control Block").

          2.2 Interprocess Communication and Synchronization

               Normally, processes run independently of each other, with no
          communication between them.  This would be the case, for example,
          if we were using a word processor, and had a compiler running  in
          the  background.   However, there are many situations where it is
          desirable to  give  processes  the  ability  to  communicate  and
          synchronize  with  one  another.   MICRO RTX provides two sets of
          facilities for these purposes:

               o The message queue, and

               o Events

               The  message  queue  services  provide  a  general   purpose
          mechanism  for  interprocess  communication  and synchronization.
          The event services are more restrictive, but provide  a  simpler,
          low-overhead  alternative for processes with more straightforward
          synchronization needs.

          2.2.1 The Message Queue


               The message queue is  MICRO  RTX's  general-purpose  message
          passing  facility.   This  facility  can be used for interprocess
          communication, as well as process synchronization.









               Messages are routed through  a  message  "queue",  which  is
          simply  a  holding  area  for particular message(s).  One or more
          processes may place a message in a particular queue;   similarly,
          one  or  more  processes  may  request messages from a particular
          queue.  Note that the number of processes placing messages  in  a
          queue,  and  the  number  of processes requesting messages from a
          queue need not be the  same.   This  feature  allows  the  simple
          implementation of an N to M process communication scheme, where N
          and M are different numbers of processes.

          2.2.2 Creation and Deletion of Message Queues

               Message queues, like  processes,  are  created  and  deleted
          dynamically at run-time.

               The service call Q_CREATE creates a message queue, and takes
          as  input an 8-character user-assigned name and an attribute. The
          attribute specifies whether the message queue will make processes
          wait first-in-first-out, or by process priority.

               Message  queues  may  be  created  all   at   once,   during
          initialization,  or  they  may be created and deleted when and as
          needed.

               A message queue may be deleted with  the  Q_DELETE  service,
          which  takes  care  of  any  clean-up work required. If there are
          processes waiting there, then they will be removed from the  wait
          queue  and  returned  to  the  ready  state.  When they run, each
          process will return from its Q_REQ call with an error  indicating
          the  message queue has been deleted.  On the other hand, if there
          are messages queued at the message queue,  then  Micro  RTX  will
          reclaim the message buffers. (See Message Buffers below.)

          2.2.3 Message Queue Name and ID

               A message queue, like a process, is known by two identities:
          an  8-character name given to it by the user, and a unique 32-bit
          queue ID (qid) assigned to it by Micro RTX, when it  is  created.
          Except  for  Q_LOOKUP,  service  calls  which reference a message
          queue must use its qid.  Messages are sent to and requested  from
          a message queue using its qid.

               The qid of a message queue is known to the creating process,
          since  it  is  returned  by  the  Q_CREATE  service  call.  Other
          processes, which know the user-assigned name, may obtain the  qid
          in one of two ways:

                  a) Use the Q_LOOKUP service, which returns the qid.

                  b) Obtain the qid from the creator, via a global variable.




               The qid, like the process ID, is in fact the  address  of  a
          system data structure that controls the message queue.  Using the
          address itself, as opposed to an index, eliminates  the  need  to
          search  for its control structure, and therefore, improves system
          performance.







          2.2.4 Messages and Message Buffers

               Processes communicate and synchronize by sending messages to
          and  requesting messages from message queues.  Micro RTX messages
          are fixed length, 4 long-words, formatted as follows:

                  +--------------------+
                  |      reserved      |  ---- Header
                  +--------------------+
                  |     long word 0    |  --+
                  +--------------------+    |
                  |     long word 1    |    +- Body
                  +--------------------+    |
                  |     long word 2    |  --+
                  +--------------------+

               The top field is reserved  for  system  use.  The  remaining
          three  long-words make up the body of the message, the format and
          content of which is totally up to the user.  It may  be  used  to
          carry  data,  pointer  to data and data size, the sender's pid, a
          response qid, etc.

               A message buffer is also 4 long-words.  Free message buffers
          are  kept  in  a list.  When a message arrives at a message queue
          and must be queued, then a buffer is taken from  this  free  list
          and used to hold a copy of the message.

               The total number of system  message  buffers  is  fixed  and
          specified  by  an entry in the Micro RTX Configuration Table (See
          section 5.1, The Configuration Table).

          2.2.5 Synchronizing Several Tasks Using Message Queues

               These examples are intended  to  give  an  overview  of  the
          message passing facilities provided by MICRO RTX, and some of the
          ways in which they can be used.

               NOTE!  MICRO RTX provides no intrinsic mechanisms to prevent
          the  problem  of deadly embrace to which multi-processing systems
          are prone.  The user is advised  to  implement  and  observe  the
          commonly known measures against deadlock (See Appendix A).

          2.2.6 A simple FIFO (First In, First Out)

               Message queues may be used as simple  FIFO  channels,  where
          one  or  more  processes  place messages into a queue, and one or
          more processes remove them.   This  provides  a  simple  one-way,
          non-interlocked  method of synchronization.  That is, a receiving
          process is synchronized with the receipt of a message  (it  won't
          come alive until it gets one), but a sending process may continue
          sending messages without restriction.  NOTE that this scheme does
          not  inherently  prevent  the  overproduction  of  messages  (see
          section 5.1.2 for further information on message overproduction).

               An example of this type of queue  scheme  might  be  in  the
          implementation   of   a  simple  print  queue.   One  process  is
          responsible for the actual printing of documents on the  printer,
          while  many  processes  wish  to submit jobs to be printed.  Each
          submitting  process  might  submit  a  message  to   the   queue,
          containing the following information:







                  o Time/date stamp of file

                  o Filename to be printed

                  o Number of Copies to be printed


               Once a process had submitted a print request, it would  then
          continue  with its own activities.  The print process, meanwhile,
          would take the first message from the message  queue,  and  print
          that  file  according to the information contained therein.  Once
          it had finished printing the first job, it would again go to  the
          message queue, and get the next job to be printed.
           If there were no more jobs to  be  printed,  the  print  process
          would  be  put  into  the  blocked state, pending arrival of more
          print requests. NOTE that the order in which print  requests  are
          made  by the various processes is the order in which they will be
          printed, hence the  name  FIFO  (First  Into  the  print  request
          buffer, First Out to the print process). [See figure 2.1].

                      q_send     +---+   q_req
          Process A -----------> | Q | -----------> Process B
                                 +---+
             .                                          .
             .                                          .
             .                                          .


                               Figure 2.1

          2.2.7 Fully Interlocked Synchronization

               Using two message queues, fully interlocked  synchronization
          can  be  achieved.  A process is a receiver from one queue (makes
          Q_REQ calls of that queue) and is a supplier to the  other  queue
          (makes  Q_SEND  calls to the second queue).  Consider the general
          case, where a process sends a message to one queue, and does  not
          proceed  until  it receives a message from the second queue.  The
          other process synchronizes with the receipt of the first message,
          then  after performing some action, posts a message to the second
          queue.  The send and receive acknowledge cycle may  be  separated
          by  any  amount  of processing.  Therefore, the two processes may
          execute in parallel, and need only synchronize in an  interlocked
          fashion when necessary. (See figure 2.2)






















                      q_send     +---+   q_req
          Process A -----------> | Q | -----------> Process B
                                 +---+
             .                                          .
             .                                          .
             .                                          .
                      q_req      +---+   q_send
          Process A <----------- | Q | <----------- Process B
                                 +---+
             .                                          .
             .                                          .
             .                                          .


                               Figure 2.2

          2.2.8 Message Queues as Semaphores

               The  MICRO  RTX  message  queue  services  may  be  used  to
          implement  Dijkstra's  P/V  primitives  (see  reading list in the
          appendix).  A semaphore is represented by a message queue, and  a
          count  is  implemented with a number of null messages.  Thus, the
          'initialize_semaphore' primitive is simply performed by  creating
          a  message queue, and posting the correct number of null messages
          to it.  The 'P' primitive becomes the q_req service call, and the
          'V'  primitive becomes the q_send call.  If one or more processes
          are waiting for a message from the queue, the process at the head
          of  the  waiting  list  is handed the meaningless (null) message.
          Mutual exclusion may be implemented using a message queue with  a
          single  message  which  represents  a token to a shared resource.
          Prior to using the resource, a process  must  acquire  the  token
          (ie,  take  the message from the queue). When it is finished, the
          process then returns the token (ie, sends a copy of  the  message
          back  to  the  queue),  whereupon  other processes that have been
          blocked awaiting a message in that queue may execute. (See figure
          2.3)






























                  Initialize Semaphore
                          |
                          | q_send...
                          |
                          |
                          |
                          |           q_req
                          |     ------------------> P_Semaphore
                          |     |
                          |     |
                          |     |
                          V     |
                   +----------------+     q_send
                   |     Queue      | <-----------  V_Semaphore
                   +----------------+


                               Figure 2.3

          2.2.9 Events

               In addition to  the  generalized  message  queue  structure,
          MICRO  RTX  also  provides  a  more restricted and more efficient
          alternative  for  process  synchronization.   Each  process   has
          associated with it a set of seven 'events'.  A process can signal
          (ie, flag as having happened) one or  more  of  these  events  in
          another  process.   It can also wait for the occurrence of one or
          more of its own events (with an optional  time-out  interval  for
          waiting).   For example:  We have two processes, A and B. Process
          A indicates that it is waiting for one of its  events  to  occur.
          Process  A  is  now  idle  until  that event happens.  Process B,
          meanwhile, signals Process A's event area, which causes Process A
          to 'wake up', and become ready-to-run.

               The primary limitation of events, is that  unlike  messages,
          they  are  not  buffered  or  queued  in  any  way.   Thus,  it's
          impossible to tell if a process has had  one  event  of  a  given
          type,  or  30  (or  any  other  number,  for  that matter), i.e.,
          multiple identical pending events are  lost  forever.   In  cases
          where  multiple  event  overruns  can't  occur, or can be handled
          appropriately by the process, the event mechanism does offer  the
          advantage of being able to specify multiple events.

          2.2.10 Interrupt Synchronization

               Many real-time systems must be able to respond to input from
          the  real  world,  which  typically occur in the form of hardware
          interrupts.  This response is embodied in  an  interrupt  service
          procedure  (ISP),  which  clears  the  interrupt  condition,  and
          handles the immediate physical action necessary to respond to the
          interrupt.   Furthermore,  once  this  has occurred, the ISP must
          have a way of  communicating  the  fact  that  an  interrupt  has
          occurred  to the user process.  Fortunately, MICRO RTX provides a
          mechanism for this type of communication.











               An ISP normally services an interrupt  by  clearing  it  and
          performing  any  necessary  immediate  physical  action.  Further
          processing should be deferred to an associated process  with  the
          appropriate  software  priority.  This process can synchronize to
          the occurence of a hardware interrupt by using  either  of  MICRO
          RTX's communication facilities, the message queue or an event.

               The ISP can also use either the message queue or an event to
          signal  a  waiting  user  process that an interrupt has occurred.
          However, it  may  ONLY  use  those  kernel  functions  which  are
          specifically  associated  with  sending such a signal, ie, it may
          only use the

                  o q_send,

                  o q_jam, and

                  o e_signal

          MICRO RTX kernel services.  Other service calls are  not  allowed
          from  within  an  ISP.  Making calls not listed above from an ISP
          will  lead  to  dangerous  race  conditions,  and   unpredictable
          results.

               An ISP should exit by trapping into the Micro RTX RTE  entry
          by  issuing  a trap 4 instruction.  This gives Micro RTX a chance
          to perform any necessary process scheduling that  may  have  been
          caused by this ISP.

               Upon entry to the RTX RTE trap, Micro RTX must  decide  what
          to execute next.  If the interrupt came in the midst of:

                  (a)  a lower level ISP, then Micro RTX will return (RTE)
                       directly to it;

                  (b)  code internal to Micro RTX, then Micro RTX will
                       return (RTE) directly to it;

                  (c)  a process, then Micro RTX will dispatch to run the
                       highest priority ready process.

          2.3 Memory Management

               MICRO RTX has an efficient memory manager,  which  allocates
          memory  segments to processes from a common heap area.  There are
          no restrictions on the use of memory acquired from the heap.

          2.3.1 Ownership of Memory Segments

               MICRO RTX keeps track of all memory  resources  owned  by  a
          process.   It  is  unnecessary  for  a  process to perform memory
          management, other than to correctly allocate memory using  kernel
          service calls.  Common errors to avoid are:














                  o Assuming that there is some fixed amount of memory
                    beyond the end of your process.

                  o Determining the amount of free memory, and then
                    allocating all of that memory in smaller chunks.
                    For example, one program we know of checks to see
                    if there is 32K worth of free memory.  If there is,
                    it allocates it in 1K chunks.  This will not
                    necessarily work with a multi-tasking system, since
                    in between the time the memory size was checked and
                    the time the program allocates it, another program
                    could have run, and allocated some of that same
                    memory for its own use.

                  o Using more memory than you've allocated for your
                    process.

               When a process is deleted, all segments of  memory  used  by
          that process are automatically returned to the memory manager and
          made available to other processes.

          2.4 Time Management

               The Atari ST real-time clock is used to control basic system
          time management.  It supplies the time-base, and allows MICRO RTX
          to count down paused processes and  track  the  running  process'
          time-slice for round robin scheduling.

          2.4.1 Pausing

               A paused process is blocked by MICRO RTX from execution  for
          a specified interval of time.

               A process may be paused by a direct action on  the  part  of
          the  process itself, or via an indirect action, such as a request
          for a message or event that has not yet occurred.  In the  latter
          case  the process is blocked awaiting fulfillment of the request;
          if the  request  cannot  be  met  within  the  specified  maximum
          interval  (the time-out value), the request will be canceled, and
          a time-out error message will be returned to the process.

          2.4.2 Time-Slice

               Each process possesses a time-slice value which  is  counted
          down  (decremented) while the process is running.  When the time-
          slice value is consumed (reaches zero), and there are one or more
          other  process  that  are  ready-to-run  and  that  have the same
          priority, then the current process relinquishes the  CPU  and  is
          put  below  all  the  other processes of the same priority on the
          ready-to-run stack (but above any processes of  lower  priority).
          Let's take a look at figure 2.2.















          Stage   -->     1             2             3             4
          ----------------------------------------------------------------
          Running -->  Process A     Process B     Process C     Process A

          Ready
          to run  -->  Process B     Process C     Process A     Process B
                       Process C     Process A     Process B     Process C
                       Process D     Process D     Process D     Process D

                                  Figure 2.2

               We have four processes, A, B, C and D.  Processes A, B and C
          all have the same priority, while process D has a lower priority.
          When we first look at the system, process A is running.  This  is
          stage  1.   After process A's time-slice has been consumed, it is
          removed from the running state, and placed into the  ready-to-run
          state,  below  processes B and C, but above process D.  Process B
          is then moved up to the running state.  This is stage  2.   After
          process  B's  time-slice is consumed, it's moved from the running
          state to the ready-to-run state, below process A,  but  above  D.
          Process C is then moved into the running state.  This is stage 3.
          After process C's time slice has been consumed, it's  moved  down
          into  the  ready-to-run stack, below process B, but above process
          D.  Process A is then moved into  the  running  state.   This  is
          Stage  4,  which  is  the  same as stage 1.  From here, the cycle
          repeats itself.


          2.5 TOS Compatible Services

               MICRO  RTX  provides  a  BIOS  and  GEMDOS  compatible   I/O
          subsystem.   From the application's point of view, these services
          work in exactly the same manner as the standard TOS services  do.
          There's  no  difference  in  the calling mechanism, or in what is
          returned.

               Although externally the MICRO RTX services appear  identical
          to standard single-tasking TOS service calls, internally they are
          are much more sophisticated,  providing  multi-processing  device
          drivers,  memory  management, and file system support.  Input and
          output blocking is handled automatically by the I/O subsystem.

               Because the calls are the same,  existing  TOS  applications
          may  be  transported  directly  to MICRO RTX, without need of re-
          writing the I/O subsystem calls.  This also  minimizes  the  need
          for  you,  the  application developer, to learn new and redundant
          service calls.

          2.5.1 BIOS Services




               MICRO RTX provides  real-time  input/output  device  support
          through  a  set of services that are compatible with the standard
          TOS BIOS.  MICRO RTX's BIOS  performs  automatic  blocking  of  a
          device  on  behalf of the calling process; there is no need for a
          process to worry about the availability of a  device.   The  BIOS
          itself  operates  on  the  physical device; a process never talks






          directly to a device,  but  rather  acquires  and  releases  that
          device   indirectly,   through   the   BIOS.   Device  allocation
          contentions (which process will have access to  the  disk  drive,
          for example) are handled automatically by MICRO RTX, and need not
          be a concern of the calling process.

          2.5.2 DOS Services

               MICRO RTX  provides  a  multi-tasking  file  manager,  whose
          services  are  run-time  compatible  with the standard TOS GEMDOS
          services.  Application programs designed to use the GEMDOS system
          services will be directly compatible with the MICRO RTX DOS.  The
          MICRO RTX DOS services fall into several categories:

                  1.  System Management

                  2.  Character Device I/O

                  3.  Memory Management

                  4.  Process Management

                  5.  File Management

                  6.  Directory Management

          many of which correspond directly to the TOS GEMDOS calls for the
          same functions.  For further information on those calls which are
          not outlined here (and can thus be assumed  to  be  identical  to
          GEMDOS   calls),   refer   to  the  Atari  GEMDOS  documentation,
          specifically the GEMDOS specification, rev. 13,  and  the  GEMDOS
          quick  reference  guide  in  the  Atari Hitchhiker's Guide to the
          BIOS.

          2.5.3 MICRO RTX TOS extensions

               The  MICRO  RTX  I/O  Subsystem  also   implements   several
          enhancements  to  the  standard TOS services.  These enhancements
          are described in detail in chapter 4 of this manual.




























          3.
                                      Chapter 3

                               MICRO RTX Service Calls

          3.1 Introduction

               This chapter describes the MICRO RTX kernel service calls in
          detail.   This  chapter  does  NOT  describe  the  Atari ST BIOS,
          Extended  BIOS,  GEMDOS,  VDI,  AES  and  GSX  system  functions.
          Information  on these calls is available in the appropriate Atari
          and  DRI  documents.    (See   the   Bibliography   for   further
          information).

          3.2 Calling Conventions

               The MICRO RTX kernel services use the same parameter passing
          conventions  that  the  standard  Atari ST BIOS and GEMDOS system
          functions do.  That is:

                  o The kernel services receive parameters on a stack frame.
                    This allows kernel calls from C and other high level
                    languages, as well as assembly language.

                  o The calling program builds a stack frame, and then enters
                    the kernel with a TRAP instruction, and, through a
                    previously installed vector, execution is passed to
                    the MICRO RTX kernel entry point.


          3.3 Kernel Service Stack Frames

               The kernel service call stack frame  is  the  way  in  which
          arguments  are  passed  to the kernel service calls, and have the
          following form:































                  +-----------------------------+  Low Memory
                  |       Function Number       |
                  +-----------------------------+
                  |       1st Parameter         |
                  +-----------------------------+
                  |       2nd Parameter         |
                  +-----------------------------+
                  |       3rd Parameter         |
                  +-----------------------------+
                  |       4th Parameter         |
                  +                             +
                  |                             |
                  +-----------------------------+
                  |       5th Parameter         |
                  +-----------------------------+
                  .                             .
                  .       etc...                .
                  .                             .
                  +-----------------------------+ High Memory

          Note also that one 'space' is considered to be an int,
          whereas two 'spaces' denotes a long.  In the example
          above, the 1st, 2nd, 3rd and 5th parameters (as well as
          the Function number) are all ints, and the 4th parameter
          is a long.

               The number, type and value of the input parameters for  each
          kernel  service  call  are, obviously, unique to that call.  Some
          parameter checking (for illegal values and wrong data  types)  is
          performed by the kernel.  In general, however, parameters are NOT
          checked, and the wrong data  type  or  out  of  range  value  may
          produce  unpredictable  or fatal results.  (And we DO mean fatal.
          An example  of  this  is  the  standard  Atari  ST  GEMDOS  call,
          Fwrite().   One  of the parameters passed in that call is a value
          describing the number of bytes to write.  However, if this  value
          was  not  EXPLICITLY  cast  as  a  LONG,  then the function could
          allocate every free FAT on the disk.  So read the function  calls
          CAREFULLY!)

          3.4 Kernel Service Register Usage

               All kernel services return information in register  D0.   If
          you're writing in C, this is equivalent to:

                  return = function_call(parameters);

               The standard registers which C defines as  non-volatile  are
          preserved,  while volatile registers may or may not be destroyed,
          but are not guaranteed to be preserved.  Specifically,  registers
          D3-D7,  A3-A7,  the  SSP and the USP are preserved, and registers
          D0-D2 and A0-A2 are used (destroyed) by the kernel services.

          3.5 Kernel Service Descriptions

               On the following pages you'll  find  the  actual  MICRO  RTX
          kernel service descriptions, ordered by their respective function
          numbers.  Each call starts on it's own  page,  and  contains  the
          following information:








          SYNOPSIS

                  A C style summary of the service call.

          DESCRIPTION

                  A narrative description of the function,
                  its requirements, limitations, effects and side
                  effects.

          PARAMETERS

                  A description of the stack frame used by the call.

          RETURN CODE

                  Gives a description of what data will be returned
                  to the calling routine.

          FRAGMENT

                  When useful, we've included a C source code fragment
                  as an example of how the call works.











































          3.5.1 RTX_INSTALL         Function Number: 00

          SYNOPSIS

                  char *rtx_install(config)
                  struct config {
                          char *basepage;
                          int max_proc;
                          int max_msgs;
                          int max_queues
                          int (*create_call)();
                          int (*delete_call)();
                          int (*switch_call)();
                  } *config;
                  {
                  }

          DESCRIPTION

               This service call must be  made  before  any  other  service
               calls  are  performed.   It installs the MICRO RTX Operating
               System Kernel,  overlaying  the  system  vector  page.   The
               config  argument is a pointer to the MICRO RTX configuration
               table,  which  contains   the   data   necessary   for   the
               initialization  of the MICRO RTX kernel.  This data table is
               described in detail later in the manual.  (See section  5.1,
               The Configuration Table).

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |      Function Code = 00       |
                  +-------------------------------+
                  |            config             |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L contains the longword pid  of  the  MICRO  RTX
               root  process  if  MICRO  RTX was successfully installed, or
               zero if it could not be installed.























          FRAGMENT


                  {
                          char *rtx_install();
                          char *install;
                          struct config {
                                  char *basepage;
                                  int max_proc;
                                  int max_msgs;
                                  int max_queues
                                  int (*create_call)();
                                  int (*delete_call)();
                                  int (*switch_call)();
                          } config;

                          /* set up the config table */
                          config.basepage = _base;/* ROOT GEMDOS basepage */
                          config.max_proc = 10;   /* 10 processes max */
                          config.max_msgs = 10;   /* 10 messages max */
                          config.max_queues = 10; /* 10 queues max */
                          config.create_call = 0; /* no hooks */
                          config.delete_call = 0; /* no hooks */
                          config.switch_call = 0; /* no hooks */

                          /* install Micro RTX */
                          install = rtx_install(&config);
                          if(install == 0)
                          {
                                  printf("MICRO RTX could not be installed.");
                                  return(-1);
                          }
                  }

































          3.5.2 P_CREATE       Function Number: 01

          SYNOPSIS

                  char *p_create(name, priority, slice, load,
                                 arg_count, args, stack_size)
                  char *name;
                  int   priority;
                  int   slice;
                  int   (*load)();
                  int   arg_count;
                  char *args;
                  long stack_size;
                  {
                  }

          DESCRIPTION

               The P_CREATE service call creates a new process.  MICRO  RTX
               allocates  a  stack  segment  for  the  process, assigns the
               priority and time-slice values to the  new  process,  copies
               'arg_count'  words  from  the  address  'args'  onto the new
               process stack, and places the new process in  the  ready-to-
               run  state  to  wait for its turn to execute.  P_CREATE then
               performs an effective "jsr" to the load address.  This  way,
               the load address can be the address of a C function.  If the
               new process has a higher priority than that  of  its  parent
               (the  calling  process),  then  the  calling process will be
               preempted after making the  P_CREATE  call,  and  the  child
               process  will  begin execution.  The name argument is a null
               terminated ASCII string of which the first 12 characters are
               significant  (see section 2.1.1, "Process Name").  It should
               be noted that in executing a  GEMDOS  Pexec  call  (function
               0x4B)  a  P_CREATE  call  is  automatically performed by the
               MICRO RTX I/O subsystem.  During a Pexec  call,  the  parent
               process  becomes blocked until the child process terminates,
               at which time the child will signal  the  parent,  and  then
               commit  suicide  (see 3.5.3, "P_DELETE").  The stack size is
               specified in bytes.   The  time-slice  value  specifies  the
               number of 200Hz timer ticks between time-slices.


























          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 01      |
                  +-------------------------------+
                  |             name              |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |           priority            |
                  +-------------------------------+
                  |            slice              |
                  +-------------------------------+
                  |            load               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |          arg_count            |
                  +-------------------------------+
                  |            args               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |          stack_size           |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L contains a long word,  which  is  the  spawned
               process' ID (pid), or zero if the P_CREATE call failed.


































          FRAGMENT

                  int func(x, y)
                  int x, y;
                  {
                          /* this function receices two integer arguments */

                          /* deamons loop forever */
                          for (;;)

                                  /* do something with the input arguments */
                                  do_something(x, y);

                  }
                          ...
                  {
                          char *p_create();
                          char *new_pid;
                          struct {
                                  int x;
                                  int y;
                          } stack_frame;
                          int word_count;

                          stack_frame.x = 1; /* 1st input argument */
                          stack_frame.y = 2; /* 2nd input argument */
                          /* word count of stack frame */
                          word_count = sizeof(stack_frame) / sizeof(int);
                          new_pid = p_create("MYPROCESS", 50, 50,
                                       func, word_count, &stack_frame, 500L);

                          if(new_pid == 0)
                          {
                                  printf("Process failed to execute");
                          }
                  }






























          3.5.3 P_DELETE       Function Number: 02

          SYNOPSIS

                  p_delete(pid)
                  char *pid;
                  {
                  }

          DESCRIPTION

               This service call deletes a process.  A process  can  delete
               other processes, or delete itself (suicide).

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 02      |
                  +-------------------------------+
                  |             pid               |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W contains a word that is zero  if  the  process
               was  successfully  deleted.   Obviously,  if  the process is
               deleting itself, the p_delete call will never return.

          FRAGMENT

                  {
                          char *proc_id;
                          int return_code;

                          /* Delete process... */
                          return_code = p_delete(proc_id);

                          if(return_code != 0)
                                  printf("Process not deleted...");

























          3.5.4 P_PRIORITY          Function Number: 03

          SYNOPSIS

                  p_priority(pid, delta)
                  char *pid;
                  int delta;
                  {
                  }

          DESCRIPTION

               This service call allows the calling process to  obtain  and
               optionally  modify  the software priority of a process.  The
               value specified by _delta_ is a signed integer that is added
               to  the  process' current priority.  The result then becomes
               the process' new priority.  A process can modify its own, as
               well  as other processes', priority level.  Using a value of
               0 (zero) for _delta_ will effectively perform no action, and
               will  return  the  current  priority level for the specified
               process.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 03      |
                  +-------------------------------+
                  |             pid               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            delta              |
                  +-------------------------------+

          RETURN CODE

               The old priority value  is  returned  as  a  word  value  in
               register D0.W.




























          FRAGMENT

                  {
                          char *pid;
                          int delta;
                          int priority_level;

                          /* Get priority level of currently running */
                          /* process (ie, myself)                    */

                          priority_level = p_priority(0L, 0);

                          printf("Priority is: %d", priority_level);
                  }




















































          3.5.5 P_SLICE             Function Number: 04

          SYNOPSIS

                  p_slice(pid, delta)
                  char *pid;
                  int delta;
                  {
                  }

          DESCRIPTION

               This service call allows the calling process to  obtain  and
               optionally  modify  the time-slice value for a process.  The
               time-slice value is measured in increments of  200Hz  system
               timer  ticks  (ie,  a  time-slice value of 1 means 5ms, of 2
               means 10ms, of 100 means a  half  second,  etc.)  The  delta
               value  is  a  signed  integer  which is added to the current
               time-slice value;  the result  then  becomes  the  new  time
               interval  corresponding  to  a  full-slice for the specified
               process.  A process may change its own time-slice value.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 04      |
                  +-------------------------------+
                  |            pid                |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |           delta               |
                  +-------------------------------+

          RETURN CODE

               The old time-slice value is returned  as  a  word  value  in
               register D0.W.

          FRAGMENT

                  {
                          int slice_value;

                          /* Get time slice value of currently running */
                          /* process (ie, myself)                      */

                          slice_value = p_slice(0L, 0);
                  }

















          3.5.6 Q_CREATE       Function Number: 05

          SYNOPSIS

                  char *q_create(name, mode)
                  char *name;
                  int mode;
                  {
                  }

          DESCRIPTION

               This service call creates a message queue.  A message  queue
               is created by name, and referenced subsequently by its queue
               ID (qid), which is returned to the calling  process  by  the
               q_create  command.  The _name_ argument is a null-terminated
               ASCII string.  The string may be any length,  but  only  the
               first 8 characters are significant, thus the strings

                  o PROCESSFOOBAR

                  and

                  o PROCESSFISH

               will appear the same to the system  (and  would  undoubtedly
               cause  problems  if  used).  The _mode_ parameter determines
               the type of queueing strategy that is being used, where:

                  o a value of 0 indicates a FIFO queue
                    (First In, First Out), and

                  o a non-zero value indicates that the waiting
                    processes should be queued by priority.

               For example, suppose we have three processes, A, B,  and  C,
               which  are  waiting  for  a message in the queue GETMESSAGE.
               Process A has a priority of 100, process B a priority of 50,
               and process C a priority of 25. Next, suppose that process B
               made a queue request  first,  followed  by  process  C,  and
               finally  process A.  How would these requests be serviced by
               the system?

               In the first case, a FIFO style queue, the requests would be
               processed  in  the  order in which they were received.  That
               is, process B, having made the first request, would  be  the
               first  to  receive a message. Process C would be second, and
               process A would be third.

               In the case of a prioritized queue, however, the order would
               be  different,  and  independent  of  the order in which the
               requests were made.
                That is, it is no longer important which process first made
               a request; rather, what is important is the priority of each
               of the requesting processes.  In this case, process A  would
               be  the first to receive a message, since it has the highest
               priority.  Second would be B, and last would be C, since  it
               has the lowest priority.








          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 05      |
                  +-------------------------------+
                  |            name               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            mode               |
                  +-------------------------------+

          RETURN CODE

               The qid (queue ID) of the created queue is a long,  returned
               in register D0.L.

          FRAGMENT

                  {
                          char *q_create();
                          char *id_a_queue;

                          /* Create a queue in FIFO mode */

                          id_a_queue = q_create("MYQUEUE", 0);
                  }







































          3.5.7 Q_DELETE       Function Number: 06

          SYNOPSIS

                  q_delete(qid)
                  char *qid;
                  {
                  }

          DESCRIPTION

               Deletes a previously created message queue.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 06      |
                  +-------------------------------+
                  |            qid                |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain a  0  (zero)  if  the  queue  was
               successfully deleted, otherwise it will be non-zero.

          FRAGMENT

                  {
                          int return_code;
                          char *queue_id;

                          /* Delete a previously created queue */

                          return_code = q_delete(queue_id);
                          if (return_code == 0)
                          {
                                  printf("The queue was deleted ok.");
                          }

























          3.5.8 Q_SEND              Function Number: 07

          SYNOPSIS

                  q_send(qid, msg)
                  char *qid;
                  long *msg;
                  {
                  }

          DESCRIPTION

               This service call allows the caller to send a message to the
               specified  queue.   If  a  process is already waiting at the
               queue, the message is  copied  to  that  process'  indicated
               message buffer.  That process is then made ready-to-run.  If
               there is no process  waiting,  then  the  input  message  is
               copied  to  a system message buffer, which is then posted to
               the queue.  The  number  of  system  buffers  available  for
               messages  is a configuration constant, and may be set.  (See
               Configuring the System).

               The message is fixed  length,  and  consists  of  four  long
               words.   The  first  long  word  contains header information
               which is used by the system.  The remaining three long words
               are available entirely to the user.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 07      |
                  +-------------------------------+
                  |            qid                |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            msg                |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will be zero on a successful send.






















          FRAGMENT

                  {
                          char *queue_id;
                          long sent_message[4];
                          int  msg_return;

                          /* Load the message buffer with data */

                          /* some sort of */
                          /* data...      */
                          sent_message[1] = 100;
                          sent_message[2] = 50;
                          sent_message[3] = 23;
                          msg_return = q_send(queue_id, sent_message);
                          if (msg_return == 0)
                          {
                                   printf("Message sent!");
                          }
                  }














































          3.5.9 Q_REQ               Function Number: 08

          SYNOPSIS

                  q_req(qid, msg, nowait_option, timeout)
                  char *qid;
                  long *msg;
                  int  nowait_option;
                  long timeout;
                  {
                  }

          DESCRIPTION

               This service call allows a process to request and  obtain  a
               message from the specified message event queue.  The calling
               process may specify whether or not it wants to wait for  the
               message.   If  a  message  has been posted to the queue, the
               call will always return immediately to the caller.   If  the
               queue  is empty, and the caller specified a 'no wait' option
               (_nowait_option_ not equal to 0 (zero)), then the Q_REG call
               will  return  immediately  with an information code.  If the
               calling process specified a 'wait'  option  (_nowait_option_
               equal to 0 (zero)), then the calling process will be blocked
               until a message is available to it.   In  addition,  if  the
               timeout  option is used (_timeout_ not equal to 0 (zero)) at
               the same time that the  'wait'  option  is  used,  then  the
               calling  process  will be blocked until it either receives a
               message, or a timeout occurs, whichever comes first.

               The calling process must supply a buffer that is  four  long
               words, in which to receive the message.  The first long word
               is used by the system, and may not be used by the user.  The
               remaining three long words may be used without restrictions.
































          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 08      |
                  +-------------------------------+
                  |             qid               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |             msg               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |        nowait_option          |
                  +-------------------------------+
                  |           timeout             |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               The value returned is a word value, in register  D0.W.   The
               value  indicates  the  status  of the buffer after the q_reg
               call, as follows:

                  Message received successfully           0
                      (Buffer contains valid data)

                  Timeout (when waiting with timeout)    -1
                     (Buffer does not contain valid data)

                  No Message Ready (when using the       -1
                     no-wait option.)
                     (Buffer does not contain valid data)































          3.5.10 Q_JAM               Function Number: 09

          SYNOPSIS

                  q_jam(qid, msg)
                  char *qid;
                  long *msg;
                  {
                  }

          DESCRIPTION

               This service call allows a process to jam a message  at  the
               head  of  the  specified  message  queue.   This  means that
               regardless of what other messages were  there,  the  message
               that  was  jammed  would  be the first one seen by a process
               requesting a message from that queue.  This routine is  used
               mostly  for  system  error  type  messages,  or  in critical
               handlers.  In general, processes tend to  use  Q_SEND.   See
               Q_SEND for more details.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 09      |
                  +-------------------------------+
                  |             qid               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |             msg               |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain a word indicating the  status  of
               the  call.   If  the  word  is  0  (zero), then the call was
               successful.  If the value is non-zero, then the call failed.


























          FRAGMENT

                  {
                          char *queue_id;
                          long buffer[4];
                          int  msg_return;

                          /* Send a message to the message queue, */
                          /* force it to be the first one...      */

                          buffer[1] = 100;   /* some sort of data...*/
                          buffer[2] = 120;
                          buffer[3] = 115;

                          msg_return = q_jam(queue_id, buffer);

                          if (msg_return != 0)
                          {
                              printf("Attempt was unsuccessful.");
                          }
                   }













































          3.5.11 E_SIGNAL       Function Number: 0A

          SYNOPSIS

                  e_signal(pid, event)
                  char *pid;
                  int event;
                  {
                  }

          DESCRIPTION

               This service call allows a process to signal an event  or  a
               group  of  events to another process.  If the target process
               is not in the event-wait condition,  or  if  the  event-wait
               condition  is  not  fully  satisfied by the events signaled,
               then the events are simply  left  pending.   If  the  target
               process  is  in the event-wait condition, and the event-wait
               condition is satisfied by the  signaled  events,  then  that
               process is unblocked and readied for execution (put into the
               ready-to-run state).

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 0A      |
                  +-------------------------------+
                  |             pid               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            event              |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain a value indicating the status  of
               the  call.   A  0  (zero)  indicates  that  the  signal  was
               successfully sent, a non-zero value will indicate  that  the
               signal failed.

























          FRAGMENT

                  {
                          char *proc_id;
                          int  event_return;

                          /* Send some sort of signal here... */
                          event_return = e_signal(proc_id, 0x0013);

                          if (event_return != 0)
                          {
                                  printf("Event signal failed.");
                          }
                  }





















































          3.5.12 E_WAIT              Function Number: 0B

          SYNOPSIS

                  e_wait(event, condition, timeout)
                  int *event;
                  int condition;
                  long timeout;
                  {
                  }

          DESCRIPTION

               This service call allows a process to wait for an event or a
               group  of  events.   There  are seven events specifiable for
               each process.  The caller can stipulate a logical AND  or  a
               logical OR condition on any of the events.  If a logical AND
               is selected (by setting _condition_ to be not equal to  zero
               (0)),  the  call will not return until ALL of the events are
               signaled.   If  a  logical  OR  is  selected   (by   setting
               _condition_  to  be zero (0)), then signaling any ONE of the
               events specified will cause the call to return.

               If the event-wait condition is  satisfied  immediately,  ie,
               all  the  necessary  signals were pending prior to this call
               being made, then the e_wait call  simply  returns,  and  the
               process continues to run.  If all the conditions are NOT met
               immediately, then the calling process is blocked  until  the
               specified  condition  is met.  Normally, the process will be
               blocked forever until the conditions are met.  However,  you
               can also force the process to return after a fixed amount of
               time, regardless of whether or not the events specified were
               signaled.   To  do  this,  you set _timeout_ to be non-zero.
               Now the e_wait call will return when either:

                  o the necessary events specified have been signaled, or

                  o the timeout value has expired




























          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 0B      |
                  +-------------------------------+
                  |            event              |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |          condition            |
                  +-------------------------------+
                  |           timeout             |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain a word which indicates the status
               of  the  16-bit event buffer addressed by _event_, above, as
               follows:

                  o Event condition satisfied -->    0

                  o Timed out (event condition
                    not satisfied)            -->   -1

          FRAGMENT

                  {
                          int event;
                          int return_code;

                          /* wait for two events, with timeout, */
                          /* either event returns...            */

                          event = 0x03;
                          return_code = e_wait(&event, 0, 100L);

                          if (return_code == 0)
                          {
                                  printf("I got event(s) %d", event);
                          }
                          else
                          {
                                  printf("I timed out...");
                          }
                  }


















          3.5.13 P_PAUSE             Function Number: 0C

          SYNOPSIS

                  p_pause(msec)
                  long msec;
                  {
                  }

          DESCRIPTION

               This service call allows the calling process  to  pause  for
               the  specified  interval  in  _msec_.  The pause duration is
               specified in milliseconds.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 0C      |
                  +-------------------------------+
                  |             msec              |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain the word indicating the status of
               the  call.  The status will be 0 if the call was successful,
               non-zero if it was not.  (A non-successful call did not wait
               the specified amount of time).

          FRAGMENT

                  {
                          int return_code;

                          /* wait 100 milliseconds */

                          return_code = p_pause(100L);

                          if(return_code != 0)
                          {
                                  printf("I didn't wait 100 ms...");
                          }
                  }




















          3.5.14 M_ALLOC             Function Number: 0D

          SYNOPSIS

                  char *m_alloc(size)
                  long size;
                  {
                  }

          DESCRIPTION

               The M_ALLOC service call allocates a memory segment  of  the
               specified size to the calling process.  The call returns the
               address of the allocated segment.  Once allocated, a segment
               is  assigned  to  and  owned  by the calling process.  It is
               released back to the memory manager by  an  explicit  M_FREE
               call  (see  M_FREE),  or automatically, upon deletion of the
               owner process.  A first-fit algorithm is  used  for  dynamic
               memory  allocation.   This  means  that  the returned memory
               segment may be exactly the requested size,  or  bigger.   It
               will  not  be  smaller.  A header that is used by the memory
               manager immediately precedes the allocated segment.   It  is
               CRUCIAL that the calling process does not modify this header
               area!  For added security, MICRO RTX buries an  encoded  key
               in the header area, and checks it occasionally.

               For complete compatibility, the GEMDOS  Malloc  function  is
               automatically  translated into the MICRO RTX M_ALLOC service
               call.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 0D      |
                  +-------------------------------+
                  |             size              |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L will contain the  long  word  address  of  the
               allocated  segment.   If there is no segment large enough to
               fill the request, then the long word will contain zero (0).





















          FRAGMENT

                  {
                          char *m_alloc();
                          char *mem_address;

                          /* allocate 1K */

                          mem_address = m_alloc(1024L);

                          if (mem_address == 0)
                          {
                                  printf("ERROR!  Not enough free memory");
                          }
                  }



















































          3.5.15 M_FREE              Function Number: 0E

          SYNOPSIS

                  m_free(segment)
                  char *segment;
                  {
                  }

          DESCRIPTION

               This service call returns (frees) a memory segment currently
               owned  by  the  calling  process  to  the  MICRO  RTX memory
               manager.   The  memory  manager  performs   any   compaction
               possible,  and places the memory block back in the free pool
               for future allocation.  It is  MANDATORY  that  the  segment
               address  specified  is  IDENTICAL  to  that  returned by the
               M_ALLOC call.  In addition, the memory header  (see  M_ALLOC
               for  more  information)  must be completely untouched.  Once
               freed, the segment must not be used again.

               The GEMDOS Mfree function is automatically  translated  into
               the MICRO RTX M_FREE service call.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function code = 0E      |
                  +-------------------------------+
                  |           segment             |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will  be  cleared  (zero)  upon  a  successful
               release  of the memory segment.  A non-zero return indicates
               an error.



























          FRAGMENT

                  {
                          char *mem_address;
                          int return_code;

                          /* Free allocated space, see M_ALLOC */
                          /* for example of allocating space   */

                          return_code = m_free(mem_address);

                          if (return_code != 0)
                          {
                                  printf("Error!  Segment not deallocated!");
                          }
                  }


















































          3.5.16 M_ASSIGN       Function Number: 0F

          SYNOPSIS

                  m_assign(segment, pid)
                  char *segment;
                  char *pid;
                  {
                  }

          DESCRIPTION

               This service call allows a process to transfer ownership  of
               a  memory  segment to another process.  Once reassigned, the
               segment should no longer be used by  the  caller.   As  with
               M_FREE,  it  is mandatory that the segment address specified
               is IDENTICAL to that  returned  by  the  M_ALLOC  call.   In
               addition, the header must be completely untouched.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 0F      |
                  +-------------------------------+
                  |            segment            |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |              pid              |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain  a  word  that  is  zero  if  the
               assignment of the memory segment was successful.  A non-zero
               return value indicates an error.




























          FRAGMENT

                  {
                          char *seg_address;
                          char *proc_id;
                          int  return_value;

                          /* assign our memory segment to someone else */

                          return_value = m_assign(seg_address, proc_id);

                          if(return_value != 0)
                          {
                                  printf("Memory transfer failed");
                          }
                  }


















































          3.5.17 P_LOOKUP       Function Number: 10

          SYNOPSIS

                  char *p_lookup(name)
                  char *name;
                  {
                  }

          DESCRIPTION

               The P_LOOKUP call allows the  calling  process  to  identify
               another  process  by  name, and obtain its Process ID number
               (pid).  The pid may then be used in other references to that
               process.

               Most Micro RTX system calls reference a process by its  pid.
               The  parent  process  obtains  a  child's  pid as the return
               parameter from P_CREATE.  One way  for  other  processes  to
               reference a process is to use P_LOOKUP to translate the name
               into a pid.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 10      |
                  +-------------------------------+
                  |             name              |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L will contain the long word pid  of  the  named
               process, or zero, if no process by that name exists.

          FRAGMENT

                  {
                          char *p_lookup();
                          char *proc_id;

                          /* Get id of proc name FOOBAR */

                          proc_id = p_lookup("FOOBAR");

                          if(proc_id == 0)
                          {
                                  printf("Process FOOBAR not found");
                          }
                  }














          3.5.18 Q_LOOKUP       Function Number: 11

          SYNOPSIS

                  char *q_lookup(name)
                  char *name;
                  {
                  }

          DESCRIPTION

               The Q_LOOKUP call allows the caller to  identify  a  message
               queue  by  name, and obtain its Queue ID (qid).  The qid may
               then be used to refer to that message queue.

               All operations on a message queue require its qid.  Q_LOOKUP
               allows  a  process  which  is not the creator of the message
               queue to translate  a  queue  name  into  a  qid.   Q_LOOKUP
               performs,  in  essence, an 'open' function, i.e.  a run-time
               binding of a declared message queue name to its qid.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 11      |
                  +-------------------------------+
                  |             name              |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L will contain the long word value of the qid of
               the  named  message  queue.   D0.L  will be zero if no queue
               exists with the given name.

          FRAGMENT

                  {
                          char *q_lookup();
                          char *queue_id;

                          /* get id of queue FUMBLE */

                          queue_id = q_lookup("FUMBLE");

                          if(queue_if == 0)
                          {
                                  printf("Queue FUMBLE not found...");
                          }
                  }














          3.5.19 P_INFO              Function Number: 12

          SYNOPSIS

                  char *p_info(pid, state)
                  char *pid;
                  int  *state;
                  {
                  }

          DESCRIPTION

               The  P_INFO  service  call  returns  information  about  the
               specified  process.   The  16  bit buffer address by _state_
               contains the following information:

                          value      bit    status
                          ------------------------
                           32         5  -> Ewait (blocked for event)
                           16         4  -> Qwait (blocked for queue)
                            8         3  -> Paused (blocked for timer)
                            4         2  -> Running
                            2         1  -> Ready
                            1         0  -> Not in Use


          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 12      |
                  +-------------------------------+
                  |              pid              |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |             state             |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L will contain the pid of the process.























          FRAGMENT

                  {
                          char *p_info();
                          char *proc_id;
                          char *return_value;
                          int  state;

                          /* get status of process... */

                          return_value = p_info(proc_id, &state);

                          if(state & 32)
                                  printf("Waiting for an event...");
                          if(state & 16)
                                  printf("Waiting for a queue message");
                          if(state & 8)
                                  printf("Waiting for a timer event");
                          if(state & 4)
                                  printf("Process running...");
                          if(state & 2)
                                  printf("Process ready to run");

                  }










































          3.5.20 P_VECTOR       Function Number: 13

                  char *p_vector(pid, vector)
                  char *pid;
                  char *vector;
                  {
                  }

          DESCRIPTION

               The P_VECTOR  service  call  allows  the  user  to  get  and
               optionally  modify a user-defined 32-bit entry in the PCB of
               a process.  If the vector value given is zero, the entry  in
               the  PCB  is  not effected.  Any non-zero value will set the
               entry to that value.

               This  service  provides  a  mechanism  for  a   user-defined
               extension  to the MICRO RTX PCB.  The contents of this field
               are completely application dependent;  the MICRO RTX  kernel
               never  users  this information directly. All child processes
               inherit their parent's vector as a part of process creation.
               Once  a  process sets its vector, it will not be modified by
               MICRO  RTX,  unless  explicitly  requested  to  by   another
               P_VECTOR call.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 13      |
                  +-------------------------------+
                  |             pid               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            vector             |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.L will contain the old value of the vector entry
               in the PCB.























          FRAGMENT

                  {
                          long p_vector();
                          char *proc_id;
                          long vect_value;

                          /* Read old vector value... */

                          vect_value = p_vector(proc_id, 0L);

                          printf("Vector value is: %ld", vect_value);

                  }




















































          3.5.21 P_SUSPEND      Function Number: 14

                  char *p_suspend(pid);
                  char *pid;
                  {
                  }

          DESCRIPTION

               This service call suspends a process indefinitely,  until  a
               P_RESUME call is made.  A process may suspend itself.

               A suspended process retains all its owned resources.

               A suspended process may be deleted.

               P_SUSPEND should be used with caution.  Suspending a process
               while  it owns a semaphore may cause a dead lock or infinite
               lock-out.

               NOTE: This service call is  not  normally  useful  in  fully
               debugged programs.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 14      |
                  +-------------------------------+
                  |             pid               |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain  a  word  that  is  zero  if  the
               process was successfully suspended.  A non-zero return value
               indicates an error.




























          FRAGMENT

                  {
                          char *proc_id;
                          int return_value;

                          /* suspend the process */

                          return_value = p_suspend(proc_id);

                          /* check the return value */

                          if (return_value != 0)
                                  printf("Cannot suspend process");

                  }


















































          3.5.22 P_RESUME       Function Number: 15

                  char *p_resume(pid);
                  char *pid;
                  {
                  }

          DESCRIPTION

               This service call resumes execution of a suspended process.

               The call simply removes the suspend order. If the process is
               blocked,  P_RESUME  will  have  no immediate effect.  If the
               process is otherwise ready to run,  P_RESUME  allows  it  to
               again compete for the CPU.

               The  caller  will  be  preempted  if  the  resumed   process
               possesses a higher priority than the caller.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 15      |
                  +-------------------------------+
                  |             pid               |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain  a  word  that  is  zero  if  the
               process  was  successfully resumed.  A non-zero return value
               indicates an error.

          FRAGMENT

                  {
                          char *proc_id;
                          int return_value;

                          /* resume the process */

                          return_value = p_resume(proc_id);

                          /* check the return value */

                          if (return_value != 0)
                                  printf("Cannot resume process");

                  }















          3.5.23 D_INSTALL      Function Number: 16

                  d_install(unit, name, constat, conin,
                            conout, costat, cntrl)

                  int unit;               /* the device number */
                  char *name;             /* the device name   */
                  long (*constat)();      /* input status routine */
                  long (*conin)();        /* read character routine */
                  long (*conout)();       /* write character routine */
                  long (*costat)();       /* output status routine */
                  long (*cntrl)();        /* device control routine */
                  {
                  }

          DESCRIPTION

               This service call installs a user-defined device driver. See
               chapter 4 on the Micro RTX I/O Subsystem for more details.















































          3.5.24 D_CNTRL             Function Number: 17

                  d_cntrl(unit, parm)
                  int unit;               /* the device number */
                  char *parm;             /* device dependent data */
                  {
                  }

          DESCRIPTION

               This service call  invokes  the  Micro  RTX  device  control
               mechanism.  See chapter 4 on the Micro RTX I/O Subsystem for
               more details.





















































          3.5.25 Q_INFO              Function Number: 18

                  q_info(qid, proc_q, msg_q);
                  char *qid;
                  int *proc_q;
                  int *msg_q;
                  {
                  }

          DESCRIPTION

               This service call returns the current state of  the  message
               queue.   Specifically, it returns the number of messages and
               processes currently queued at the message queue.  It  should
               be  obvious  that  at most only one of the two queues can be
               non-empty and, therefore, at most only one of the two values
               can be non-zero.

               The proc_q and msg_q  parameters  are  pointers  to  buffers
               large  enough  to  hold  the  16-bit  values returned by the
               Q_INFO function.



          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code = 18      |
                  +-------------------------------+
                  |             qid               |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            proc_q             |
                  +                               +
                  |                               |
                  +-------------------------------+
                  |            msg_q              |
                  +                               +
                  |                               |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will contain  a  word  that  is  zero  if  the
               message queue's state was successfully obtained.  A non-zero
               return value indicates an error (the proc_q and msg_q values
               are not valid).


















          FRAGMENT

                  {
                          char *qid;      /* the queue ID */
                          int proc_q;     /* number of processes queued */
                          int msg_q;      /* number of messages queued */
                          int return_value;

                          /* get the queue's state */

                          return_value = q_info(qid, &proc_q, &msg_q);

                          /* check the return value */

                          if (return_value != 0)
                                  printf("Bad QID");
                          else
                          {
                                  printf("%d processes queued", proc_q);
                                  printf("%d messages queued", msg_q);
                          }
                  }












































          3.5.26 RTX_REMOVE          Function Number: FF

          SYNOPSIS

                  rtx_remove()
                  {
                  }

          DESCRIPTION

               This  service  call  removes  (un-installs)  the  MICRO  RTX
               operating  system  kernel.   No  MICRO  RTX operating system
               kernel services will be available after the  caller  returns
               from this call.

          PARAMETERS

                  +-------------------------------+ Low Memory
                  |       Function Code: FF       |
                  +-------------------------------+

          RETURN CODE

               Register D0.W will be cleared (set to zero) upon  successful
               removal of the MICRO RTX operating system kernel.

          FRAGMENT

                  {
                          int return_value;

                          /* Remove MICRO RTX (why??) */

                          return_value = rtx_remove();

                          if(return_value == 0)
                                  printf("MICRO RTX removed...");

                  }



























          4.
                                      Chapter 4
                               MICRO RTX I/O Subsystem

               This chapter describes several facilities  provided  by  the
          MICRO  RTX  I/O subsystem which are not supported by the standard
          TOS I/O subsystem.

               The services described here are optional  TOS  enhancements;
          they need not be used, and they do not supersede the standard TOS
          or MICRO RTX service calls.

          4.1 Definition of Compatibility

               Ideally, any enhancements to TOS have inherent compatibility
          with  the  standard  TOS.   This  is the primary design goal (and
          limitation) in everything presented here.

               Compatibility, when used in this  chapter,  means  that  the
          enhanced  system  service  supports  every  function  of the non-
          enhanced version in exactly the same manner, and produces exactly
          the same results.

          4.2 Areas of Enhancement

               The multi-tasking facilities  supported  by  the  MICRO  RTX
          kernel  provide  a  means of incorporating multi-tasking services
          into the TOS system.  The enhancements  to  TOS  described  below
          effect  the  system  services provided by the TOS BIOS and GEMDOS
          layers, and in no way effect GEM AES,  VDI  or  the  GEM  Desktop
          directly.

               The GEMDOS layer is the logical candidate for  enhancements,
          since   services   at   this  level  correspond  to  those  of  a
          conventional multi-tasking, time-sharing operating system.

               All MICRO RTX GEMDOS enhancements have function  numbers  in
          the  0x100's.  That  is,  all  the calls have function numbers of
          0x100 and greater.

          4.3 Multi-tasking Process Control

               The standard GEMDOS incorporates the concept of a process in
          a  non-multi-tasking  sense.   The following TOS services perform
          process related functions:

                  o Pexec -- Load/Execute a process

                  o Pterm -- Terminate running process




               The logical progression to  concurrent  processes  falls  in
          nicely as an extension to these existing GEMDOS services.










               The first argument  to  the  Pexec  service  specifies  what
          action the service should perform.  The options are:

                  0 -- load and execute
                  3 -- load, do not execute
                  4 -- begin execution
                  5 -- create basepage


               In all these  cases  the  parent  waits  for  the  child  to
          terminate  before  resuming  execution.   MICRO  RTX  allows  for
          immediate resumption of the parent process, without  waiting  for
          the child process to terminate.  The new Pexec options are:

                  100 -- load and execute in parallel
                  104 -- begin execution in parallel


               In these cases, the return value from the function does  not
          reflect  the  child  termination  code, but rather the success or
          failure of the  child  process  load/creation.   When  a  process
          started  in  this fashion terminates, the value returned with the
          Pterm call is lost.

          4.4 Interprocess Communication

               Interprocess communication enhancements also  fit  naturally
          into  the  File  I/O  services  provided  by GEMDOS.  Since these
          services use file handles to address I/O channels for  both  disk
          files  and  character devices, they are perfectly suited for also
          supporting interprocess I/O channels.

               The  MICRO  RTX  implementation  provides  a  mechanism  for
          creating  an  interprocess  channel, which has associated with it
          two GEMDOS file handles, one for reading and one for writing.

               Once created, these handles may be used like any other  file
          handle;  all the GEMDOS handle related functions are valid.

               The process creating the I/O channel owns the handles.  This
          forces  the  restriction that only a parent process may establish
          interprocess connections.  Here is an example of the technique:

               The parent  process  A  wishes  to  establish  a  connection
          between two children, B and C.  Process A creates an I/O channel,
          getting two new file handles as a result.  Process A then  forces
          its standard output handle to address the write handle of the I/O
          channel.  Process A executes process B  concurrently  (using  the
          Pexec enhancement described in section 6.3).





               The child process B now has its standard  output  addressing
          the  write  handle of the I/O channel.  Next, process A redirects
          its standard output back to normal, and  redirects  its  standard
          input  handle  to the input handle of the I/O channel.  Process A
          then executes process C (with or without waiting).







               This procedure sets up process B to write to process  C  via
          its  standard  output channel.  Likewise, it sets up process C to
          read from process B via its  standard  input  channel.   In  this
          fashion, the I/O redirection is transparent to processes B and C;
          only process A knows what's going on.

               The obvious limitation is that  this  method  only  provides
          one-way fully interlocked synchronization.  The advantage is that
          it is completely compatible with existing GEMDOS  file  I/O,  and
          does not introduce new constructs at that level.

               The new GEMDOS call is function 0x100, and has the following
          form:

                  Popen(fd)
                  int fd[2];
                  {
                  }


               The function returns two GEMDOS file handles to the  caller;
          fd[0]  is  the  read-only  handle,  and  fd[1]  is the write-only
          handle.

          4.5 Installable Device Drivers

               Following the TOS conventions, each  device  has  associated
          with  it  a  device  number and a device name.  The standard ones
          are:

                  Number     Name   Device
                  ------------------------
                    0        PRN    Printer
                    1        AUX    RS-232 channel
                    2        CON    System Console
                    3        MIDI   Midi Port
                    4        KBD    Intelligent Keyboard


               At the BIOS level, devices are referenced by  number.   From
          GEMDOS, devices may be accessed by name.

               The installed device driver must implement  the  four  basic
          I/O  functions;  read  a  character, write a character, check for
          input and check for output.  These  services  correspond  to  the
          BIOS   services   Bconin,   Bconout,   Bconstat,   and   Bcostat,
          respectively.  In addition,  the  device  driver  may  optionally
          support a fifth function implementing device control.

               The installed device may be accessed at the BIOS level using
          its device number, just like any other device in the system.



               The installed device may be 'opened' at the GEMDOS level.











               New devices may be added, or existing ones replaced.

               The device control mechanism  allows  for  device  dependent
          configuration  and  manipulation  via  a standard interface.  The
          form is as follows:

                  d_cntrl(unit, parm)
                  int unit;               /* the device number */
                  char *parm;             /* device dependent data */


               The user supplied device control handler may  interpret  the
          'parm' argument in its own way.

               The device install call has the following form:

                  d_install(unit, name, constat, conin,
                            conout, costat, cntrl)

                  int unit;               /* the device number */
                  char *name;             /* the device name   */
                  long (*constat)();      /* input status routine */
                  long (*conin)();        /* read character routine */
                  long (*conout)();       /* write character routine */
                  long (*costat)();       /* output status routine */
                  long (*cntrl)();        /* device control routine */

          4.6 Determining File Handle Type

               GEMDOS enhanced service function 0x101  returns  information
          on the specified GEMDOS file handle.  The form is:

                  Ftype(handle)
                  int handle;
                  {
                  }


               The function returns the type of file described by the given
          file handle, as follows:

                  0-15 The BIOS device number (e.g., 2 = Console)
                  16   Regular file
                  17   Pipe


          4.7 File and Record Locking

               MICRO RTX implements a single service call, function  number
          0x102,  which  provides  file  and  record  locking.   It has the
          following form:
















                  Flock(fd, flag, offset, length)

                  int fd;         /* File handle */
                  int flag;       /* Flag: lock = 1, unlock = 0 */
                  long offset;    /* Offset of region to be locked */
                  long length;    /* Length of region to be locked */


               This function locks or unlocks the specified region  of  the
          file associated with the given GMEDOS file handle.  The offset is
          relative from the start of the file and the length of the  region
          is specified in bytes.

               If another process attempts to use (read or write) a  locked
          region,  the  read  or  write  fails  with a return value of -133
          (decimal).

               The locked region can be  anywhere  in  the  file.   Locking
          beyond  the  end of the file is not an error.  A region should be
          locked for only a brief period.

               To lock the entire file, an offset of zero and a  length  of
          minus one should be given.

               When unlocking a region, the offset  and  length  parameters
          must be exactly the same as those specified in the previous Flock
          call.

          4.8 DOS Level Device Control

               GEMDOS enhanced service 0x104 may be used to control certain
          characteristics of a terminal device.  It has the following form:

                  Fcntrl(fd, mode)
                  int fd;
                  int mode;

          The mode parameter is a bit vector  defining  the  state  of  the
          specified  file  descriptor  (handle),  with  the  following bits
          defined:

























                                         MSB
             15      14      13      12      11      10       9       8
          |-------|-------|-------|-------|-------|-------|-------|-------|
          | RESVD | RESVD | RESVD | RESVD | RESVD | RESVD | RESVD | RAWIO |
          |-------|-------|-------|-------|-------|-------|-------|-------|

                                         LSB
              7       6       5       4       3       2       1       0
          |-------|-------|-------|-------|-------|-------|-------|-------|
          |NOECHO |CLOSED | PIPE  |  STD  | WRITE | READ  | FILE  |  TTY  |
          |-------|-------|-------|-------|-------|-------|-------|-------|

          Where the bits have the following meanings:

                   Bit    |   File Descriptor is...
                  --------|-----------------------------
                   TTY    | A Terminal
                   FILE   | A File
                   READ   | Opened for reading
                   WRITE  | Opened for writing
                   STD    | A standard handle
                   PIPE   | A pipe
                   CLOSED | Closed
                   NOECHO | In no-echo mode
                   RAWIO  | In RAW I/O mode

          Only the NOECHO and RAWIO modes are writable.   All  other  state
          bits  are  read-only.   Setting a file descriptor to NOECHO mode,
          will force the system not to echo the input for  read  operations
          on  the  specified  handle.   Setting  a file descriptor to RAWIO
          mode, will cause all operations on that handle  to  be  performed
          without any processing of control characters.

               Only the behavior of TTY devices  may  be  altered  in  this
          manner.  Files and pipes are always handled without echo and with
          no control character processing.

               The previous state of the file descriptor is returned by the
          function.

          4.9 Adjusting the TPA Size

               In the standard non-multitasking TOS, the memory for process
          execution  is  called  the  TPA (Transient Program Area).  GEMDOS
          allocates the largest contiguous portion of free memory  for  the
          process,  which  is  normally  all available memory.  The process
          then relocates its stack and calls Mshrink to release  a  portion
          of the TPA memory back to the system.

               There are two cases for potential problems with this  scheme
          in a fully multitasking environment.



               First, if a process fails to release the unused  portion  of
          its  TPA memory, it could consume all the memory resources in the
          system,  and  therefore  memory  allocation  attempts  by   other
          processes  will  fail,  which in turn usually causes processes to
          fail with out-of-memory errors.







               On the other hand, if the process does not  use  the  GEMDOS
          memory  management  calls  to acquire memory from the system, and
          instead assumes that its TPA contains  a  fixed  amount  of  free
          memory  beyond  the end of its Text, Data, and Bss segments, then
          the process will be artificially limited in memory usage  to  the
          size  of  the TPA.  Further, if such a program does not check the
          TPA limits and merely assumes there  is  enough  memory,  it  may
          attempt  to  use memory outside its usable range, which of course
          could have disastrous results.

               MICRO RTX provides a mechanism to avoid the above  problems,
          by allowing the user to set a minimum size for the TPA area.  The
          default TPA size is 64K bytes.  This default is adequate for  all
          normal,    "well-behaved"    programs   meeting   the   following
          requirements:

                  1) The program requires 64K or less of initial stack
                     space.

                  2) The program either A) uses less than 64K of
                     the space beyond the end of its Text, Data,
                     and Bss, or B) it relocates its stack and
                     releases the unused portion of the TPA back
                     to the system.

          The preferred method  is  to  relocate  the  process  stack,  and
          release  the  unused  portion  of  the  TPA  back  to the system,
          subsequently acquiring memory at run-time with Malloc calls. This
          way  regardless  of  the  initial TPA size allocated by the Pexec
          function, optimal memory usage is attained.

               For programs that fail to release the unused portion of  the
          TPA,  the  TPA size may be reduced to the actual amount of memory
          required by the process.   This  leaves  more  memory  for  other
          processes to use.

               Likewise, the  TPA  size  may  be  increased  to  accomadate
          programs that expect a large TPA instead of acquiring memory from
          the system.

               The GEMDOS enhanced system service 0x103 sets the  TPA  size
          for  all  subsequent  Pexec  service  calls.  The  call  has  the
          following form:

                  long Psettpa(size)
                  long size;

          The previous TPA size is returned so that it may be restored with
          another  call  to  Psettpa.   The  new TPA size remains in effect
          until another Psettpa call changes it.




               An input value of -1 (0xffffffff) obtains  the  current  TPA
          size without modifying it.

          4.10 MICRO RTX I/O Subsystem Enhancements Summary








               The following table lists the enhancements to  the  services
          provided by the MICRO RTX I/O Subsystem.

          Name         System Layer        Function Code
          ----------------------------------------------
          Popen        GEMDOS Trap #1         0x100
          Ftype        GEMDOS Trap #1         0x101
          Flock        GEMDOS Trap #1         0x102
          Psettpa      GEMDOS Trap #1         0x103
          Fcntrl       GEMDOS Trap #1         0x104

          d_install    RTX Trap #5            0x16
          d_cntrl      RTX Trap #5            0x17






















































          5.
                                      Chapter 5
                               Building An Application



               A MICRO RTX application always  consists  of  at  least  one
          process -- the root process.   All other processes are created by
          the root process, or one of its offspring.

               The root process is the  GEMDOS  application  that  installs
          MICRO RTX.  The root is often a shell program which interactively
          creates and executes sub-processes.  For example, the MT  C-Shell
          (which  is  a  Unix-like  Multitasking  OS  for  the Atari ST) is
          actually a MICRO RTX  application.  All  of  the  multiprocessing
          capabilities  of  the MT C-Shell are inherited from (and provided
          by) the MICRO RTX kernel.

               MICRO RTX uses a model of a process in which the process may
          consist of up to five types of memory segments.  For the Atari ST
          system, a segment is a physically contiguous section  of  memory.
          The five segment types are:

               o A text (or code) segment contains a process' instructions.

               o A constant segment contains all compile-time constants.

               o A stack segment is assigned by the kernel as part  of  the
          creation  of  a  new process;  a stack is of fixed size (that is,
          once allocated, it cannot be grown).

               o A process data segment provides the data storage  location
          known at compile time.  A static data segment need not be present
          in a process. Processes that share a  common  text  segment,  for
          example, must have dynamically allocated (heap) data segments.

               o The last segment type, the heap, is  acquired  dynamically
          by  the  issuance  of  MICRO RTX M_ALLOC or GEMDOS Malloc service
          calls.  A segment so allocated may be used as a  text,  constant,
          stack or data segment.

               Processes may share a common, reentrant  text  segment.   In
          this case, the text segment must, of course, be pure (code);  and
          the static, compile-time variable storage  must  be  acquired  at
          run-time.   Local  automatic  storage, as usual, may be allocated
          and deallocated on the stack.

               The  current  implementation  of  MICRO  RTX  supports  only
          memory-resident  processes.   An  activated process must have all
          its segments in memory at  all  times,  whether  the  process  is
          running or not.

          5.1 The Configuration Table

               The MICRO  RTX  system  configuration  is  controlled  by  a
          passive  set of declarations maintained in a configuration table.
          This table contains all the application  and  hardware  dependent
          parameters which the MICRO RTX kernel needs to know about.







               The table data structure consists of  7  entries,  as  shown
          below.

                  struct config {
                          char *basepage;
                          int  max_proc;
                          int  max_msgs;
                          int  max_queues;
                          int  (*create_call)();
                          int  (*delete_call)();
                          int  (*switch_call)();
                  };


          5.1.1 Basepage

               This entry must contain the address of the  GEMDOS  basepage
          of  the root process.  The basepage is passed on the stack to the
          root process by the Pexec() function.

               For C programs using the Alcyon  compiler  from  Atari,  the
          basepage  address is stored in the global variable "_base" by the
          startup module GEMSTART.S.

               Assembly language programs can access the  basepage  address
          by  accessing  the  longword  at  offset  4(sp) upon entry to the
          startup module.

          5.1.2 Max_proc, Max_msgs, Max_queues

               These entries specify the following:

                  o Max_proc:  Maximum number of concurrently active
                               process allowed in the system.

                  o Max_msgs:  Maximum number of system message
                               buffers.

                  o Max_queues: Maximum number of concurrently active
                                message queues.


               Processes, queues and message buffers all require memory for
          their  control  structures.   These constants are the only static
          data necessary for the MICRO RTX kernel.  They specify the amount
          of  memory  the  kernel must reserve for itself at initialization
          time.

               MICRO RTX does NOT allow dynamic  growth  (ie,  increase  in
          size)  of  these maximum values during run time.  If any of these
          values are exceeded, the  corresponding  kernel  service  call(s)
          will fail.


               The limitations imposed by the maximum number  of  processes
          and  the  maximum  number  of message queues are straightforward.
          When either of these limits is reached, no more  processes/queues
          may be created until one is deleted.








               The limitations imposed by  the  maximum  number  of  system
          message   buffers   is  somewhat  more  complicated.   As  stated
          elsewhere, each message buffer is four  long  words  big.   If  a
          process  sends  a message to a queue where no process is waiting,
          the message must be copied to a message buffer obtained from  the
          pool  of  available  system  message  buffers.   If  that pool is
          exhausted (there are no more system message  buffers  available),
          then  the  message cannot be posted, and an error message will be
          sent to the sending process.   This  is  one  reason  why  it  is
          important  to  check  the return code from a "send message" call.
          If such an error message is received by the calling process,  the
          calling  process can choose to buffer the message on its own, and
          try sending the message again later, or it can choose to  discard
          the message.

          5.1.3 Create_call, Delete_call, Switch_call

               These  entries  supply   the   addresses   of   user-defined
          procedures,  which  are  called  during process creation, process
          deletion and  process  switching  (re-scheduling),  respectively.
          These  kernel 'hooks' allow a user to perform special application
          dependent tasks at these critical points in the normal  operation
          of the kernel.

               Null addresses may  be  used  in  any  of  these  spaces  to
          indicate  to the kernel that no such call out routine is used (or
          needed).

               The  following  conventions  must   be   observed   in   the
          implementation of the various callout procedures:

          1.  All  registers  must  be  preserved  through  the  call,  and
              restored upon return.

          2.  The stack must be balanced upon return.

          3.  Upon  entry,  the  CPU  is  in  supervisor  mode.   The  user
              procedure  must  not  at  any time cause the CPU to exit this
              state.

          4.  Upon entry, the hardware mask level is set to  7.   The  user
              procedure must not change the mask level.

          5.  CREATE_CALL is called  after  the  target  process  has  been
              entered  onto  the  ready-list,  but  before any of its state
              information has been loaded. Upon entry,  A0  points  at  the
              process control block (PCB) of the target process.

          6.  DELETE_CALL is called  after  the  target  process  has  been
              returned  to the free list, all its memory segments have been
              reclaimed, and all its open handles have been  closed.   Upon
              entry,  A0  points  at the process control block (PCB) of the
              target process.


          7.  SWITCH_CALL is called after the  state  of  the  old  running
              process  has  been  completely saved, and before the state of
              the new process to be run is loaded.  Upon entry,  A0  points
              at  the  process  control  block  (PCB)  of  the  OLD running
              process, and A6 points at the PCB of the new  process  to  be






              run.


































































          6.  Appendix A: Selected Readings

          The C Programming Language
                  by Brain W. Kernighan and Dennis M. Ritchie
                  Prentice-Hall Publishing Company

          Programming the 68000
                  by Steve Williams
                  Sybex, Inc.

          GEM AES and VDI Programmers Reference
                  available from Atari, Corp (as part
                  of the developer's pack), or directly
                  from Digital Research, Inc.

          HitchHiker's Guide to the BIOS
                  part of the Atari Developer's package

          MICRO C-Shell and MT C-Shell user's manuals
                  available (with the products) from
                  Beckemeyer Development Tools

          Operating Systems - An Advanced Course
                  Bayer, R., R. M. Graham, and G. Seegmuller
                  1978, Springer-Verlag, Berlin

          Concurrent Programming Concepts
                  Brinch Hansen, P.
                  Dec. 1973, Computing Surveys, 5(4) 223-245

          The Architecture of Concurrent Programs
                  Brinch Hansen, P.
                  1977, Prentice-Hall, Englewood Cliffs, NJ

          Prevention of System Deadlocks
                  Habbermann, A. N.
                  Jul. 1969, Communications of the ACM
                  12(7) 373-377 and 385

          Synchronization of Communicating Process
                  Habbermann, A. N.
                  Mar. 1972, Communications of the ACM, 15(3) 171-176

          Cooperating Sequential Processes
                  Dijkstra, E. W.
                  Technical Report EWD-123
                  Technological University, Eindhoven, The Netherlands

          Solution of a Problem in Concurrent Programming Control
                  Dijkstra, E. W.
                  Sep. 1965, Communications of the ACM, 8(9), 569








