



DEEP - Manual.


    Version 0.91



    Christian Hoofe

      Solmsstr.8

    1000 Berlin 61

    West Germany



     July 14, 1991




Contents



1  Introduction                                                           4



2  Examples                                                               6

   2.1  A difference equation system   : : : : : : : : : : : :  : : : :   6

        2.1.1 Progam flow of the economic model   : : : : : : : : : : :   8

        2.1.2 The variables of the model   : : : : : : : : : : : : : : :  8

        2.1.3 Preprocessor statements  : : : : : : : : : : : : : : : : :  9

        2.1.4 The assumptions of the model   : : : : : : : : : : : : : :  9

   2.2  A differential equation system   : : : : : : : : : : : : : : : :  10

        2.2.1 Progam flow of the RABBIT-LYNX Model   : : : : : : : : : :  12

        2.2.2 The variables of the model   : : : : : : : : : : : : : : :  13

        2.2.3 The assumptions of the model   : : : : : : : : : : : : : :  13

        2.2.4 Problems with differential equations  : : : : : : : : :  :  14

   2.3  Exact solution example   : : : : : : : : : : : : : : : : : : : :  16

        2.3.1 The assumptions of the model   : : : : : : : : : : : : :    18



3  DEEP C                                                                 20

   3.1  C standard features   : : : : : : : : : : : : : : : : : : : : : : 20

        3.1.1 Declarations : : : : : : : : : : : : : : : : : : : : : : :  20

        3.1.2 Data Types  : : : : : : : : : : : : : : : : : : : : : : :   21

        3.1.3 Expressions  : : : : : : : : : : : : : : : : : : : : : : :  21



                                  1




     3.1.4 Constants  : : : : : : : : : : : : : : : : : : : : : : : : :  22

     3.1.5 Operators  : : : : : : : : : : : : : : : : : : : : : : : : :  22

     3.1.6 Statements  : : : : : : : : : : : : : : : : : : : : : : : :   24

     3.1.7 Preprocessor Dircetives   : : : : : : : : : : : : : : : : :   24

3.2  Standard library functions  : : : : : : : : : : : : : : : : : : : : 24

     3.2.1 Mathematical functions  : : : : : : : : : : : : : : : : :     25

     3.2.2 Input/Output functions  : : : : : : : : : : : : : : : : :     25

     3.2.3 Other functions  : : : : : : : : : : : : : : : : : : : : : :  25

3.3  Simulation features  : : : : : : : : : : : : : : : : : : : : : : :  25

     3.3.1 Simulation variables  : : : : : : : : : : : : : : : : : : :   25

     3.3.2 Simulation functions and operators  : : : : : : : : : : :     28

     3.3.3 The simulation memory  : : : : : : : : : : : : : : : : :      29



                               2




List  of  Tables



   2.1  Results of program EX_EXACT.C  : : : : : : : : : : : : : : :     19



   3.1  Data types and sizes  : : : : : : : : : : : : : : : : : : : : :  21

   3.2  Operators in precedence order : : : : : : : : : : : : : : : : :  23

   3.3  Standard mathematical functions  : : : : : : : : : : : : : : : : 26

   3.4  Input and Output functions  : : : : : : : : : : : : : : : : : :  27

   3.5  Other functions  : : : : : : : : : : : : : : : : : : : : : : : : 28



                                  3




Chapter  1



Introduction



                Welcome to the DEEP World.



DEEP ^1 is a program designed to calculate difference and differential equa-
tion systems with a C interpreter on the ATARI ST/TT. In an intergrated
development enviroment it is possible to edit equation systems, execute the
code and display the results either in text or graphical form.  The Runge-
Kutta integration methods of 2nd and 4th order are supported.

DEEP supports a subset of the C language.  You can use it to write C
programs. The program is not designed to be a perfect C interpreter. You
can buy very fast and cheap ANSI C compilers or interpreters. If you want
to learn a programming language take one of them.  DEEP will only be
interesting for you if want to make investigations in simulation.  I have
developed DEEP to have a tool for simulation programming and I hope
that it might also be useful for your simulation purposes.

DEEP is based on the C interpreter described in Peter A. Darnell's and
Philip E. Margolis' "C: A Software Engineering Approach" [1]. I have added
the preprocessor, the development enviroment and some special simulation
features to it.
____________________________
1   Difference Equation Exploration Package



                                  4




DEEP is written in C. Altough C is a fast language when it is used to build
a C interpreter it gets slow. The interpreter is more than a hundered times
slower than a normal C program. DEEP should only be used for small size
simulation programs.

If you use DEEP always remember that I have tried to do my best but in
a program with 15000 lines of source code there will be errors and you will
find them. You can contact me via the titel page address.

The program was designed for the simulation of economic models. It's up
to you to simulate other things with the program.

Simulation in social science is based on time series and feedback loops. So
you have to understand this components to build a simulation model ([3]
gives a good introduction to simulation).  Some example programs show
you how to do simulations with DEEP. A simulation run produces only
numbers - nothing else. You create a model and the computer calculates the
numbers for you. You can test your model, change parameters or equations
and look at the output.  There is always a little bit of trial and error in
simulation programming ^2 and DEEP can help you to get experienced with
the simulation approach.

I believe simulation can help us - at best - to understand some aspects of
the real world. Therefor join the simulation community. You are welcome.

But you are not welcome if you work in the military sector.  The military
use of this software is strictly forbidden.  I have tried to be constructive
and I am not willing to support destructive people.  Including all modern
Frankensteins like atomic and genetic engineers.



____________________________
2   One of the astonishing things of simulation is that you need only a few 
    equations to get unpredictable results.



                                  5




Chapter  2



Examples



2.1    A difference equation system



     1  /* =======================================================
     2      Modul:   EX_ECONO.C
     3               A simple multiplier-accelerator model.
     4      Author:  Ch. Hoofe
     5      Source:  A. Stobbe Volkswirtschaftslehre III  p. 107
     6      Version: 1.0  29.6.91
     7     ====================================================== */
     8  #define SIM_END 41
     9
    10  long            length;
    11  long            t;
    12
    13                    /* simulation variables declaration */
    14  double I[SIM_END];    /* investment */
    15  double C[SIM_END];    /* consumption */
    16  double Y[SIM_END];    /* national income */
    17
    18                   /* global variables */
    19  int C_aut;           /* autonomous consumption */
    20  int G_aut;           /* autonomous government expenditures */
    21  /* =======================================================
    22       Function:       initialization()
    23
    24       Parameter:      void
    25       Return:         void



                                  6




26     ======================================================= */
27  void initialization(void)
28  {
29          length=SIM_END;
30          t=1;
31
32          I[0] = 0;
33          C_aut = 30;
34          C[0] = C_aut + 400;
35          G_aut = 70;
36          Y[0] = I[0]+C[0]+G_aut;
37
38                        /* after period 0 increase */
39          G_aut = 90;  /* goverment expenditures */
40  }
41
42                       /* parameter */
43  #define C_QUOTE 0.8        /* marginal propensity to comsume */
44  #define ACCELERATOR 1
45  /* =======================================================
46       Function:       simulation()
47
48       Parameter:      void
49       Return:         void
50     ======================================================= */
51  void simulation(void)
52  {
53          C[t] = C_aut + C_QUOTE * Y[t-1];
54          I[t] = ACCELERATOR * (C[t]-C[t-1]);
55          Y[t] = I[t] + C[t] + C_aut + G_aut;
56  }
57  /* =======================================================
58       Function:       main()
59
60       Parameter:      void
61       Return:         void
62     ======================================================= */
63  void main(void)
64  {
65
66                            /* initialization */
67          initialization();
68                           /* simulation call */
69          simulation();



                              7




    70
    71  }
    72



2.1.1   Progam flow of the economic model


Like every normal C program a DEEP program starts at the main() func-
tion.  The lines are always executed in their sequential order from top to
the bottom. In main() the initialization() function is called where the
variables are set to their initial values.  Subsequently the simulation()
function is called. This function has a special meaning in DEEP. Depending
on the variables length (declared in line 10 of the example) and t (declared
in line 11) the simulation() function will be repeatedly called.

In the example the initial value of t is 1 and the value of length is 41.
This means that the simulation() function will be called 40 times. In the
simulation() function t is used as the index for the C, I and Y arrays which
store the results of the simulation run. These arrays also give the program
excess to the results of a former time period.



2.1.2   The variables of the model


The two variables length and t are used to control the simulation run.
Their function is explained in the previous section. They have a global scope,
which means that they can be accessed from every part of the program. The
declaration of these variables is not imperative. DEEP will always declare
these variables because they are necessary for the simulation and integration
functions.  There are two other internal variables dt and T which are not
used in our example. Nevertheless if you look at the global variables after a
simulation run you will find these variables.

In line 14-16 the arrays for the storage of the simulation results are declared.
They all have the type double because the results of the program need a
floating point representation.

Afterwards (line 19-10) two global variables are declared. The variable C_aut
is initialized in the initialization function and not changed during pro-
gram execution. Therefore it could be replaced by a preprocessor statement
(see next section).



                                  8




2.1.3   Preprocessor statements


A preprocessor line always begins with a # sign.  The preprocessor scans
through the source code and makes text replacements.  There are several
preprocessor commands of which only the #define statement is used in the
example.



    43  #define C_QUOTE 0.8



This line will cause the preprocessor to replace every appearence of C_QUOTE
in the source code with 0.8. This has the advantage that if C_QUOTE appears
several times in the source code and you want to change the value 0.8, you
have only to edit line 43. There is also another advantage, you can make a
parameter readable.

It is a convention to write preprocessor identifiers with upper case letters
to distinct them from variables.  This is useful to avoid variable names or
parts of variables names are replaced by a preprocessor statement. This can
cause errors which are difficult to find.



2.1.4   The assumptions of the model


The example shows a very simple macroeconomic model which I have taken
from a book for undergraduate students.



            Ct  =  Ca + cYt1           (2.1)    Ca > 0; 0 < c < 1

            It  =  beta(Ct-Ct1 )       (2.2)             beta > 0

            Yt  =  Ct+ It+ Ga:         (2.3)



The consumption (2.1) is based on the autonomous Ca consumption plus a
part c of the previous income. For simplicity's sake it is assumed that the
disposable income is equal to the national income (Y ).



    53          C[t] = C_aut + C_QUOTE * Y[t-1];



The investment (2.2) depends on the diffrence between the consumption of
the actual and the previous period.  The result is multiplicated by beta, 
the accelerator which is set in this example to 1.



                                  9




    54          I[t] = ACCELERATOR * (C[t]-C[t-1]);



The last equation (2.3) describes the equilibrium condition of the model.



    55          Y[t] = I[t] + C[t] + C_aut + G_aut;



2.2    A differential equation system



The program shows a implementation of the RABBIT-LYNX Model. In a
simple model the birth and death rates of rabbits and lynxs are calculated.
Besides the simulation of a predator-prey relationship the example can show
same of the weaknesses of the underlying model. Changing the parameters
slightly can cause unstable results.  Also the used integration method is
important for a correct result.



     1  /* =====================================================
     2       Modul:   EX_LYNX.C
     3                Rabbit model.
     4       Author:  Ch. Hoofe
     5       Source:  H. Rauch Modelle der Wirklichkeit S. 41 ff
     6       Version: 1.0  20.4.91
     7     ===================================================== */
     8  #define SIM_END 61
     9                          /* global simulation variables */
    10  long            length;
    11  long            t;
    12  double          dt;
    13
    14                         /* simulation variables declaration */
    15  double Rabbit[SIM_END];
    16  double Lynx[SIM_END];
    17
    18                         /* global variables */
    19
    20                         /* parameter */
    21  #define BIRTH_RATE_RABBIT       0.50    /* birth rate rabbits   */
    22  #define DEATH_RATE_LYNX         0.25    /* death rate lynx      */
    23  #define RABBITxLYNX             0.05    /* death rate Rabbit meets
                                                   lynx */
    24  #define LYNXxRABBIT             0.01    /* birth rate Lynx meets



                                 10




25
26  /* =====================================================
27       Function:       initialization()
28
29       Parameter:      void
30       Return:         void
31     ===================================================== */
32  void initialization(void)
33  {
34          length = SIM_END;
35          t = 1;
36          dt = 0.25;
37
38          Rabbit[0]=20;
39          Lynx[0]=7;
40  }
41  /* =====================================================
42       Function:       integration_rk4()
43
44       Parameter:      void
45       Return:         void
46     ===================================================== */
47  void integration_rk4(void)
48  {
49          double mult = Rabbit[t] * Lynx[t];
50          double R_birth,R_death,L_birth,L_death;
51
52          R_birth = BIRTH_RATE_RABBIT * Rabbit[t];
53          R_death = RABBITxLYNX * mult;
54          L_birth = LYNXxRABBIT * mult;
55          L_death = DEATH_RATE_LYNX * Lynx[t];
56
57          Lynx[t]    ~= L_birth - L_death;
58          Rabbit[t]  ~= R_birth - R_death;
59  }
60  /* =====================================================
61       Function:       simulation()
62
63       Parameter:      void
64       Return:         void
65     ===================================================== */
66  void simulation(void)
67  {
68



                             11




    69          Rabbit[t]=Rabbit[t-1];
    70          Lynx[t]=Lynx[t-1];
    71
    72          integration_rk4();
    73
    74          if(Rabbit[t]<0 __ Lynx[t]<0)
    75                   exit();
    76  }
    77  /* =======================================================
    78       Function:       main()
    79
    80       Parameter:      void
    81        Return:         void
    82     ======================================================= */
    83  void main(void)
    84  {
    85
    86                            /* initialization */
    87          initialization();
    88                            /* simulation call */
    89          simulation();
    90
    91  }



2.2.1   Progam flow of the RABBIT-LYNX Model


In the example the initial value of t is 1 and the value of length is 61. This
means that the simulation() function will be called 60 times.

In the simulation() function t is used as the index for the Rabbit and Lynx
arrays. If we only calculate difference models all calculating will happen on
this level. Because a population can not be negative a statement is added to
test if one of the example populations is negative. In this case the simulation
run is aborted with the exit() function.

In the example we use a Runge-Kunge integration method of 4th order to
calculate the results. Therefore a additional function call is necessary. With
the integration_rk4() call this is done.  Before that call the integration
variables will be set to the value of the last time step (line 69 and 70). This
is necessary because the integration will be performed on the actual time
step. In the integration_rk4() function only the actual time step t will
be used.



                                 12




In the integration_rk4() function the rates will be calculated first and
then the special assignment type '"=' is used. This is the only valid combina-
tion to calculate differential equations. Instead of integration_rk4() you
can use integration_rk2() which means you use an integration method of
2nd order with less correctness but a quicker execution speed. You can also
speed up things if you chose a higher dt for example 0.5 or 1. The results
will be less precise.



2.2.2   The variables of the model


The three variables length,t,dt are used to control the simulation run.
The function of these variables were explained earlier. They have a global
scope which means that they can be accessed from every part of the program.

The variables Rabbit[61] and Lynx[61] contain the results of the simula-
tion run. The variable t holds the index (=time step) to these arrays.

Besides the global variables there are also local variables in the example pro-
gram.  R_birth,R_death,L_birth,L_death and mult are local variables.
Local variables exists only within the function they are declared. If such a
function is called the space for these variables is allocated and after return
from that function call it is given back to the system. With the use of local
variables you can save core space. If a variable is declared twice global and
local DEEP like C always refers to the local variable.

Normally all variables in C are written in lower case. To distinct simulation
variables from all other variables its' first sign is written in upper case.



2.2.3   The assumptions of the model


In the world of this simple model there are two species of animals.

The birth rate of the rabbits depends on the number of existing rabbits.



    52          R_birth = BIRTH_RATE_RABBIT * Rabbit[t];



The death rate of the rabbits depends on the number of meetings (not
friendly) between rabbits and lynxs.



    53          R_death = RABBITxLYNX * mult;



                                 13




What is bad for a rabbit is good for a lynx so the birth rate of the lynxs
depends on the number of meetings between lynxs and rabbits.



    54          L_birth = LYNXxRABBIT * mult;



The death rate of lynxs depends on a fixed factor.



    55          L_death = DEATH_RATE_LYNX * Lynx[t];



In every time step the rates are integrated with the help of a 4th order
Runge-Kutta integration method.  In DEEP this is done with the special
assignment type '"=' in the special function integration_rk4.



    57          Lynx[t]    ~= L_birth - L_death;
    58          Rabbit[t]  ~= R_birth - R_death;



Such systems are called VOLTERRA system after Vito Volterra (1860 -
1940) who described them first. In a mathematical symbolization this is :



                         y'1=   ay1  by1y2                       (2.4)

                         y'2=   -cY2 + dy1y2                      (2.5)



y1 represents the rabbits in our example and y2 is equal to the lynxs. The
parameters are equal to the following parameters of the example program.



                           a  :=  R_birth

                           b  :=  R_death

                           c  :=  L_death

                           d  :=  L_birth



2.2.4   Problems with differential equations


One might think it should be possible to rewrite the example program to a
version which looks like the original VOLTERRA equation system.



                                 14




        /* incorrect version of the VOLTERRA system */
        void integration_rk4(void)
        {
                Lynx[t]   ~= LYNXxRABBIT * Rabbit[t] * Lynx[t] -
                             DEATH_RATE_LYNX * Lynx[t];
                Rabbit[t]  ~= BIRTH_RATE_RABBIT * Rabbit[t] -
                              RABBITxLYNX * Rabbit[t] * Lynx[t];
        }



But this program will cause different results from our example program. The
difference is caused by the intergration method which is hidden behind the
'~=' operator.  With a Runge-Kutta integration method of 4th order this
equation will be calculated 4 times each step.^1 The right side of the equation
Lynx[t] is calculated and the result is assigned to Lynx[t].  Afterwards
the Rabbit[t] equation is calculated now using the results of the Lynx[t]
equation. This will cause mistakes because the Rabbit[t] equation needs
the Lynx[t] value of the actual period and not the new calculated value.^2

If you use the capability of DEEP to calculate differential follow these rules:



   - Set the value of the actual simulation variable to value of the pre-
     vious period (Rabbit[t]=Rabbit[t-1]).  This must be done before the
     integration function is called.


   - You get wrong results if a variable appears on the right side of an
     integration assignment '~=' which also appears in an integration as-
     signment on the left side. This variable has to be calculated first and
     the result (with the help of a temporary variable) can be written on
     the right side of an integration assignment.


   - If you want to use the time period in an equation you must use T
     instead of t. The variable t must be used for array subscripts.
____________________________
1  Step in this context depends on value of dt and not only on t (See 3.3.1 on 
   page 25).
2  The '~=' assignments resemble assignment operations in a derivative function
   (For example see [4] page 572). It is a problem for the interpreter that it does not
   know how many '~=' assignment operations will follow the actual one which makes it 
   difficult to save the result temporarly.  Therefore the results are written back 
   immediately to the variable on the left side. In terms of Dynamo the first equations 
   of a integration function are the rate and auxiliary equations. Afterwards the levels 
   are calculated which are equal to '~=' assignments.



                                 15




   - Set dt to a value between 0 and 1.  dt determinate how many steps
     will be calculated between one step of t.  The formula 1/dt is used for
     this calculation.



2.3    Exact solution example



The results of the calculation of a differential equation system are allways
an approximation to the real result.  The next example shows a program
which calculates an equation for which the correct results are known.



     1  /* =======================================================
     2       Modul:  EX_EXACT.C
     3               Example of a differential equation with an
     4               exact solution
     5       Author: Ch. Hoofe
     6       Source:
     7       Version:        1.0  22.6.91
     8     ======================================================== */
     9  #define SIM_END 6
    10                          /* global simulation variables */
    11  long            length;
    12  long            t;
    13  double  dt;
    14
    15                          /* simulation variables declaration */
    16  double Y[SIM_END];
    17  double Y_exact[SIM_END];
    18
    19                           /* global variables */
    20
    21                           /* parameter */
    22
    23  /* ========================================================
    24          Function:       initialization()
    25
    26          Parameter:      void
    27          Return:         void
    28     ======================================================= */
    29  void initialization(void)
    30  {
    31          length=SIM_END;



                                 16




32          t=1;
33          dt=0.2;
34
35          Y[0]=1;
36          Y_exact[0] = exp(0.0);
37  }
38
39  /* =======================================================
40       Function:       integration_rk4()
41
42       Parameter:      void
43       Return:         void
44     ======================================================= */
45  void integration_rk4(void)
46  {
47          double tmp1;
48
49          tmp1 = Y[t] * T;
50          /*printf(""nt: %ld T:%f tmp1: %f",t,T,tmp1);*/
51
52          Y[t] ~= tmp1;
53  }
54  /* =======================================================
55       Function:       simulation()
56
57       Parameter:      void
58       Return:         void
59     ======================================================= */
60  void simulation(void)
61  {
62
63          Y[t]=Y[t-1];
64                             /* calculate the exact solution */
65          Y_exact[t] = exp(pow(t,2)/2);
66
67          integration_rk4();
68
69  }
70  /* =======================================================
71          Function:       main()
72
73          Parameter:      void
74          Return:         void
75     ======================================================== */



                             17




    76  void main(void)
    77  {
    78
    79                            /* initialization */
    80          initialization();
    81                            /* simulation call */
    82          simulation();
    83
    84  }
    85



2.3.1   The assumptions of the model


The example is based on the differential equation:



                             y'= f(x,y)                         (2:6)


For this differential equation is an exact solution:



                                     x2
                             y = exp(___)                        (2:7)
                                      2

In the the simulation() function this equation is used to calculate the exact
result. Table 2.1 on page 19 shows the results.

This examples shows that the error grows exponentialy.  If you chose a
higher value for dt or if you take the other integration method the result
gets worse. You must always be aware that the integration method is only
an approximation to the exact result.  Because a lower dt slows down the
execution time the best approach is to chose a high dt (=1) in the beginning
to have quick results. Later you can run a simulation with a lower dt to be
sure to have made a usable model.



                                 18




          _____________________________________________
         |                                             |
         |                   Results                   |
         |____________________________________________ |
         |_time_period_|program_result_|_exact_result__|
         |---------------------------------------------|
         |______0______|_____1.000000__|_____1.000000__|
         |______1______|_____1.648717__|_____1.648721__|
         |______2______|_____7.388225__|_____7.389056__|
         |______3______|____89.920441__|____90.017131__|
         |______4______|__2965.461199__|__2980.957987__|
         |______5______|263739.714037__|268337.286521__|
          ---------------------------------------------
             Table 2.1: Results of program EX_EXACT.C



                     19




Chapter  3



DEEP  C



DEEP is a simulation interpreter with a subset of the C commando set.
This chapter describes the C standard and special features of DEEP.



3.1    C standard features



3.1.1   Declarations


Variables up to 31 characters are supported. The first character of a variable
must be an alpha sign. Besides the '_' sign can be used as the first character
of a variable.

Variables declared outside of a function have program scope. These global
variables can be accessed from different source files. Global variables ini-
tialized to null values.

All other variables have either function or block scope they are active inside
the function or block they are declared. After leaving the function or block
there live ends. These local variables are not initialized so that their value
is undefined.

Global variables must be declared before the first function declaration. Local
variables must be declared before the statements of a function or a block.

If a function call appears before it's function declaration, a warning message
will appear.  This message can be ignored.  To suppress this message it is
necessary to reorder the program so that the function declarations are put
before there function calls. Not declared functions will be found at run time.



                                 20




                       _________________________
                      |                         |
                      |        Data types       |
                      |_________________________|
                      |_type_____|length_(byte)_|
                      |-------------------------|
                      | void     |______________|
                      | char     |______1_______|
                      | short    |______1_______|
                      | int      |______2_______|
                      | long     |______4_______|
                      | pointers |______4_______|
                      | float    |______10______|
                      | double   |______10______|
                       -------------------------
                      
                    Table 3.1: Data types and sizes



3.1.2   Data Types


The Table 3.1 contains the data types and its' storage amount on the Atari.

Arrays are also supported.  The void data type is only useful for function
declarations. The float data type is only added for C compability. Whenever
possible the use of the double type is recommended.^1 The size of the data
type char is always rounded up to even size. This means that a char variable
needs 2 bytes space.  This is necessary because the Motorola 68000 chip
requires even adress boundaries. The same is done with an array of char if
the length of it is not even.

typedef,structures,unions, and enums are not supported.

Always be carefull when you use pointers.  False use of pointers
can crash the system.



3.1.3   Expressions


Precedence rules and conversion rules are as described by ANSI Standard.
____________________________
1  As you can see from the table 3.1 there is no difference between float and 
   double in the internal reprensentation



                                 21




3.1.4   Constants


Fixed and floating-point constants are allowed as specified by the ANSI
Standard. Double-quoted strings and single-quoted characters are allowed.



3.1.5   Operators


For the type double and long, the following C expression operators are sup-
ported:

sizeof, =, +, -(unary), -(binary), *, /, <, >, <=, >=, ==, !=, !, function call,
and array reference.

For the type int, the following C expression operators are supported:

sizeof, =, +, -(unary), -(binary), *, /, %, _, &(binary),^, <, >, <=, >=, ==, !*
 *=,!, ++, --, >>, <<, function call, and array reference. Also pointer arithmetic
is supported.

The following operators are not supported: ?:, casts, ->, and ..

Table 3.2 on page 23 gives an overview over the operators and its' precedence
order.

A special operator of DEEP is the := operator.  This operator makes it
possible to do operations on arrays or to be more precise on vectors.  For
example to calculate a growth rate for the rabbits you can do like this:



   double Rabbit[61];
   double tmp[61];


   tmp[1] := Rabbit[1] - Rabbit[0];



The left side of the := operator determines how often the assignment oper-
ation is repeated.  In our example the operation is repeated 60 times and
the array index is incremented with every repetition. This operator should
be used carefully because the arrays must have the same length and its use
is only recommended for one-dimensional arrays. Multi-dimensional arrays
are not supported by this operator. I have developed it to do a quick calcu-
lation after a simulation run at the command window but you can also use
this operator inside a program.

Another special operator is '~=' operator which is described in 2.2.



                                 22




 _____________________________________________________________________
|                                                                     |
|                              Operators                              |
|_____________________________________________________________________|
|_Operator____________|description_____________________|Associativity_|
|---------------------------------------------------------------------|
| ()                  |function call                   |left to right |
| []                  |array_element___________________|______________|
| !                   |logical not                     |right to left |
| "                   |bitwise complement              |              |
| -                   |unary minus                     |              |
| ++                  |increment                       |              |
| --                  |decrement                       |              |
| &                   |address of                      |              |
| *                   |contens of                      |              |
| sizeof              |size_in_bytes___________________|______________|
| *                   |multiply                        |left to right |
| /                   |divide                          |              |
| %                   |remainder_______________________|______________|
| +                   |add                             |left to right |
| -                   |subtract________________________|______________|
| >>                  |bitwise right shift             |left to right |
| <<                  |bitwise_left_shift______________|______________|
| <                   |arithmetic less than            |left to right |
| >                   |arithmetic greater than         |              |
| <=                  |arithmetic less than or equal to               |
| >=                  |arithmetic_greater_than_or_equal_to_ __________|
| ==                  |arithmetic equal                |left to right |
| !=                  |arithmetic_not_equal____________|______________|
| &                   |bitwise_and_____________________|left_to_right_|
| ^                   |bitwise_exclusive_or____________|left_to_right_|
| |                   |bitwise_or______________________|left_to_right_|
| &&                  |logical_and_____________________|left_to_right_|
| ||                  |logical_or______________________|left_to_right_|
| = += -= *= /= %=    |assignment_operator_____________|left_to_right_|
 ---------------------------------------------------------------------

               Table 3.2: Operators in precedence order



                                 23




3.1.6   Statements


The following statement constructs are supported: expressions, for, while,
if, break, return, and compound statements.

There also three special statements: list,stop,run.



   - 'list' displays the program in an internal representation.^2


   - The 'run' statement starts the interpreter which can also be done by
     pressing the Alternate and 'R' key. 'list' and 'run' should only be used
     within the command window.


   - With 'stop' you can set a breakpoint in a program. If a 'stop' statement
     is found by the interpreter the program execution is stopped and a box
     is shown which enables you to look at the global and local variables.
     You can also cancel the program excution.



The following statement constructs are not supported:  switch, continue,
goto, do...while, and statement labels.



3.1.7   Preprocessor Dircetives


DEEP supportes the following preprocessor dircetives:  #define, #undef,
#ifdef, #ifndef, #endif, #include.

Macro-expansion, trigraph sequences, builtin macros, the string producer #
and the token pasting operator ## are not supported.



3.2    Standard library functions



DEEP supports several of the C standard library functions. The functions
are the original library functions of the Turbo C Compiler.
____________________________
2  All preprocessor statements are replaced its' definition text, so you can 
   control whether the preprocessor has generated the correct code.



                                 24




3.2.1   Mathematical functions


Table 3.3 on page 26 shows the mathematical functions availiable within
DEEP. The functions are part of the Turbo C compiler used to generate
this program.  I assume that these functions work correct otherwise is not
my fault.



3.2.2   Input/Output functions


The most important function in table 3.4 on page 27 is the printf() func-
tion.  This function enables a formated output on the command window.
sprintf() does the same but here the output is written to a buffer.



3.2.3   Other functions


The most important function with respect to simulation in this section is the
random function. This function is taken from the book "Numerical Recipes
in C" [4]. It's identical with the ran3() function described on page 212 of
this book.



3.3    Simulation features



To do it's simulation job DEEP has some special features you won't find in
the C language. These features are special variables, functions and opera-
tors.



3.3.1   Simulation variables


The variable long length holds the length of a simulation run. The variable
long t holds the actual time step and is incremented by the system after
each call to the simulation() function.

dt is a variable used to specify the integration step for differential equation*
 *s.
This variable can have values between 0 and 1.  With a smaller dt the
precesion of the calculation ascends and execution speed descends and vice
versa. The values of dt should follow this row 1,0.5, 0.25,0.125,...  . With



                                 25




 __________________________________________________________________________
|                                                                          |
|                             Mathematical functions                       |
|__________________________________________________________________________|
|_function_________________________|name___________________________________|
|--------------------------------------------------------------------------|
| int abs(int i)                   |absolute_value_________________________|
| double acos(double x)            |arcus cosine___________________________|
| double asin(double x)            |arcus sine_____________________________|
| double atan(double_x)            |arc_tangent____________________________|
| double atan2(double_y,_double_x) |arc_tangent____________________________|
| double ceil(double x)            |ceiling________________________________|            
| double cos(double_x)             |cosine_________________________________|
| double cosh(double_x)            |cosine_hyperbolic______________________|
| double exp(double_x)             |exponential____________________________|
| double fabs(double_x)            |float_abs______________________________|
| double floor(double x)           |largest  ineteger not greater than x___|
| double fmod(double_x,double_y)   |float_modulus__________________________|
| long labs(long_x)                |long_absolut___________________________|
| double ldexp(double_x,_double_n) |log_double_exp_________________________|
| double log(double x)             |natural logarithm log__________________|
| double log10(double x)           |logrithm base 10_______________________|
| double modf(double x,double *ip) |modulo float___________________________|
| double pow(double x,double y)    |power__________________________________|
| double pow10(double_x,double_y)  |power_of_10____________________________|
| double sin(double_x)             |sine___________________________________|
| double sinh(double_x)            |sine_hyperbolic________________________|
| double sqrt(double_x)            |square_root____________________________|
| double tan(double_x)             |tangent________________________________|
 --------------------------------------------------------------------------

              Table 3.3: Standard mathematical functions



                                 26




 ___________________________________________________________________________                                                                              *
|                            Input/Output functions                         |
|___________________________________________________________________________|
|_function_________________________________|comment_________________________|
|---------------------------------------------------------------------------|
| int close(int handle)                    |close_file_of_specified_handle__|
| int creat(char *filename)                |create_a_new_file_with_name_____|
|                                          |filename________________________|
| int getchar(void)                        |Returns_the_next_character_from_|
|                                          |keyboard________________________|
| char *gets(char_*str)                    |Returns_next_input_line_or_NULL_|
| int open(char *filename, int access)     |Open file filename with access__| 
|                                          |mode 'access'___________________|
| int printf(char *format,...)             |print_formated_to_the_command___|
|                                          |window__________________________|
| int_putchar(int c)                       |put_charater_to_the_commamd_____|
|                                          |window__________________________|
| int puts(char *s)                        |write the string s and a newline|
|                                          |to_the_command_window___________|
| long read(int handle, void *buf, long len)|read 'len' bytes from the file |
|                                          | specified through_'handle'_to__|
|                                          | 'buf'__________________________|
| int remove(char *filename)               |removes_the_named_file__________|
| int rename(char *old, char *new)         |changes_the_name_of_a_file______|
| int scanf(char *format, ...)             |read from keyboard under the____|
|                                          |control format__________________|
| int sprintf(char *buffer,char *format,_...)|print_formated_into_'buffer'__|
| long write(int handle, void *buf, long len)|writes 'len' bytes of 'buf' to|
|                                          |  the file specified_through____|
|                                          |  'handle'______________________|
 ---------------------------------------------------------------------------

                 Table 3.4: Input and Output functions
                                                          


                                 27




 ___________________________________________________________________________
|                                                                           |
|                              Other functions                              |
|___________________________________________________________________________|
|_function_________________________|comment_________________________________|
|---------------------------------------------------------------------------|
| double atof(char *str)           |converts_'str'_to_double________________|
| int atoi(char *str)              |converts_'str'_to_integer_______________|
| long atol(char *str)             |converts_'str'_to_long__________________|
| void exit(void)                  |causes_normal_program_termination_______|
| void free(void *ptr)             |deallocates_the_space_pointed_to_by_ptr_|
| void *malloc(long_size)          |allocates_'len'_bytes_and_returns_pointer|
| double random(int *ini)          |returns a pseudo-random number between__|
|                                  |0.0_and_1.0_.'ini'=0_resets_the_generator|
| char *strcat(char_*dest,_char_*src)|concatenate_'src'_to_the_end_of_'dest'|
| int strcmp(char *s1, char *s2)   |compare string s1 to string s2__________|
|                                  |return < 0 if s1 < s2                   |
|                                  |0 if s1==s2, or >0 if s1>s2             |
| char *strcpy(char_*s1,_char_*s2) |copy 's2' to 's1'_______________________|
 ---------------------------------------------------------------------------
                      Table 3.5: Other functions



a dt of 0.25 , e.g, the system calculates the values of integration equation 4
(1/dt) times each time step t with dt 0.125 this would be 8 times.

If you need t in a differential equation you have to use the internal variable
T instaed of t to get correct results.



3.3.2   Simulation functions and operators


DEEP knows the following simulation functions:



   - simulation() which is called length times depending on the initial
     value of t.


   - integration_rk2() performs in conjunction with the ~= assignment
     a Runge-Kutta integration of 2nd order.  The setting of dt is a pre-
     condition for the correct work of this integration method.


   - integration_rk4() let you calculate a Runge-Kutta integration of
     4th order. dt must also be chosen.



                                 28




As described in the Lynx-Rabbit example (see 2.2 on page 10) we have the
special assignment operator '~='. This operator is only useful in the functions
integration_rk2() or integration_rk4() which should be called from the
simulation() function to get results for a time series.



3.3.3   The simulation memory


DEEP has it's own memory management.  You determine how huge the
interpreter space should be.  It is not efficient to take the whole possible
core for the interpreter, because the interpreter also dynamicaly needs space
during run time.

The stack space of the interpreter is limited to 16 Kb. I think thats will be
enough for normal program execution.  You can do recursion with DEEP
but you will run out of stack space sooner as you might expect, because the
interpreter does a lot of recursive function calls.

Before starting an interpreter run the interpreter core is cleared. The bigger
the size of the core is, the longer it takes till this job is done.



                                 29




Bibliography



 [1]P.A. Darnell,  P.E. Margolis. C: A Software Engineering Approach.
    Springer Verlag, 1991


 [2]B.W. Kernigham, D.M. Ritchie. The C Programming Language Second
    Editon. Prentice Hall, 1988


 [3]A.M. Starfield, K.A. Smith, A.L. Bleloch. How to model it Problem
    solving for the computer age. McGraw-Hill,1990


 [4]W.H. Press, B.P. Flannery, S.A. Teukolsky, W.T. Vetterling. Numerical
    Recipes in C. Cambridge University Press, 1988



                                 30
