/ This file contains fast image drawing routines to replace the VDI vro_cpyfm
/ in LOW-RES.  They will have to be slightly modified in Med Res.
/ The only changes involve the removal of a number of lines, these lines
/ are clearly marked with CAP comments.  To make these work with hi-res you
/ will have to make the same changes as for Med-Res, but you will also have
/ to change some move.l type instruction into move.w type instructions.  These
/ are also labelled.


/ This routine shifts a word aligned image over by a specified number of
/ pixels.  It works only on LOW-RES bitimages.
/ Define in C as:
/ EXTERN VOID Shift_Image(w_width, height, objPtr, destPtr, offset);
/        int w_width, height, *objPtr, *destPtr, offset;
/	w_width = word width of image
/	height  = pixel height of image
/	objPtr  = ptr to the source image (still word aligned)
/	destPtr = ptr to buffer in which to store the shifted image
/	offset  = how many pixels to shift (1-15)

	.globl Shift_Image_
	.shri

Shift_Image_:
	move.w	6(sp),d1	/height in d1
	move.w	16(sp),d2	/offset to d2
	andi.w	$0xf,d2		/only want the 4-low bits (0-15)
	subq.w	$1,4(sp)	/width - 1 = width if count starts at zero
	movea.l	8(sp),a0	/object pointer to a0
	movea.l 12(sp),a1	/dest pointer to a1
	bra	si2		/height - 1 = height if count starts at zero
si0:	move.w	4(sp),d0	/width in d0
	clr.l	(a1)		/for each line, the first word of the
	clr.l	4(a1)		/image must be cleared
si1:	clr.l	d4		/make sure that the top halves of these
	clr.l	d5		/registers are zeroed out
	clr.l	d6
	clr.l	d7
	move.w	(a0)+,d4	/load in one word (four planes)
	move.w	(a0)+,d5	/to be rotated
	move.w	(a0)+,d6
	move.w	(a0)+,d7
	ror.l	d2,d4		/rotate all planes by the offset(d2)
	ror.l	d2,d5
	ror.l	d2,d6
	ror.l	d2,d7
	or.w	d4,(a1)+	/add low order bits to the high order bits
	or.w	d5,(a1)+	/stored by move instructions farther
	or.w	d6,(a1)+	/down in this routine
	or.w	d7,(a1)+
	swap	d4		/move high order bits into lower halves
	swap	d5		/of the registers
	swap	d6
	swap	d7
	move.w	d4,(a1)		/save the high orders bits to be ORed
	move.w	d5,2(a1)	/in the loop (do not increment a1 because
	move.w	d6,4(a1)	/the ORs in the loop must function on
	move.w	d7,6(a1)	/the same addresses as these moves.
	dbra	d0,si1		/repeat width times
	addq.l	$8,a1		/new line, move to next word( / 4 planes = 8)
si2:	dbra	d1,si0		/repeat height times
	rts			/done



/ This routine shifts a mask that is already in the format identical to
/ the one generated by Make_Mask (below).  It assumes that the mask is
/ an overlay of the image and needs to be reversed in order to be usable by
/ Draw_Image.  This routine functions in much the same way as the
/ Shift_Image routine, but works on single LONG WORDS rather than no
/ complete LOW-RES vplane blocks.  Thus, it could be used directly as a
/ MED-RES Shift Image routine.
/ Define in C as:
/ EXTERN VOID Shift_Mask(w_width, height, maskPtr, destPtr, offset);
/        int w_width, height, *maskPtr, *destPtr, offset;
/	w_width = word width of mask image
/	height  = pixel height of image
/	maskPtr = ptr to the source image (still word aligned)
/	destPtr = ptr to buffer in which to store the shifted image
/	offset  = how many pixels to shift (1-15)

	.globl Shift_Mask_
	.shri

Shift_Mask_:
	move.w	6(sp),d1	/height in d1
	move.w	16(sp),d2	/offset to d2
	andi.w	$0xf,d2		/only want the low 4-bits (0-15)
	subq.w	$1,4(sp)	/width - 1 = width if count starts at zero
	movea.l	8(sp),a0	/object pointer to a0
	movea.l 12(sp),a1	/dest pointer to a1
	bra	sm2		/height - 1 for dbra loop (stop at -1)
sm0:	move.w	4(sp),d0	/width in d0
	clr.l	(a1)		/for each line, the first word of the
	not.l	(a1)		/mask has to be 1 filled
sm1:	clr.l	d4		/make sure that the top halves of these
	move.w	(a0)+,d4	/load in one word to be rotated
	addq.l	$2,a0
	ror.l	d2,d4		/rotate all planes by the offset(d2)
	eor.w	d4,(a1)+	/add low order bits to the high order bits
	eor.w	d4,(a1)+	/stored by move instructions farther down
	swap	d4		/move high order bits into lower half
	not.w	d4		/invert mask
	move.w	d4,(a1)		/save the high orders bits to be XORed
	move.w	d4,2(a1)	/in the loop 
	dbra	d0,sm1		/repeat width times
	addq.l	$4,a1		/new line, move to next word ( / 2 planes = 4)
sm2:	dbra	d1,sm0		/repeat height times
	rts			/done


/ This routine makes a mask for a Raster Image from the image itself.
/ This is a logical AND mask (uses and.l to cut hole in background).
/ Use of this solves several problems for the size of the .data section
/ of the program.  Also, each Vplane of the mask is only 1 long word
/ wide (since you don't need more).  Thus, the mask is half the size
/ of the corresponding image.  Draw_Image assumes this type of mask.
/
/ Define in C as:
/ EXTERN VOID Make_Mask(w_width, height, imagePtr, maskPtr);
/        int w_width, height, *imagePtr, *maskPtr;
/	w_width  = word width of image (hangover is handled)
/	height   = pixel height of image
/	imagePtr = ptr to image data
/	maskPtr  = ptr to place to store the mask

	.globl Make_Mask_
	.shri

Make_Mask_:
	move.w	6(sp),d1	/height in d1
	movea.l	8(sp),a0	/image pointer to a0
	movea.l	12(sp),a1	/mask pointer to a1
	bra.s	mm2		/height - 1 = height if count starts at zero
mm0:	move.w	4(sp),d0	/width in d0
mm1:	move.w	(a0)+,d2	/load first plane of bit image in d2
	or.w	(a0)+,d2	/OR it with the 3 other planes
	or.w	(a0)+,d2
	or.w	(a0)+,d2
	move.w	d2,d3		/store inverse mask in d3 (temporary)
	swap	d2		/move inverse mask to top half of register
	move.w	d3,d2		/and also in bottom half
	eori.l	$-1,d2		/mask no longer inverse
	move.l	d2,(a1)+	/store mask in buffer
	dbra	d0,mm1		/repeat 'width' times
mm2:	dbra	d1,mm0		/repeat 'height' times
	rts			/done


/ This routine draws an image on the screen.  It assumes that the data is
/ Once again, use with LOW-RES only.
/ Define in C as:
/ EXTERN VOID Draw_Image(w_width, height, scrPtr, imagePtr, maskPtr);
/        int w_width, height, *scrPtr, *imagePtr, *maskPtr;
/	w_width  = word width of image (actual)
/	height   = pixel height of image (actual)
/	scrPtr   = ptr to the absolute screen address to place the image
/	imagePtr = ptr to image data
/	maskPtr  = ptr to the mask data

	.globl Draw_Image_
	.shri

Draw_Image_:
	move.w	6(sp),d1	/height to d1
	movea.l	12(sp),a1	/image pointer to a1
	movea.l	16(sp),a2	/mask pointer to a2
	bra.s	di2		/height - 1 = height if count starts at zero
di0:	move.w	4(sp),d0	/width to d0
	movea.l	8(sp),a0	/absolute screen address to a0
	movea.l a0,a3
di1:	move.l	(a2)+,d3	/load mask data into d3
	move.l	(a1)+,d6	/load screen image into d6 and d7
	move.l	(a1)+,d7	/2 words each covers all 4 planes
	move.l	(a3)+,d4	/do the same for the background
	move.l	(a3)+,d5	/in d4 and d5 (from screen)
	and.l	d3,d4		/mask background
	and.l	d3,d5
	or.l	d6,d4		/copy image onto background
	or.l	d7,d5		/giving final image on top of background
	move.l	d4,(a0)+	/copy final image into screen memory
	move.l	d5,(a0)+
	dbra	d0,di1		/repeat for 'width' times
	addi.l	$160,8(sp)	/move to next screen line
di2:	dbra	d1,di0		/repeat 'height' times
	rts			/done


/ This routine copies a block from one screen to another.
/ It works only in LOW-RES.
/ Define in C as:
/ EXTERN VOID CopyScrn_Block(width, height, source, dest, offset)
/        int w_width, height, *source, *dest, offset;
/	width = width of block in vplanes		 4(sp)
/	height  = vert. size of the block		 6(sp)
/	source  = absolute address of source screen	 8(sp)
/	dest    = absolute address of dest screen	12(sp)
/	offset  = offset into each screen		16(sp)

	.globl CopyScrn_Block_
	.shri

CopyScrn_Block_:
	move.w	16(sp),d0	/get offset into screen buffer
	ext.l	d0		/make it a long
	move.l	d0,d1		/save a copy
	add.l	8(sp),d0	/add source screen addr
	move.l	d0,8(sp)	/save absolute source addr
	add.l	12(sp),d1	/calc absolute dest addr
	move.l	d1,12(sp)	/save it

	subq.w	$1,4(sp)	/width - 1 = width if count starts at zero
	move.w	6(sp),d0	/copy height to d1
	move.l	$160,d3		/line offset for low-res ($80 for HI-RES)
	bra.s	mb2		/height - 1 = height if count starts at zero
mb0:	move.w	4(sp),d1	/copy width to d0
	movea.l	8(sp),a0	/absolute source address to a0
	movea.l	12(sp),a1	/absolute dest address to a1
mb1:	move.l	(a0)+,(a1)+	/move all four planes (move.w for HI-RES)
	move.l	(a0)+,(a1)+	/DELETE for MED-RED
	dbra	d1,mb1		/repeat width times
	add.l	d3,8(sp)	/move to next line on both screens
	add.l	d3,12(sp)
mb2:	dbra	d0,mb0		/repeat height times
	rts			/done



/ This routine copies a block of contiguous memory from place to place.
/ It was designed to copy LOW-RES screen quickly, so it copies VPLANE
/ BLOCKS (which are 2 LONG WORDs each).
/ Define in C as:
/ EXTERN VOID Copy_Block(source, dest, size)
/       int *source, *dest;	
/	unsigned int offset;
/	source	= absolute address of source screen	 4(sp)
/	dest	= absolute address of dest screen	 8(sp)
/	size	= offset into each screen		12(sp)

	.globl Copy_Block_
	.shri

Copy_Block_:
	movea.l	4(sp),a0	/ get source address
	movea.l	8(sp),a1	/ get dest address
	move.w	12(sp),d0	/ get length of buffer
	bra.s	cpyblk1		/ make count start at zero
cpyblk0:
	move.l	(a0)+,(a1)+	/ 2 longs makes a vplane
	move.l	(a0)+,(a1)+
cpyblk1:
	dbra	d0,cpyblk0		/ loop until done
	rts



/ This routine clears a block of contiguous memory.
/ It was designed to clear a LOW-RES screen quickly, so it clears
/ 2 LONG WORDs per pass of the loop.
/ Define in C as:
/ EXTERN VOID Clear_Block(dest, size)
/       int *dest;	
/	unsigned int offset;
/	dest	= absolute address of block to clear	4(sp)
/	size	= offset into each screen		8(sp)

	.globl Clear_Block_
	.shri

Clear_Block_:
	movea.l	4(sp),a0	/ get address of block to clear
	move.w	8(sp),d0	/ length of block to clear (in LONG pairs)
	bra.s	clrblk1		/ length starts at 0
clrblk0:
	clr.l	(a0)+		/ clear 2 LONGs for 1 LOW-RES vplane
	clr.l	(a0)+
clrblk1:
	dbra	d0,clrblk0
	rts



/ This routine merges two blocks of memory using bitwise OR.
/ It was designed to work with LOW-RES images, so it handles 2 LONGS per pass.
/ Define in C as:
/ EXTERN VOID Merge_Block(source, dest, size)   
/       int *dest;	
/	unsigned int offset;
/	source	= absolute address of source image	 4(sp)
/	dest	= absolute address of dest image	 8(sp)
/	size	= offset into each screen		12(sp)


	.globl Merge_Block_
	.shri

Merge_Block_:
	movea.l	4(sp),a0	/ get source image ptr
	movea.l	8(sp),a1	/ get dest buffer ptr
	move.w	12(sp),d0	/ get block length
	bra.s	merge1
merge0:
	move.l	(a0)+,d1	/ merge 2 LONGS
	or.l	d1,(a1)+
	move.l	(a0)+,d1
	or.l	d1,(a1)+
merge1:	dbra	d0,merge0	/ continue until done

	rts
