ZORG, Copyright Ludovic Rousseau 1993, 1994



                             FAT



  Les fichiers sont d‚coup‚s en blocs (Cluster) et non en secteurs. La FAT
(File Allocation Table) est un fait un tableau de pointeurs chaŒn‚s sur les
blocs des fichiers. A chaque bloc du disque correspond une valeur dans la FAT.
Cette valeur indique plusieurs ‚tats possibles : le bloc est libre, le bloc
fait partie d'un fichier, le bloc est le dernier bloc d'un fichier ou le bloc
est endommag‚.
  Les fichiers ne sont pas forc‚ment ‚crits de fa‡on contigu‰ sur le disque et
peuvent ˆtre en plusieurs morceaux r‚partis n'importe o— sur le disque. Il faut
pouvoir 'tracer le chemin' d'un fichier et la FAT sert … ‡a. Le fait que les
fichiers soient d‚coup‚s en blocs de plusieurs secteurs permet de ne pas avoir
de fichiers potentiellement trop d‚coup‚s et donc un va et vient de la tˆte de
lecture si les blocs ‚taient de 1 secteur seulement et en mˆme temps ne pas
perdre trop de place dans le dernier bloc qui ne perd pas plus de 1023 octets
avec des secteurs de 512 octets. Il a fallu faire un compromis entre des blocs
de grande taille d'un c“t‚ et de petite taille de l'autre. On peut remarquer
que les RAM DISK ont des blocs de 1 'secteur' car dans ce cas le d‚placement de
la tˆte n'a aucune importance vu qu'il n'y en a pas de tˆte.

  Le premier bloc d'un fichier est indiqu‚ dans l'entr‚e du r‚pertoire. A ce
bloc correspond une valeur dans la FAT. Cette valeur indique le prochain bloc
du fichier. A ce prochain bloc correspond ‚galement une valeur dans la FAT et
ainsi de suite jusqu'au dernier bloc.

  Sur une disquette, une valeur dans la FAT occupe 12 bits soit 1.5 octet.
Comme pour le boot sector, il faut utiliser les mˆmes rŠgles que les disquettes
DOS et donc un format petit boutien. Le format petit boutien est le format
utilis‚ par les processeurs Intel (entre autres). Dans ce format les octets
sont ‚crits dans l'ordre octet de poids faible puis octet de poids fort. Par
exemple $1234 est ‚crit $34 puis $12. Les processeurs 680x0 de Motorola
utilisent eux le format gros boutien dans lequel $1234 s'‚crit $12 $34, ce qui
est quand mˆme plus facile … lire pour un humain.

  Lire et ‚crire 12 bits en petit boutien c'est pas ‚vident.
  Pour comprendre il faut prendre 3 octets donc 2 entr‚es de FAT.

    +---+---+---+---+---+---+
    | A : B | C : D | E : F |
    +---+---+---+---+---+---+

  Les octets sont d‚coup‚s en quartets. Chaque lettre repr‚sente un quartet.
Les lettres A et B forme le premier octet.

  Ces trois octets correspondent aux entr‚es form‚es des quartets 0D AB et 0E
FC.


          +--------<--------+
          |                 |
    +---+---+---+---+  +---+---+  +---+---+---+---+
    | 0 : D | A : B |  | C : D |  | 0 : E | F : C |
    +---+---+---+---+  +---+---+  +---+---+---+---+
                         |                      |
                         +---------->-----------+

  Pour un disque dur c'est plus simple car chaque entr‚e occupe 2 octets. Il
suffit d'‚changer l'octet de poids faible avec l'octet de poids fort pour avoir
une valeur en gros boutien compr‚hensible par un processeur Motorola 68xxx.

  Les 2 premiŠres entr‚es de la FAT ne sont pas utilis‚es. Sur une disquette
elles valent $FF9 et $FFF et occupent les 3 premiers octets ($F9 $FF $FF). $F9
indique le format de la disquette mais n'est pas utilis‚. Les deux $FF
devraient pointer sur la fin du disque mais ne sont pas utilis‚s. Pour un
disque dur, les 2 premiŠres entr‚es occupent 4 octets ($00 $00 $00 $00) et ne
servent pas … grand chose.

  Le premier bloc du disque est donc en fait le bloc num‚ro 2. Ce bloc commence
sur le disque juste aprŠs la fin du r‚pertoire principal.


  Valeurs des entr‚es dans la FAT pour une disquette :

  - $000 indique que le bloc n'appartient … aucun fichier;

  - $001 ???;

- de $002 … $FF0 : le bloc est dans un fichier et cette valeur est le num‚ro du
prochain bloc du fichier;

- de $FF1 … $FF7 : le bloc n'est pas utilis‚. En g‚n‚ral il s'agit d'une erreur
mat‚riel sur l'un des secteurs du bloc. Ce bloc est d‚faillant et ne doit pas
ˆtre utilis‚;

- de $FF8 … $FFF : le bloc est le dernier du fichier. La fin exact du fichier
se d‚duit avec la taille du fichier en octet indiqu‚e dans l'entr‚e du
r‚pertoire.



  Pour un disque dur, les valeurs peuvent aller jusqu'… $FFFF.

  - $0000 le bloc est libre;

  - une valeur de $0002 … $FFF0 indique un prochain bloc du fichier;

  - de $FFF1 … $FFF7 le bloc est endommag‚;

  - de $FFF8 … $FFFF le bloc est le dernier du fichier.


  ZORG a une fonction permettant d'afficher la liste des blocs d'un fichier
('Information' / 'Tracer un Fichier').

  ZORG permet de g‚rer des disques ayant un nombre quelconque de secteurs par
bloc et pas seulement 1 ou 2 secteurs par bloc. Il paraŒt ainsi facile de
concevoir une partition de 128 Mo ayant 32768 blocs de 8 secteurs chacun. Le
problŠme est que le systŠme ne lit pas des blocs mais des secteurs et que
l'appel systŠme utilis‚ 'long Rwabs( int rwflag, void *buffer, int count, int
devno )' ne permet d'indiquer les secteurs que sur un entier de 16 bits soit au
maximum 65535 secteurs avec un entier non sign‚.
  Deux problŠmes se posent alors :
  - il faut que toutes les routines utilisent des entiers non sign‚s et je ne
suis pas s–r que toutes mes routines le fassent.
  - on est limit‚ … des partitions de 65536 * 512 = 32 Mo ou 32768 * 512 = 16
Mo avec un compteur sur 15 bits (sign‚) (utilis‚ sur les TOS ant‚rieurs au TOS
1.04).


  La solution est d'utiliser des secteurs plus grands que 512 octets. On peut
alrs monter jusqu'… une partition de 65536 * 32768 = 2 Giga avec des secteurs
de 32768 octets.

  On peut malgr‚ tout lire des disques de 1073741824 octets (un giga-octet) en
utilisant l'accŠs direct au contr“leur du disque. Cet accŠs direct permet de
donner un num‚ro de secteur sur 21 bits. Le problŠme est que cet accŠs ne se
fait pas par le systŠme mais avec mes propres routines et donc peut ne pas
marcher avec tous les disques. Il existe sur TT un appel systŠme 'int DMAread(
long sector, int count, void *buffer, int devno )' qui permet d'indiquer un
secteur sur un entier long de 32 bits.

  La solution … ce problŠme de limite du num‚ro de secteur est de ne pas
utiliser Rwabs() (limit‚ … 16 bits) mais d'utiliser soit DMAread() sur un TT ou
Falcon soit une routine propre. Un autre problŠme se pose alors. DMAread() ne
lit pas un secteur sur une partition mais sur un disque entier. Il faut donc
fournir en paramŠtres … ZORG l'organisation du disque en partitions afin de
savoir ou commence la partition sur le disque. Ce param‚trage se fait avec le
fichier ZORG.INF (voir ZORG_INF.TXT).
  Je dois vous mettre en garde sur l'utilisation d'une routine propre. La
routine de lecture de secteur que j'utilise provient d'un exemple du livre
'Disquette et Disque Dur' de Micro Application. Le bon fonctionnement de cette
routine n'est en aucun cas garantie avec tous les disques. Elle marche
impeccablement bien avec mon MegaFile 30 mais peut poser des problŠmes avec des
disques bizarres. Je ne vous conseillerai jamais assez de v‚rifier que tout
marche bien avant d'utiliser r‚ellement ZORG.
