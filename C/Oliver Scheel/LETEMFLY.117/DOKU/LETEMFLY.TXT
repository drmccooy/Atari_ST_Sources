                             Let 'em Fly!
                             ------------

                     (Flying Dials and more ...)

                             Version 1.17
                            Dezember  1991

                      (c) 1991 by Oliver Scheel
                        Freaky Deaky Software

                           (it's Freeware)


                              Einleitung
                              ==========

Tjaaa,  eigentlich  wollte ich nur mal sehen wie schnell das  VDI  des 
Atari ST sein kann, doch daraus ist dann wohl etwas mehr geworden ...

Jeder  dÅrfte inzwischen fliegende Dialogboxen kennen.  Sie sind  z.B. 
in `Gemini' (dem Shareware Alternativ-Desktop) oder in `Rufus'  (einem 
Terminalprogramm)  eingebaut.  Zudem sind diese Dialogboxen auch  Åber 
die  Tastatur  bedienbar  und hÑufig bleibt  einem  so  der  fliegende 
Wechsel zwischen Tastatur und Maus erspart.  Leider sind diese Dialog-
boxen  nur  innerhalb  dieser Programme aktiv  und  sobald  man  diese 
verlassen hat,  steht man wieder ohne da.  Und hier setzt Let 'em Fly! 
an,  und  viele  `normale'  Dialogboxen sind  jetzt  auch  mit  diesen 
Features ausgestattet.

Features
--------

 - Fliegende Dialoge:
     Viele  Dialoge werden flugfÑhig gemacht.  Hiermit kann  man  Ver-
     decktes  sichtbar  machen.  Auch  die  Alert-Boxen  kînnen  jetzt 
     fliegen.
     Durch  ein  ausgeklÅgeltes  Verfahren sind die  Boxen  auch  ohne 
     Blitter  beim  Verschieben ertrÑglich schnell und  optisch  opti-
     miert.  Zudem  lÑuft die ganze Geschichte  speicherplatzoptimiert 
     ab,  d.h.  auch  wenn  wenig Speicher vorhanden ist,  ist  es  in 
     einigen FÑllen noch mîglich die Boxen zu verschieben.
     Weiterhin  merkt  sich  Let 'em  Fly!  innerhalb  des  jeweiligen 
     Progamms  die Position der Dialogboxen,  d.h.  daû nach dem  Ver-
     schieben  einer  Box  diese  dann beim  erneuten  Aufruf  an  der 
     letzten Position wieder dargestellt wird.
     Auch  virtuelle Screens a la `BigScreen 2.0' werden  unterstÅtzt, 
     d.h.  die  Dialogboxen  werden in dem zur  Zeit  sichtbaren  Aus-
     schnitt zentriert.

 - Tastaturbedienbarkeit von Dialogen:
     Ebenso  viele Dialoge kann man jetzt Åber die Tastatur  bedienen. 
     Bei  ganz bestimmten Mustern werden auch die Sondertasten  [HELP] 
     und [UNDO] belegt.

 - ZusÑtzliche Editierfunktionen:
     Sind  in  einem Dialog editierbare  Eingabefelder  vorhanden,  so 
     werden zusÑtzliche Editierfunktionen  bereitgestellt.  U.a.  wird 
     auch  das  GEM-Clipboard  unterstÅtzt,  sowie  eine  History  der 
     letzten  20  Eingaben gefÅhrt.  Einige  Editierfunktionen  kînnen 
     auch  in  Programmen Wirkung zeigen welche  eigene  Routinen  zur 
     Dialogverarbeitung benutzen.

 - neue Alert-Boxen mit neuen Icons:
     Die Optik der Alert-Boxen wurde Åberarbeitet.  Sie sind jetzt nur 
     noch  so groû wie sie wirklich sein mÅssen.  Weiterhin  kann  man 
     neue Icons nachladen.

 - Grow-/Shrinkboxen abschaltbar:
     Es lassen sich auch die Grow- und Shrinkboxen abschalten,  um  so 
     einen  Geschwindigkeitsgewinn beim Zeichnen von Dialogboxen  u.a. 
     Dingen zu erzielen.

 - Kein Flugschein erforderlich!
     Ja,  Sie  haben richtig gelesen.  FÅr Let 'em Fly!  brauchen  Sie 
     keinen Flugschein.  Grundkenntnisse in der Bedienung des  Steuer-
     aggregats sollten aber trotzdem vorhanden sein.

Das  Programm  lÑuft auf allen ST/TT Rechnern  in  allen  Auflîsungen. 
Falls es trotzdem Probleme gibt, bitte ich um Kontaktierung.

Das  Programm  ist Freeware,  d.h.  es darf frei kopiert  und  benutzt 
werden.  Davon ausgeschlossen ist die gewerbliche Nutzung.  Diese  ist 
nur mit schriftlicher(!) Genehmigung meinerseits mîglich, eingeschlos-
sen  davon sind PD-Versande!  Die Rechte bleiben in allen  FÑllen  bei 
mir. Zuwiderhandlungen werde ich strafrechtlich verfolgen.

Zu Let 'em Fly! gehîren folgende Dateien:

     - LETEMFLY.PRG           Das eigentliche Programm
     - LET_CONF.PRG/ACC       Das Konfigurationsprogramm
     - LET_CONF.CPX           Das Ganze als CPX-Modul

     - GEM1ICON.RSC           Die  originalen  Atari  Icons  fÅr   die 
                              Alert-Boxen
     - GEM2ICON.RSC           Die Icons aus GEM/2 fÅr die Alert-Boxen

     - LETEMFLY.TXT           Diese Anleitung
     - CHANGES.TXT            Die   énderungen   zwischen   den   ver-
                              schiedenen Versionen
     - READ_ME                Eine kurze Info

Let 'em Fly!  darf  nur  komplett  mit  diesen  Dateien  weitergegeben 
werden.

Ich  erhebe  mit dieser Anleitung keinen Anspruch  darauf,  daû  jeder 
alles versteht,  was zur normalen Benutzung auch nicht notwendig  ist. 
Das ist in diesem Fall prinzipbedingt,  da das Programm in die  Tiefen 
des Betriebssystem eintaucht und um alles zu verstehen,  muû man  auch 
dieses  ensprechend  genau kennen.

WICHTIG:   Weiterhin  ist  noch  eine  Zusatzdokumentation  fÅr   Pro-
grammierer und Fortgeschrittene erhÑltlich. Diese ist jetzt nicht mehr 
Teil  des  Let 'em Fly!  `Grundpaketes'.  Sie sollte entweder  in  den 
etablierten  Mailboxen  zu finden sein,  kann jedoch auch  Åber  einen 
adressierten und frankierten RÅckumschlag bei mir bezogen werden.

Jetzt aber erstmal das ...

Ich  Åbernehme  keine Haftung oder Verantworung fÅr direkte  oder  in-
direkte  SchÑden jedweder Art,  seien  sie  finanzieller,  materieller 
oder  sonstiger Art,  die aus dem Gebrauch,  Nichtgebrauch  oder  Miû-
brauch von Let 'em Fly! entstehen.
Fast  alle Soft- und Hardwarebezeichnungen,  die in  dieser  Anleitung 
erwÑhnt werden,  sind eingetragene Warenzeichen und sollten als solche 
betrachtet werden.


                             Installation
                             ============

Das eigentliche Programm LETEMFLY.PRG lÑût sich sowohl vom Desktop aus 
starten als auch aus dem AUTO-Ordner heraus.  Im zweiten Fall muû  man 
das Programm in den AUTO-Ordner des Boot-Laufwerks kopieren.  Nach dem 
nÑchsten Reset ist es dann automatisch installiert.
Daneben gibt es auch noch ein Konfigurationsprogramm LET_CONF.PRG/ACC. 
Mit  diesem Programm ist es mîglich Let 'em Fly!  an die  persînlichen 
BedÅrfnisse  anzupassen.  Es kann entweder vom Desktop  aus  gestartet 
werden oder als Accessory installiert werden.  Im zweiten Fall muû die 
Endung  auf  'ACC' lauten und das Programm  im  Wurzelverzeichnis  des 
Boot-Laufwerks  stehen.   Nach  einem  Reset  ist  es  dann  Åber  die 
Accessory-Leiste  aus jedem (echten) GEM-Programm heraus  ansprechbar. 
Da  die  neue  Version  dieses  Konfigurationsprogramm  etwas   lÑnger 
geworden ist und nicht jeder 2 oder 4 MByte Speicher besitzt, empfehle 
ich  `The Chameleonø' von Karsten Isakovic.  Mit diesem Programm  kann 
man Accessories nachladen und auch wieder entfernen.
Das Konfigurationsprogramm gibt's auch als CPX fÅr das neue  Kontroll-
feld  von  Atari.  Es  heiût LET_CONF.CPX und  muû  im  entsprechendem 
Verzeichnis liegen.


                              Bedienung
                              =========

GrundsÑtzliches
---------------
Nicht alle Dialogboxen werden von Let 'em Fly!  unterstÅtzt, da einige 
Leute eigene Routinen zur Dialogverarbeitung programmiert haben.  Hier 
kann  Let 'em Fly!  garnicht  oder nur teilweise  seine  Features  zur 
VerfÅgung stellen.  FÅr alle Programmierer,  die Let 'em Fly!  optimal 
ausnutzen  wollen,   gibt  es  (wie  oben  schon  erwÑhnt)  eine   Zu-
satzdokumentation.
Auch die Dialoge im Desktop werden nicht unterstÅtzt,  da hier das TOS 
seine Routinen direkt anspringt.
Falls irgendetwas nicht funktionieren sollte,  dann bitte ich erst die 
Einstellungen mit dem Konfigurationsprogramm (s.u.) zu prÅfen!

So, nun geht's aber los ...

Let 'em Fly!
------------
In  einer  Dialogbox  gibt es in erster  Linie  anwÑhlbare  und  nicht 
anwÑhlbare  Objekte.  Falls man jetzt ein nicht anwÑhlbares Objekt  in 
einem  Dialog  mit  der linken Maustaste anklickt  und  die  Maustaste 
festhÑlt,   so  sollte  sich  der  Mauszeiger  in  eine  Flache   Hand 
verwandeln. Nun kann man die Dialogbox auf dem Bildschirm verschieben. 
Je nachdem wie Let 'em Fly!  konfiguriert wurde (s.u.),  lÑût sich die 
Box  als Ganzes in Echtzeit verschieben oder nur als  Rahmen,  so  wie 
auch die normalen Fenster verschoben werden.  Falls man beim Anklicken 
der  Box zusÑtzlich die rechte Maustaste (oder eine der  Shift-Tasten) 
gedrÅckt  hÑlt,  so  verschwindet die Box und  ein  Geisterrahmen  er-
scheint.  Somit ist es jetzt mîglich `durch' die Box zu schauen, falls 
diese  etwas  verdeckt.  Der Geisterrahmen lÑût  sich  natÅrlich  auch 
verschieben.  Beim Loslassen der Maustaste(n) erscheint die Box wieder 
auf  dem Bildschirm.  Die Funktion der rechten Maustaste kann man  mit 
Hilfe des Konfigurationsprogramms auch umkehren.
Bemerkung:  es  kann  sein,  daû andere  Programme,  die  Let 'em Fly! 
explizit  unterstÅtzen auch nur Åber ein spezielles  Objekt  `fliegen' 
kînnen (der File-Selector `Selectricø' unterstÅtzt  z.B.  Let 'em Fly! 
und  man  kann dort die Box Åber das Eselsohr in  der  oberen  rechten 
Ecke  verschieben).  Hier  sollte aber die  Anleitung  des  jeweiligen 
Programms weiterhelfen.
Falls  die  Box sich zwar noch normal  verschieben  lÑût,  nicht  aber 
durchsichtig gemacht werden kann,  dann steht nicht genug Speicher zur 
VerfÅgung  um die komplette Box zu sichern.  Der erste  Modus  zerlegt 
bei  nicht ausreichendem Speicher die Flugbahn in  entsprechend  viele 
Einzelschritte  und  fÅhrt diese dann aus,  daher hat  man  hier  mehr 
Chancen.
Klickt  man  auûerhalb des Dialogs,  so machte  es  normalerweise  nur 
`Pling',  nun kommt zusÑtzlich der Dialog zur Mausposition `geflogen'. 
Diese  Funktion  ist  besonders bei  Groûbildschirmen  sehr  nÅtzlich. 
Zudem  bewirkt ein Doppelklick auf das Flugobjekt ein  Zentrieren  des 
Dialogs.
Weiterhin merkt sich Let 'em Fly!  die letzte Position der Dialogboxen 
innerhalb eines Programms,  d.h. verschiebt man die Dialoge, so werden 
sie  bei  einem erneuten Aufruf an der letzten  Position  wieder  dar-
gestellt.  Durch DrÅcken von [ALT]+[CTRL] beim Aufruf(!) des  Dialoges 
wird die Box wieder richtig zentriert.  Diese Funktion zeigt auch  bei 
fremden Flugroutinen Wirkung.
Bei  installierten virtuellen Screens a la `BigScreen 2.0' kînnen  die 
Dialoge  im  zur Zeit sichbaren  Ausschnitt  zentriert  werden.  Somit 
erspart man sich so manche Suche nach dem Dialog.  Alert-Boxen  werden 
unabhÑngig  von der Einstellung im KonfigurationsmenÅ immer im  sicht-
baren Ausschnitt zentriert.  Alert-Boxen sind ja dazu da dem  Anwender 
eine  wichtige  Information  zu geben und nicht,  um  sie  erst  lange 
suchen zu mÅssen.

Zusammenfassung:

   - Nicht  alle  Boxen kînnen fliegen!  Es muû a)  genÅgend  Speicher 
     vorhanden  sein und b) die  entsprechende  Betriebssystemfunktion 
     vom Programm aufgerufen werden.
   - Manchmal  ist es zwar mîglich die Box zu  verschieben,  aber  sie 
     lÑût  sich nicht mehr durchsichtig machen.  In diesem Fall  steht 
     nicht   mehr  genÅgend  Speicherplatz  fÅr  die   Bufferung   der 
     kompletten Box zur VerfÅgung.
   - Weiterhin  kînnen  Programme,  welche  nicht  darauf  vorbereitet 
     sind,  daû  ihre Boxen fliegen kînnten,  ein  etwas  eigenartiges 
     Verhalten   zeigen.    Es   wirkt   sich   aber   nur   auf   die 
     Bildschirmdarstellung  aus  und  irretiert  eher.   Daten   gehen 
     hierbei  normalerweise  nicht verloren.  Eine Garantie  kann  ich 
     dafÅr jedoch nicht geben.


Key Dials
---------
Viele  Dialoge lassen sich ab sofort auch Åber die Tastatur  bedienen. 
Das  sieht  man daran,  daû in/neben den Buttons unter  dem  Text  ein 
Buchstabe bzw. eine Zahl unterstrichen ist (in der Farbauflîsung steht 
auch  noch  eine andere Darstellungsart  zur  VerfÅgung).  DrÅckt  man 
diesen Buchstaben bzw.  diese Zahl in Verbindung mit der  [ALT]-Taste, 
so wird das entsprechende Objekt angewÑhlt.  Das entspricht dann einem 
einfachen  Mausklick auf das Objekt.  Weiterhin bewirkt ein  Mausklick 
auf  ein  unterstrichenes Objekt neben dem eigentlichen  Button  eben-
falls einen Klick auf das entsprechende Objekt.
Ist  kein  editierbares  Feld im Dialog vorhanden,  so  kann  man  die 
Shortcuts auch ohne [ALT]-Taste erreichen (z.B. in den Alert-Boxen).

Zudem  werden  je nach Mîglichkeit auch die Tasten [UNDO]  und  [HELP] 
belegt:

[HELP] sucht nach den Zeichenfolgen     'help',
                                        'hilfe'

[UNDO] sucht nach den Zeichenfolgen     'abbruch',
                                        'abbrechen',
                                        'verlassen',
                                        'nein',
                                        'quit',
                                        'cancel',
                                        'abort',
                                        'no',
                                        'exit'

Groû-  und  Kleinschreibung wird nicht  berÅcksichtigt.  Beim  DrÅcken 
einer dieser Tasten wird dann das jeweilige Objekt angewÑhlt.
Insgesamt  werden 38 Tasten (A-Z,  0-9,  HELP,  UNDO)  verwaltet.  Das 
Default-Objekt  (wird beim DrÅcken von RETURN angewÑhlt und  ist  dick 
umrandet),  sowie  das  UNDO-Objekt ist zudem (fast)  immer  Åber  den 
ersten  Buchstaben im jeweiligen Text zu  erreichen.  D.h.  'Ok'  Åber 
ALT+'O', 'Abbruch' Åber ALT+'A' u.s.w..

öber  [ALT]+[Tab] und [SHIFT]+[ALT]+[Tab] kann man den  Default-Button 
`verschieben',  d.h.  man kann in vielen FÑllen mit dieser Mîglichkeit 
und der RETURN-Taste den Dialog bearbeiten.

öber  [SHIFT]+[HELP] wird innerhalb eines Dialogs eine Copyright  Info 
angezeigt. Bei Alert/Error-Boxen ist diese Funktion ausgeschaltet.


Extended Editor
---------------
Sind in einer Dialogbox editierbare Eingabefelder vorhanden, so werden 
von  Let 'em Fly!  auch  zusÑtzliche Editierfunktionen  zur  VerfÅgung 
gestellt.

Neben den schon im Betriebssystem fest eingebauten ...

[Cursor Up]         Ein Eingabefeld zurÅck.
[Cursor Down]       Ein Eingabefeld vor.
[Cursor Left]       Ein Zeichen nach links.
[Cursor Right]      Ein Zeichen nach rechts.
[TAB]               Ein Eingabefeld vor.
[RETURN]            Beendet den Dialog.

... gibt es jetzt noch viel mehr ...

[RETURN]            Falls kein Default-Objekt vorhanden ist,  wird zum 
                    nÑchsten Eingabefeld gesprungen.
[SHIFT]+[RETURN]    springt  zum nÑchsten Eingabefeld (auch  wenn  ein 
                    Default-Objekt vorhanden ist).
[SHIFT]+[TAB]       Ein Eingabefeld zurÅck.
[SHIFT]+[Csr Left]  springt an den Anfang des Eingabefeldes.
[SHIFT]+[Csr Right] springt an das Ende des Eingabefeldes.
[CTRL]+[Csr Left]   springt wortweise nach links.
[CTRL]+[Csr Right]  springt wortweise nach rechts.
[Home]              springt zum ersten Eingabefeld im Formular.
[SHIFT]+[Home]      springt zum letzten Eingabefeld im Formular.
[CTRL]+[Delete]     lîscht alle Zeichen rechts vom Cursor.

Zudem  besitzen  die Tasten [Cursor Up] und [Cursor  Down]  sogenannte 
`Turn-Around'  Funktionen,  d.h.  ist  man im ersten  Eingabefeld  und 
drÅckt  [Cursor  Up],  so  gelangt man  ins  letzte  Eingabefeld.  FÅr 
[Cursor Down] gilt das Umgekehrte.
Weiterhin  wird  auch die direkte  Cursor-Positionierung  innerhalb(!) 
des Edit-Feldes durch die Maus unterstÅtzt.  Das Betriebssystem  setzt 
normalerweise  den Cursor beim AnwÑhlen eines Eingabefeldes  immer  an 
das Ende.  Ist eine direkte Positionierung mîglich, so verwandelt sich 
der Mauscursor Åber dem editierbaren Feld in einen Textcursor.

Alle erlaubten Zeichen fÅr Dateinamen und Pfade
-----------------------------------------------
... kann  man jetzt in die dafÅr vorgesehenen Eingabefelder  eingeben. 
Das  TOS  verhÑlt sich da SEHR merkwÅrdig,  zum einen  lÑût  es  viele 
legale Zeichen Åberhaupt nicht zu (z.B.  `›',  `-'),  auf der  anderen 
Seite  kann  man  dann aber die  `Åbelsten'  Zeichen  (`é',  `û'  ...) 
eingeben (Bacardi Feeling ...).

Spezielle Zeichen:
------------------
In  manchen  FÑllen muû man Zeichen eingeben,  die Åber  die  Tastatur 
nicht   so   einfach   (wenn   Åberhaupt)   erreichbar    sind.    Mit 
[SHIFT]+[Insert] kann man eine kleine Box auf den Bildschirm  zaubern, 
aus  der man das Zeichen mit der Maus anwÑhlen  kann.  Diese  Funktion 
kann nur aufgerufen werden,  wenn in das editierbare Feld alle Zeichen 
eingegeben werden dÅrfen.

GEM-Klemmbrett:
---------------
Innerhalb  der  editierbaren  Felder wird  auch  das  Clipboard  (GEM-
Klemmbrett)  unterstÅtzt,  d.h.  man kann z.B.  in anderen  Programmen 
Text  ausschneiden und dann spÑter im Dialog einfÅgen.  Um  das  Clip-
board  benutzen  zu kînnen,  muû dieses vorher auch  definiert  worden 
sein,  d.h.  das Betriebssystem muû wissen wo die Daten  abgespeichert 
werden sollen.  Hierzu muû die Environment-Variable `SCRAPDIR' gesetzt 
worden sein.  Benutzt man `Gemini', so geschieht das mehr oder weniger 
automatisch.  Andernfalls  kann  man diese  Variable  durch  spezielle 
Programme  (z.B.  `JCNBOOT' von Jens C.Neffe) setzen lassen.  Die  zu-
sÑtzliche Zeile sieht dann folgendermaûen aus:

SCRAPDIR=Pfad

Beispiel:

SCRAPDIR=C:\CLIPBRD

Folgende Clipboard-Funktionen werden unterstÅtzt:

[CTRL]-[X]     Schneidet  die komplette Zeile aus und speichert  diese 
               auf dem Klemmbrett.
[CTRL]-[C]     Kopiert die komplette Zeile ins  Klemmbrett,  d.h.  die 
               Zeile wird im Dialog nicht gelîscht.
[CTRL]-[V]     FÅgt  den Inhalt in die aktuelle Zeile  ein.  Der  alte 
               Inhalt wird dabei gelîscht.  Will man das unterdrÅcken, 
               so  kann  man  zusÑtlich  die  [SHIFT]-Taste   gedrÅckt 
               halten.

Wird bei den ersten beiden Funktionen zusÑtzlich [SHIFT] gedrÅckt,  so 
wird  der Inhalt des Klemmbretts nicht gelîscht und der  entsprechende 
Text  wird angehÑngt.  Dabei wird vorher ein  Zeilenvorschub  erzeugt, 
d.h.  die  einzelnen  Textausschnitte sind dann durch  einen  Vorschub 
voneinander getrennt.

History-Funktion:
-----------------
Oft  muû man Dinge eingeben,  die man vorher schon  einmal  eingegeben 
hat  (z.B.  Shell-Funktion),  und um einmal mehr  Fingerarbeit  einzu-
sparen  kann  man die letzten 20  Eingaben  wieder  herzaubern.  Diese 
Funktion  ist auch als `History' bekannt.  Jeder History-Eintrag  kann 
bis zu 40 Zeichen speichern,  doppelte EintrÑge in der History  werden 
unterdrÅckt (fÅr unsere Gemini-Freaks: `nohistdouble = TRUE').

[CTRL][Csr Up/Down]      geht die History durch.
[SHIFT][Csr Up/Down]     Die  in der aktuellen  Eingabezeile  stehende 
                         Zeichenkette  wird als Suchmuster  verwendet, 
                         d.h.   es   werden  hier  nur  die   Eingaben 
                         angezeigt   die   mit   dieser   Zeichenkette 
                         beginnen.

Die Leute,  die noch nicht mit einer History gearbeitet haben, sollten 
etwas  damit  experimentieren.  Weiterhin verhÑlt  sich  die  History, 
weitestgehend wie die in der Commandline-Shell `Mupfel'.

Viele   der  zusÑtzlichen  Editierfunktionen  (auûer  die   Mausunter-
stÅtzung)  sind  auch in Dialogen mit  fremden  Routinen  ansprechbar. 
Hier heiût es dann:  Ausprobieren!  Die MagicDials von Peter Hellinger 
werden Åbrigens optimal von Let 'em Fly!  unterstÅtzt.  Leider ist das 
ab der Version 3.0 (MagicTools) auch nicht mehr der Fall.


Die neuen Alert-Boxen
---------------------
Die ursprÅnglichen Alert-Boxen des Atari ST wurden Åberarbeitet, damit 
sie u.a. auch in den Genuû von Let 'em Fly! kommen. Die drei Knîpfe in 
der Alert-Box lassen sich neben dem oben beschriebenen Verfahren  auch 
noch  Åber F1-F3 anwÑhlen,  um so unnîtige Affengriffe  zu  vermeiden. 
Ebenso braucht man fÅr die TastenkÅrzel keine [ALT]-Taste zu  drÅcken. 
Weiterhin  sind diese Boxen nur noch so groû,  wie sie  wirklich  sein 
mÅssen damit der Text hineinpaût  und es lassen sich zudem neue  Icons 
beim  Programmstart  nachladen.   Die  entsprechende  Datei  muû  dann 
LET_ICON.RSC  heiûen  und sich im selben Verzeichnis  wie  das  Haupt-
programm  befinden.  Der  Aufbau der Datei ist im  Programmer's  Guide 
beschrieben.
Die  GEM/1 und GEM/2 Icons liegen Let 'em Fly!  bei (s.o.) und  mÅssen 
nur ins entsprechende Verzeichnis kopiert und umbenannt werden.


                      Das Konfigurationsprogramm
                      ==========================

Nach  dem  Start des Programms (LET_CONF.PRG/ACC/CPX) gelangt  man  in 
ein MenÅ ...

In  der  obersten Zeile steht die Version  von  Let 'em Fly!  die  der 
Benutzer zur Zeit installiert hat.  Es wird auch zwischen `normal' und 
`light' unterschieden. In der zweiten Zeile steht mein Name (Uii!).
In  der  Mitte  ist ein rechteckiger Kasten zu  finden,  wo  sich  die 
Schalter  zum Konfigurieren befinden.  Da es inzwischen so  viele  ge-
worden  sind und eigentlich alle auch ihre Daseinsberechtigung  haben, 
kann   man   mit  dem  Slider  auf  der  rechten  Seite   die   Punkte 
`durchfahren'.  Wie der erfahrene Let 'em Fly! User schon erkannt hat, 
hat  sich  das Programm seit Version 1.12  etwas  verÑndert.  Auf  den 
ersten  Blick sieht es vielleicht etwas  unÅbersichtlich  aus,  jedoch 
wurden die Schalter nach einem neuen Kriterium sortiert.  Nun sind die 
wichtigen  Schalter  auf  der ersten und zweiten Seite  und  der  Rest 
liegt dahinter. Damit sollte man schneller zum Ziel kommen.
Benutzt man das PRG/ACC,  so kann man diese Box auch Åber die Tastatur 
bedienen. Mit [CsrUp] und [CsrDown] kann man auch den Slider bedienen. 
DrÅckt  man zusÑtzlich [SHIFT],  so wird  nicht  zeilenweise,  sondern 
seitenweise  geblÑttert.  Beim CPX-Modul ist das aus  programmiertech-
nischen GrÅnden leider nicht mîglich.

Am unteren Rand befinden sich vier Buttons:

- Info    Zeigt eine kleine Informationsseite an.

- Save    Sichert  die  Einstellungen permanent im  eigentlichen  Pro-
          gramm.  Es  erscheint  darauf hin eine  Auswahlbox,  wo  das 
          Programm  (LETEMFLY.PRG oder LET_LGHT.PRG) angewÑhlt  werden 
          kann.

- Cancel  Alle  Einstellungen werden rÅckgÑngig gemacht und  das  Kon-
          figurationsprogramm wird verlassen.

- OK      Die  Einstellungen  werden Åbernommen,  jedoch  nicht  abge-
          speichert,  d.h.  beim  nÑchsten Neustart des Rechners  sind 
          diese  futsch.  Die  gleiche  Wirkung hat  der  Closer  oben 
          links.

Nun  aber zu den Schaltern bzw.  Reglern.  Die Schalter  stellen  sog. 
Pop-Up MenÅs dar,  d.h. ein Klick auf den Schalter zaubert eine kleine 
Auswahlbox  hervor.  Klickt  man auf den  erklÑrenden  Text,  so  wird 
zwischen den beiden Mîglichkeiten hin- und hergeschaltet.

- Let 'em Fly!      öber diesen Schalter lÑût sich  Let' em Fly!  ein- 
                    bzw.   (komplett)  ausschalten.   Die   restlichen 
                    Einstellungen sind damit ohne Wirkung.

- Alert-Boxes       Hier lassen sich die neuen Alert- und  Error-Boxen 
                    ein-/ausschalten.

- Key Dials         Aktiviert/Deaktiviert  die   Tastaturbedienbarkeit 
                    der Dialogboxen.

- Extended Editor   Dieser Schalter ist fÅr die zusÑtzlichen  Editier-
                    funktionen da.

- Flying Dials      Mit diesem Schalter werden die Flugroutinen  akti-
                    viert. Die Dialoge kînnen jetzt fliegen (Uii!).

- Fly Type          Hier wird bestimmt, wie die Boxen fliegen:
                    Solid:    in Echtzeit, d.h. sie folgen der Mausbe-
                              wegung.  Ohne  Blitter  und  ohne  Bild-
                              schirmbeschleuniger  ist  diese  Version 
                              etwas trÑge.
                    Hollow:   Hier  wird  mit einem  einfachen  Rahmen 
                              gearbeitet.

- Ghost Flights     Will  man die Funktion der rechten  Maustaste  fÅr 
                    den Flugmodus umkehren (invert),  so kann das  mit 
                    diesem Schalter geschehen.

- Jumpin' Dials     Wer nicht mîchte, daû die Dialoge zur Mausposition 
                    geflogen  kommen,  wenn man auûerhalb des  Dialogs 
                    klickt,   kann  hier  diese  Funktion  abschalten. 
                    (NatÅrlich  kann  man  die  Funktion  auch  wieder 
                    einschalten)

- Save Position     Mit diesem Schalter kann man einstellen,  ob  sich 
                    Let 'em Fly!   die  Position  der  Dialoge  merken 
                    soll.

- Send Redraw       Bei  manchen Programmen gibt es Probleme nach  dem 
                    lîschen der Dialogbox,  d.h.  der Hintergrund wird 
                    nicht wieder richtig hergestellt (z.B.  TC-Filese-
                    lector,   Adimens).   Ist  diese  Funktion  einge-
                    schaltet,  so  wird dem gerade laufenden  Programm 
                    gesagt,  daû  nach  dem Lîschen der Box  der  ent-
                    sprechende Bildschirmausschnitt neugezeichnet wer-
                    den soll.

- VSCR Support      Dieses  megagigantische KÅrzel VSCR  heiût  nichts 
                    anderes,  als  Virtual SCReen (der Ausschnitt  des 
                    Bildschirms  ist ungleich dem Gesamtmaû des  Bild-
                    schirms,  auch  mit  der  Fenstertechnik  zu  ver-
                    gleichen)   und  kennzeichnet  ein  Verfahren   um 
                    anderen  Programmen mitteilen zu  kînnen,  welcher 
                    Bildschirmausschnitt  denn  nun  gerade   sichtbar 
                    ist.  Ist  dieser  Punkt  eingeschaltet,  so  wird 
                    dieses  Verfahren unterstÅtzt.  Einen  nicht  vor-
                    handenen  VSCR erkennt  Let 'em Fly!  automatisch. 
                    Vertreter dieser Gattung ist z.B.  `BigScreen 2.0' 
                    von Julian Reschke.
                    Was macht nun Let 'em Fly!  in diesem  Fall?  Nun, 
                    die  Dialogboxen werden immer im  sichtbaren  Aus-
                    schnitt zentriert.  Die Alert-Boxen jedoch  werden 
                    immer,  unabhÑngig von diesem Schalter,  im sicht-
                    baren Bereich zentriert.

- Form Grow/Shrink  Schaltet  die Grow-/Shrinkboxen beim Zeichnen  von 
                    Dialogboxen  ein bzw.  aus.  Somit wird der  Bild-
                    schirmaufbau erheblich beschleunigt,  jedoch  geht 
                    das  'Intuitiv-sensitive' verloren.  Das  KAOS-TOS 
                    wirbt Åbrigens mit diesem Feature.

- Graf Grow/Shrink  Schaltet  auch  die restlichen Grow-  und  Shrink-
                    boxen aus,  z.B.  wenn ein Programm von Gemini aus 
                    gestartet wird.

- Fly Delay         Damit man in die Buttons `reinfahren'  kann,  ohne 
                    daû der Dialog vorher anfÑngt zu fliegen, kann man 
                    hier  eine  Verzîgerung einstellen  (0  steht  fÅr 
                    keine  Verzîgerung).  Die persînliche  `Note'  er-
                    reicht man durch Probieren.

- Shortcut Disp.    Mit  diesem Schalter kann man  bestimmen,  ob  die 
                    Shortcuts  durch  Striche oder  durch  farbig  ge-
                    druckte   Buchstaben  kenntlich   gemacht   werden 
                    sollen.  NatÅrlich  ist  das  nur  fÅr  die  Farb-
                    auflîsungen interessant,  im monochromen Modus hat 
                    dieser  Schalter keine Wirkung.  Hier  wird  immer 
                    der Strich unter den Buchstaben benutzt.

- Shortcut Col.     öber  diesen Schieberegler kann  den  TastenkÅrzel 
                    eine  Farbe zugewiesen werden,  z.B.  ist  in  der 
                    mittleren Auflîsung rot besser auszumachen.  Steht 
                    der Regler auf ganz links,  so werden zwar  Tasten 
                    vergeben, jedoch wird kein Strich gemalt.

- Alert-Icon        Hier kann den Icons in den Alert-Boxen eine  Farbe 
                    zugewiesen werden.

- Alert-Border      Um das Individuelle noch weiter zu steigern,  kann 
                    hier  die  Rahmendicke (normal ist 1)  der  Alert-
                    Boxen eingestellt werden.


...  Hier stand mal etwas zur light-Version von Let 'em Fly!. Zur Zeit 
gibt  es aber keine light-Version,  und deshalb steht hier  auch  nix. 
Bei  der light-Version handelte es sich Åbrigens um  eine  abgespeckte 
Version.


              (bekannte) Probleme mit anderen Programmen
              ==========================================

   - Der  Universal  Item  Selector (UIS III)  muû  nach  Let 'em Fly! 
     gestartet werden, da er sonst wieder ausgeklinkt wird. Das dÅrfte 
     fÅr alle Programme gelten, die kein XBRA benutzen.
   - Der Little Green Selector funktioniert mit Let 'em Fly!  nicht so 
     richtig,  sowohl  mit  dem  Fliegen als auch  mit  den  Tastatur-
     Shortcuts  gibt es Probleme.  Diese Probleme sind aber im LGS  zu 
     suchen!  Der LGS hÑngt z.B. im ikbdsys drin, bloû wofÅr (SINN!?). 
     Dort  bringt  er anscheinend die  Tastencodes  vollkommen  durch-
     einander,  so  daû  nur  der LGS damit etwas  anfangen  kann  (na 
     schîn).  Warum benutzt der LGS nur im GEMDOS-Trap XBRA und  sonst 
     nirgendswo?  Ich weiû ja nicht was der freundliche  Atari-HÑndler 
     empfehlt, ich empfehle Selectricø als File-Selector.
   - Da  die  MagicDials von Peter Hellinger  die  benutzerdefinierten 
     Objekte  und Buttons nicht `konventionell' behandeln,  wird  beim 
     Anwenden  der  Tastenkombination [ALT]+[Tab] (und  auch  bei  der 
     Umkehrung  mit [SHIFT]) der Button nicht korrekt  gezeichnet.  Zu 
     AbstÅrzen kann es jedoch nicht fÅhren.
   - Bei  MiNT-Versionen  kleiner-gleich 0.91 kann  sich  Let 'em Fly! 
     nicht   installieren.   Das  Problem  haben  aber   auch   andere 
     Programme.
   - Wird ein Dialog in NeoDesk mit [RETURN] beendet,  so verschwindet 
     er nicht.
   - Harte Probleme gibt es auch noch mit Diskus 2.x.  Beim Darstellen 
     einiger  Dialogboxen  meint  es  einfach  abstÅrzen  zu   mÅssen. 
     Abhilfe: `Flying Dials' ausschalten.


                           Trappelshouting
                           ===============

Let 'em Fly!  klinkt  sich in den TRAP #2 (AES/VDI) und den  TRAP  #13 
(BIOS)  ein und benutzt dazu die XBRA-Kennung `LTMF'.  Zudem wird  ein 
sog.  Cookie-Jar installiert (benutzt auch die Kennung `LTMF'). Dieser 
zeigt auf die folgende Struktur:


typedef struct
{
    unsigned int    version;    /* BSD format       */
    struct
    {
        unsigned light  : 1;    /* light version (read) */
        unsigned        : 1;    /* reserved             */
        unsigned jumpin : 1;    /* jumpin' dials        */
        unsigned flyswi : 1;    /* conf. flymode switch */
        unsigned vscr   : 1;    /* virtual scr. support */
        unsigned center : 1;    /* center mode          */
        unsigned keys   : 1;    /* key handling         */
        unsigned edit   : 1;    /* extended editor      */
        unsigned redraw : 1;    /* send redraw message  */
        unsigned flytyp : 1;    /* solid/hollow fly     */
        unsigned fly    : 1;    /* flying on/off        */
        unsigned alert  : 1;    /* Alerts/Errors on/off */
        unsigned v_mem  : 1;    /* use virtual memory   */
        unsigned f_grow : 1;    /* grow/shrink boxes    */
        unsigned g_grow : 1;
        unsigned bypass : 1;    /* ON/OFF highest prio  */
    } config;
    char    *vpath;             /* path for v-mem   */
    void    cdecl   (*di_fly)(OBJECT *tree);    /* fly routine */
    void    cdecl   (*obj_clsize)(OBJECT *tree, int obj,
                                   int *x, int *y, int *w, int *h);
    int     cdecl   (*do_key)(int key, int kshift); /* User Keys */
    int     cdecl   (*init_keys)(OBJECT *tree);
    int     cdecl   (*lookup_key)(int key, int kshift);
    int     cdecl   (*di_moveto)(OBJECT *tree, int mx, int my);
    int     cdecl   (*di_center)(OBJECT *tree);
    int     ucol;   /* underscore color */
    int     aicol;  /* alert icon color */
    int     aframe; /* alert frame size */
    int     ccol;   /* character color  */
    int     flydelay;   /* delay before flying (form_do()-only) */
    int     cdecl   (*hist_insert)(char *string);
    char    cdecl   (*ins_spcchar)(void);
} LTMFLY;


`bypass'  entspricht Bit-No. 0 und eine 1  schaltet  Let 'em Fly!  aus 
und  eine  0  schaltet es ein.  Alle anderen  Bits  funktionieren  um-
gekehrt,  d.h.  1  fÅr  an  und 0 fÅr  aus,  also  nach  dem  gesunden 
Menschenverstand.
Einige  C  Compiler legen Bitfelder Åbrigens anders  als  Turbo-C  ab, 
daher:  Vorsicht.  `cdecl' heiût in Turbo-C, daû die ParameterÅbergabe 
auf  dem Stack erfolgt.  Eine Anpassung an andere (C-)Compiler  sollte 
kein groûes Problem darstellen.

`v_mem'  und `*vpath' sind noch nicht benutzt ('vpath' zeigt zur  Zeit 
auf  einen String der LÑnge Null),  `light' dient zum Feststellen  der 
Version  und  ist Read-Only!  Ebenso sind  die  von  Let 'em Fly!  be-
reitgestellten Funktionen Read-Only!

V1.17 Info:
-----------
öber  di_moveto()  kann man auch abfragen,  ob die  Dialogbox  fliegen 
kann,  oder ob ein Redraw ausgefÅhrt werden muû.  Hier zwei  nÅtzliche 
#defines ...

/* some useful defines ... */

#define fly_check(tree)     di_moveto(tree, -1, 0)
#define redraw_check(tree)  di_moveto(tree, -2, 0)

di_moveto()  sollte  nach  dem bekannten  Verfahren  in  der  LTMF_LIB 
(wurde mit der Version 1.14 vertrieben) eingebunden werden.  Ansonsten 
kann ich nur nochmal auf die Zusatzdokumentation verweisen.


                              Ausleitung
                              ==========

Wie  schon gesagt wollte ich nur sehen wie schnell das VDI  sein  kann 
und irgendwie ist dann dieses Programm entstanden.
Die  Flugroutinen waren eigentlich nur fÅr eigene  Programme  gedacht, 
aber in der ST-Computer 6/91 hat Robert Tolksdorf gezeigt,  daû man so 
etwas prinzipiell auch resident installieren kann,  jedoch haben beide 
Programme  nichts  gemeinsam,  auûer daû wir beide auf  die  form_do() 
Sourcen von D.R. zurÅckgegriffen haben.
Der Rest ist eher aus der Not entstanden.  Dan Wilga hat ein  Programm 
mit  dem  Namen `FormDoIt!' geschrieben,  welches  es  ermîglicht  die 
Dialoge  auch mit der Tastatur zu bedienen und zusÑtzlich noch  einige 
Editierfunktionen  bereitstellte.  Leider ist seine form_do()  Routine 
nicht 100% kompatibel zum Original und es gab besonders bei  TOUCHEXIT 
Objekten   Probleme.   Zudem  benutzt  er  die  Line-A  Routinen   zur 
Grafikausgabe,  welche in der heutigen Zeit nicht mehr benutzt  werden 
sollten.  Auch  `FormDoIt!' hat mit Let 'em Fly!  nur so viel zu  tun, 
daû  ich  viele  Funktionen  und  das  Prinzip  auch  in  Let 'em Fly! 
implementiert habe,  jedoch geht mein Programm wesentlich  weiter,  da 
es  a)  nicht nur form_do() ersetzt,  b) kein Line-A  benutzt  und  c) 
wesentlich `intelligenter' ist.
Was noch zu sagen ist,  daû sog.  `Schweineprogramme' nur bis zu einem 
gewissen Grad unterstÅtzt werden.  Unter `Schweineprogrammen' verstehe 
u.a.  ich Programme, die sich nicht an die Regeln des AES halten. Bei-
spielsweise  kennt UnLZH kein appl_init/exit,  OBWOHL es AES  Routinen 
benutzt.  Das Gleiche gilt auch fÅr PFX-PAK.  Weiterhin gibt es  immer 
noch  Programme,  welche kein XBRA verwenden.  Das betrifft in  erster 
Linie  Programme  aus  den USA.  XBRA ist  inzwischen  von  Atari  zum 
Standard  erhoben worden und sollte daher von JEDEM  Programm  benutzt 
werden,  welches Vektoren verbiegt. In Let 'em Fly! sind zwar ziemlich 
viele  Sicherheitsabfragen  enthalten,  aber alles kann man  nun  auch 
nicht abfragen.


Credits
-------
An  dieser Stelle will ich mich trotzdem bei den  beiden  o.g.  Leuten 
bedanken, da sie gezeigt haben, daû solche Geschichten mîglich sind.
FÅr  das  Design  der Dialogboxen innerhalb und  auûerhalb  (CPX)  von 
Let 'em Fly! wurde Interface von Olaf Meisiek verwendet.
Vergessen  will  ich  hier mal auch nicht die  drei  (ist  einer  mehr 
geworden) Betatester (Thanx).  Einen davon,  dem Martin  Kîhling,  muû 
ich  aber  jetzt nochmal getrennt danken,  da er auch  schon  im  non-
Betatester-Status viele Fehler und Unschînheiten gefunden hat.



Meine Adresse ... oder Tomaten, Drohbriefe etc. bitte an:

Oliver Scheel
Rothehausstr. 28
W-5000 Kîln 30

Und  fÅr  die Leute,  die eine Piepmaschine (Modem) ihr  Eigen  nennen 
kînnen oder auf Kosten der Uni den ganzen Tag im InterNet hÑngen:

MausNet: Oliver Scheel @ K
EMail:   Oliver_Scheel@k.maus.de

Let 'em Fly!     Man fliegt nicht mehr ohne ...




----
RÑchzschreipfÑler (c) 1991 by Oliver Scheel

