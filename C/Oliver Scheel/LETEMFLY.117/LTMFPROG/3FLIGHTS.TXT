                           Three Flights Up
                           ----------------


              The new Programmer's Guide to Let 'em Fly!

                       (includes version 1.17)

                         Januar/Februar 1992

                     (c) 1991-92 by Oliver Scheel

             ... this guide (however) goes Freaky Deaky!


                             Introduction
                             ============

Tja,  nun ist es soweit,  der komplett Åberarbeitete Guide ist da.  Er
soll  dazu  dienen  die programmiertechnischen  Mîglichkeiten  in  Zu-
sammenhang mit Let 'em Fly!  nÑherzubringen.  Um jedoch hochgesteckten
Erwartungen entgegenzuwirken:  Er kann das Gehirn des einzelnen  nicht
ersetzen,   also   nichts  fÅr  den  Ex  US-PrÑsidenten  Ronny   ("The
President's brain's missin'!").

Nun  denn,  fÅr diesen Guide sind C-Kenntnisse (und  nach  Mîglichkeit
auch  Assemblerkenntisse) erforderlich.  Eine UnterstÅtzung  von  GFA-
Basic  (oder Omikron-Basic) wird es von meiner Seite her nicht  geben,
da  ich noch nie mit Basic auf dem ST gearbeitet habe (ich stelle  mir
es  aber ziemlich kompliziert vor) und natÅrlich  gewisse  Abneigungen
gegen  Basic  auf  dem  ST habe.  Da  eine  echte  strukturierte  Pro-
grammierung unter Basic nicht mîglich ist (da kann der Herr  Ostrowski
noch  so  viel `while's und `case's einbauen),  dÅrfte  besonders  der
Zugriff auf die Struktur nicht ganz einfach sein.


Der Lieferumfang und die Kondome (Ñh, Konditionen)
--------------------------------------------------
Dieses Paket ist Public Domain,  d.h. es darf frei kopiert und benutzt
werden.  Der  Vertrieb  Åber  einen PD-Versand ist  nur  mit  schrift-
licher(!)  Genehmigung meinerseits  mîglich.  Zuwiderhandlungen  werde
ich strafrechtlich verfolgen.

Zu `Three Flights Up' gehîren folgende Dateien:

     - 3FLIGHTS.TXT      Dieser Text
     - CHANGES.TXT       Die komplette Changes-Liste von Let 'em Fly!

     - LTMF_LIB.C        Eine Library fÅr C
     - LTMF_LIB.H        Dazu das Header-File
     - DO_SAMPL.C        Ein form_do() Sample

Das  Paket darf nur komplett mit diesen Dateien weitergegeben  werden!
Es  ist  erlaubt die *.C Dateien fÅr die  eigenenen  Anforderungen  zu
verÑndern.  Es  ist  jedoch NICHT erlaubt  diese  verÑnderten  Dateien
weiterzugeben.  FÅr  Fehlerkorrekturen  habe ich natÅrlich  immer  ein
offenes Ohr.


                       First Flight (Internes)
                       =======================

Na, wo hÑngen wir denn Åberall drin?
------------------------------------
Let 'em  Fly!  verbiegt den TRAP #2 (AES/VDI) und den TRAP #13  (BIOS)
und  benutzt  dazu die XBRA-Kennung `LTMF'.  Ansonsten wird  noch  ein
Cookie-Jar installiert (s.u.).

Der Werdegang einer Dialogbox bei installiertem Let 'em Fly!
------------------------------------------------------------

Normalerweise  wird in einem Programm eine Dialogbox nach dem  folgen-
den Schema abgearbeitet:

     [...]

     form_center(dialog, &x, &y, &w, &h);
     form_dial(FMD_START, 0, 0, 0, 0, x, y, w, h);
     objc_draw(dialog, ROOT, MAX_DEPTH, x, y, w, h);
     choice = form_do(dialog, 0);
     form_dial(FMD_FINISH, 0, 0, 0, 0, x, y, w, h);

     [...]

Let 'em Fly!  hÑngt in allen eben benutzten Funktionen drin und mischt
mehr oder weniger krÑftig mit. Da dies die grundlegenden Funktionen im
Dialogbox-Handling  sind,  werden die EinflÅsse von  Let 'em Fly!  auf
diese Funktionen jetzt im einzelnen beschrieben:

form_center(dialog, ...)
------------------------
Hier  wird  der Dialog normalerweise  zentriert.  Bei  eingeschaltetem
`Save   Position'  werden  nur  die  Tree-Koordinaten  mit   Korrektur
zurÅckgegeben.  Ist  der  `VSCR-Support' aktiv,  so wird die  Box  von
Let 'em Fly! im gerade sichtbaren Ausschnitt zentriert.

form_dial(FMD_START, ...)
-------------------------
öber  diese Funktion sichert Let 'em Fly!  den  Dialogbox-Hintergrund.
Der Åbergebene Bereich sollte daher mîglichst genau angegeben  werden.
Wird  eine  LTMF-Version  ab 1.14 benutzt,  so  kann  man  auch  einen
grîûeren  Ausschnitt Åbergeben,  Let 'em Fly!  transformiert dann  bei
Bedarf die Koordinaten. `form_center()' liefert bei 'normalen' Dialog-
boxen richtige Ergebnisse,  Probleme gibt's z.B. bei SHADOWED Ones. Im
Zweifelsfall lieber ein biûchen mehr angeben.
Konnte der Hintergrund nicht gesichert werden,  so wird die  originale
Routine aufgerufen.

objc_draw(dialog, ...)
----------------------
Let 'em Fly! setzt hier nur einige interne Flags.

form_do(dialog, ...)
--------------------
Hier greift Let 'em Fly!  in die Vollen.  Zwei AES-Funktionen,  die in
form_do() benutzt werden (und form_do() selbst natÅrlich  auch),  wur-
den  komplett  neu programmiert und  ins  Betriebssystem  eingebunden:
`form_keybd()'  und  `objc_edit()'.   Bei  selbstgebauten   form_do()-
Routinen  sollte  man  daher Gebrauch  von  diesen  beiden  Funktionen
machen,  insbesondere  von objc_edit(),  da hier u.a.  der  Clipboard-
Support,  die History und die Special Character Box integriert wurden.
Auch  sollte  man  nicht zuviele Tastenkombinationen  vor  dem  Aufruf
herausfiltern.
Innerhalb  von  `form_do()'  wird  dann  u.a.   der  Objektbaum   nach
Tastenkombination durchgescannt.  Diese (rekursive) Funktion  arbeitet
wie folgt:
     Das  entsprechende  Objekt muû  entweder  SELECTABLE,  EXIT  oder
     TOUCHEXIT  sein  und darf nicht DISABLED oder  geHIDETREEd  sein.
     Ist  der  Parent geHIDETREEd,  so werden die  Children  ebenfalls
     nicht  durchsucht.  Jetzt wird geprÅft,  ob sich ein Text in  dem
     Objekt  befindet.  Falls  ja,  dann wird dieser Text  nach  einer
     freien  Tastenkombination abgesucht.  Falls  nicht,  dann  schaut
     Let 'em Fly!  nach,  ob das nÑchste Objekt in der Liste(!)  einen
     Text   enthÑlt  und  dieses  Objekt   nicht   SELECTABLE,   EXIT,
     TOUCHEXIT,  DISABLED oder geHIDETREEd ist.  Dieser Text wird dann
     zur  Zuweisung der Tastenkombination  benutzt.  Die  Y-Koordinate
     des Ersatzobjektes muû auf +/- 3 Pixel Åbereinstimmen.  Daher ist
     darauf  zu achten,  daû die Dialogbox richtig sortiert  ist.  Der
     Text  des  `Abbruch'-Buttons  sollte mit  einem  der  oben  schon
     aufgefÅhrten Åbereinstimmen.  Zu beachten ist,  daû es auch  eine
     HELP-Taste geben kann.  Weiterhin ist es ab Version 1.10  mîglich
     die Tasten gezielt zu vergeben (s.u.).
Ebenso  wurden  in  `form_do()' das `Fly Delay'  (ab  V1.17)  und  die
direkte Cursor-Positionierung implementiert.
Let 'em Fly!  lîscht  ab Version 1.17 vor dem Eintritt in  den  Event-
Loop den Tastaturbuffer.  Die Let 'em Fly!  Funktion ist Åbrigens sehr
kompatibel  zum  Original,  da sie auf den  (inzwischen  îffentlichen)
D.R. form_do() Sourcen basiert.

form_dial(FMD_FINISH, ...)
--------------------------
Das ist das GegenstÅck zu FMD_START. Hier wird dann der Bildschirmaus-
schnitt  wieder  korrekt hergestellt.  Konnte der  Hintergrund  vorher
nicht  gesichert  werden,  so  wird hier  ein  Redraw  ausgelîst.  Die
Hauptapplikation wird somit aufgefordert den Bildschirmausschnitt wie-
der herzustellen.
Die  FMD_STARTs und FINISHes sind gegen die untere (0) und  obere  (6)
Grenze  abgesichert.  NatÅrlich sollte man darauf achten,  daû  es  zu
jedem FMD_START auch nur ein entsprechendes FMD_FINISH (und umgekehrt)
gibt.  Ansonsten kann man Let 'em Fly!  durcheinander bringen.  Werden
zuviele  FINISHes aufgerufen,  so wird ein entsprechender  Redraw  er-
zeugt (s.a. Third Flight).


Steuerung von Let 'em Fly! Åber die Extended Objects
----------------------------------------------------

Ab  Version  1.10  werden  die  erweiterten  Objekttypen  benutzt,  um
Let 'em Fly!  innerhalb  von Dialogen `steuern' zu kînnen.  Es  kînnen
jetzt  so bei einigen Dialogen Funktionen abgeschaltet werden und  die
Tasten  gezielt  vergeben werden.  Der Extended Object Type  im  ROOT-
Objekt  muû ein Magic enthalten,  damit  Let 'em Fly!  weiû,  daû  die
restlichen  Werte des Dialogs gÅltig sind.  Damit  sollen  Kollisionen
mit fremden Dialogroutinen vermieden werden.
öber  die Objekt-Flags 10 und 11 im ROOT-Objekt kînnen  die  Key-Dials
und  der Extended Editor global (also fÅr diesen Dialog)  abgeschaltet
werden.  Das  Objekt-Flag  14  erzwingt  ein  Zentrieren  des  Dialogs
(interessant  bei eingeschaltetem `Save Position').  öber das  Objekt-
Flag  12  kann ein Dialog flugunfÑhig gemacht  werden.  Das  ist  dann
interessant,  wenn  ein  Programm mit den  fliegenden  Dialogen  nicht
zurrechtkommt.
Das Objekt-Flag 15 wird Åbrigens von Let 'em Fly!  benutzt,  um  einen
bereits  zentrierten  Dialog zu markieren.  Dies  ist  unabhÑngig  vom
Magic  und  kann nur durch den Schalter  `Save  Position'  unterdrÅckt
werden.
FÅr  die  restlichen Objekte im Dialog wird das Extended  Object  Byte
dazu  benutzt um Tasten gezielt zu vergeben.  Es wird  dabei  zwischen
normalen  Tasten (A-Z,  0-9) und  Sondertasten  (HELP,  UNDO,  F1-F10)
unterschieden.  Weiterhin  kann man bestimmen,  ob das nÑchste  Objekt
fÅr die Tastenvergabe benutzt werden soll.
Die  Objekt-Flags 10 und 11 haben die gleiche Bedeutung wie  im  ROOT-
Objekt, sind jedoch nur lokal wirksam.

So,  und hier die genaue Belegung der Bits and Bytes (die Flags werden
von 0, entspricht Bit 0, ab an gezÑhlt!):

ROOT-Objekt
-----------
- Extended Object Byte (erweiterter Objekttyp)
     MAGIC 0x89 (137)    Sagt Let 'em Fly!,  daû die restlichen  Werte
                         im Dialog gÅltig sind.
     GLOBOFF 0x71 (113)  Hiermit wird Let 'em Fly!  fÅr diesen  Dialog
                         komplett(!)  ausgeschaltet.  Das Byte  stimmt
                         mit dem in FormDoIt! benutzten Åberein.

- Objekt-Flags
     Flag 10   Schaltet den Extended Editor global aus.
     Flag 11   Schaltet die Key Dials global aus.
     Flag 12   Macht den Dialog flug_un_fÑhig.
     Flag 13   Rastet  den  Dialog  nach dem Fliegen  wieder  auf  das
               ursprÅngliche Byte-Alignment ein.
     Flag 14   Erzwingt  ein Zentrieren des Dialogs (entspricht  `Save
               Position' OFF).

restliche Objekte
-----------------
- Extended Object Byte (erweiterter Objekttyp)
     Das  Byte wird in zwei Nibbles († 4 Bit)  unterteilt.  Das  obere
     Nibble konfiguriert das untere Nibble.  Eine kleine Grafik dÅrfte
     hier hilfreich sein:

     +---+---+---+---+----------------+
     | 0 | F | S | T | Key Identifier |
     +---+---+---+---+----------------+
           ^   ^   ^   ^
           |   |   |   +----  Identifiziert  die  Taste.   Ist  dieses
           |   |   |          Nibble nicht gesetzt,  also gleich Null,
           |   |   |          so vergibt Let 'em Fly!  die Taste  nach
           |   |   |          dem  herkîmmlichen  Verfahren.   Besitzt
           |   |   |          dieses Nibble einen Wert (1-15), so wird
           |   |   |          damit die Position(!) der Taste im  Text
           |   |   |          angegeben.  Vorsicht: Der ZÑhler beginnt
           |   |   |          mit  1 (also nicht mit 0)  und  fÅhrende
           |   |   |          Spaces werden mitgezÑhlt!
           |   |   |
           |   |   +--------  Zeigt  an,  daû das nÑchste  Objekt  zur
           |   |              Tastenvergabe  benutzt werden  soll.  Es
           |   |              muû kein Key Identifier verhanden  sein.
           |   |              In  diesem Fall sucht sich  Let 'em Fly!
           |   |              die Taste selbst aus.
           |   |
           |   +------------  Dieses Bit sagt,  daû dieses Objekt  mit
           |                  einer  Sondertaste belegt  werden  soll.
           |                  Der   Key  Identifier  muû  dann   einen
           |                  gÅltigen Wert haben:
           |                        1 - UNDO
           |                        2 - HELP
           |                        3 - F1
           |                         [...]
           |                       12 - F10
           |                  Weiterhin wird das Objekt noch nach  dem
           |                  Let 'em Fly! Algorithmus mit einer Taste
           |                  belegt.   Man  kann  es  aber  Åber  das
           |                  ObFlag 12 unterdrÅcken.
           |
           +----------------  öber  dieses  Bit  wird  das  Flugobjekt
                              festgelegt. Eine Kombination mit den an-
                              deren  beiden Bits ist  nicht  sinnvoll.
                              Das untere Nibble (Key Identifier)  sagt
                              dann   aus,   ob  das   Flugobjekt   Ex-
                              clusivrechte besitzt (d.h.  es kann  nur
                              Åber  dieses Objekt  `geflogen'  werden)
                              oder nicht. Dabei gilt:
                                   0 -  Exclusiv
                                   1 -  Inclusiv (d.h.  Background und
                                        Flugobjekt)

     Zu   beachten   ist,   daû  auch   weiterhin   die   automatische
     Tastenvergabe aktiv ist.  Wird UNDO Åber die ExObTypes  vergeben,
     so ist es gegen eine weitere automatische Vergabe geschÅtzt.  Bei
     HELP ist dies nicht der Fall!

     Die restlichen Bits sind reserviert und sollten auf Null  gesetzt
     sein.

     Special ab V1.17:   Ab  dieser  Version wird auch  das  FormDoIt!
                         Byte  (0x71  /  113)  zur  UnterdrÅckung  der
                         Tastenvergabe   fÅr  das   jeweilige   Objekt
                         unterstÅtzt.  Da dieser Wert eh sinnlos  ist,
                         gibt es daher auch keine Kollisionen.

- Objekt-Flags
     Flag 9    Zeigt an,  daû bei diesem Objekt eine  sog.  EXAPPLBLK-
               Struktur benutzt wurde.  Die Struktur wird weiter unten
               beschrieben.
     Flag 10   Schaltet den Extended Editor fÅr dieses Objekt aus.
     Flag 11   Schaltet  die Key Dials fÅr dieses Objekt  (und  dessen
               Unterobjekte!) aus.
     Flag 12   Wird  eine  Taste mit  einer  Sondertaste  (z.B.  UNDO)
               belegt,   so   wurde  trotzdem  noch   eine   `normale'
               Tastenkmbination  dafÅr  herausgesucht.   Durch  setzen
               dieses Flags kann man es (erfolgreich) verhindern.

Vorsicht: FÅr   Kollisionen  bei  der  Tastenvergabe  ist   der   Pro-
          grammierer,  bzw.  der VerÑnderer des RSC-Files selbst  ver-
          antwortlich!


NatÅrlich kann man auch `fremde' RSC-Files modifizieren, jedoch sollte
man hier sehr vorsichtig sein.  Vielleicht werden die Bits ja auch vom
Programm selbst benutzt und verÑndert.
Weiterhin ist es selbstverstÑndlich,  daû verÑnderte RSC-Files  grund-
sÑtzlich NICHT weitergegeben werden dÅrfen!!! Falls ich solchen FÑllen
auf die Spur kommen sollte,  so bekommt derjenige erheblichen(!) érger
von mir!

AbhÑngigkeiten zwischen Schalter, ob_flags und Funktionen
---------------------------------------------------------

     Function       | Switch            | ob_flags (only with MAGIC)
     ---------------+-------------------+---------------------------
     form_do()      | Let 'em Fly ON/OFF| ExObType Value 0x71 (113)
                    | Key Dials         | Flag 11 / ExObType 0x71
     form_dial()    | Flying ON/OFF     | Flag 12 (ROOT-only)
                    | Grow/Shrink       | ---
                    | Send Redraw       | ---
     form_center()  | Save Position     | Flag 14
                    | VSCR Support      | no flag available yet
     form_alert()   | Alert/Error-Boxes | ---
     form_error()   | Alert/Error-Boxes | ---
     form_keybd()   | Extended Editor   | Flag 10 (ROOT-only)
     objc_edit()    | Extended Editor   | Flag 10
     appl_exit()    | - no switch -     | ---
     ---------------+-------------------+---------------------------
     di_fly()       | Flying ON/OFF     | Flag 12 (ROOT-only)
                    | Solid/Hollow Fl.  | ---


Die EXAPPLBLK-Struktur
----------------------
Um Benutzerdefinierte Objekte ins Resource einzubinden,  muû man  eine
spezielle Struktur benutzen (USERBLK),  die weitere Informationen  fÅr
das AES enthÑlt.  Die EXAPPLBLK-Struktur ist eine erweiterte  USERBLK-
Struktur und sieht wie folgt aus:

typedef struct
{
        int cdecl        (*ub_code)(struct __parmblk *parmblock);
        union obspecptr  *ub_spec;       /* old ob_spec */
        int              ub_type;        /* old ob_type */
} EXAPPLBLK;

`ub_code' ist der Zeiger auf die Funktion zum Malen des Objekts,
`ub_spec' ist ein Zeiger auf den alten ObSpec und
`ub_type' der alte Objekt-Typ (der neue muû ja G_USERDEF sein).

FÅr weitere Informationen zu benutzerdefinierten Objekten verweise ich
an dieser Stelle auf das neue Profibuch.

öber diese Struktur kann Let 'em Fly!  nun auch bei entsprechenden be-
nutzerdefinierten Objekten Tasten vergeben.

Ich  nutze jetzt die Mîglichkeit um hier auf eine Library  von  Markus
Nick aufmerksam machen.  Sie heiût `Ruby' und ermîglicht es Flugecken,
runde Radio-Buttons und Check-Boxen in ein Resource  einzubinden.  Die
FlugfÑhigkeit und die Tastenvergabe Åbernimmt Let 'em Fly!.  Somit ist
nur  der Let 'em Fly!-unabhÑngige Teil im eigentlichen  Programm  ent-
halten,  was sich natÅrlich auf die Grîûe positiv auswirkt.  Weiterhin
ist  das  Format  in  den  Grundelementen  kompatibel  zu  denen   der
Fly/My/MagicDials,  d.h.  spÑtere Library-Wechsel sind relativ einfach
zu bewerkstelligen.


                      Second Flight (The Cookie)
                      ==========================

Let 'em Fly!  installiert einen Cookie mit der Kennung `LTMF', welcher
auf die folgende Struktur zeigt:


typedef struct
{
        unsigned int    version;        /* Version im BCD-Format*/
        struct
        {
                unsigned light  : 1;    /* light version (read) */
                unsigned        : 1;    /* reserved             */
                unsigned jumpin : 1;    /* jumpin' dials        */
                unsigned flyswi : 1;    /* conf. flymode switch */
                unsigned vscr   : 1;    /* virtual scr. support */
                unsigned center : 1;    /* center mode          */
                unsigned keys   : 1;    /* key handling         */
                unsigned edit   : 1;    /* extended editor      */
                unsigned redraw : 1;    /* send redraw message  */
                unsigned flytyp : 1;    /* solid/hollow fly     */
                unsigned fly    : 1;    /* flying on/off        */
                unsigned alert  : 1;    /* Alerts/Errors on/off */
                unsigned v_mem  : 1;    /* use virtual memory   */
                unsigned f_grow : 1;    /* grow/shrink boxes    */
                unsigned g_grow : 1;
                unsigned bypass : 1;    /* ON/OFF highest prio  */
        } config;
        char    *vpath;                 /* path for v-mem       */
        void    cdecl   (*di_fly)(OBJECT *tree);
        void    cdecl   (*obj_clsize)(OBJECT *tree, int obj,
                                    int *x, int *y, int *w, int *h);
        int     cdecl   (*do_key)(int key, int kshift);
        int     cdecl   (*init_keys)(OBJECT *tree);
        int     cdecl   (*lookup_key)(int key, int kshift);
        int     cdecl   (*di_moveto)(OBJECT *tree, int mx, int my);
        char    cdecl   (*ins_spcchar)(void);
        int     ucol;   /* underscore color     */
        int     aicol;  /* alert icon color     */
        int     aframe; /* alert frame size     */
        int     flydelay; /* delay before flying (form_do()-only) */
        int     cdecl   (*hist_insert)(char *string);
} LTMFLY;


Die  Variablen  und  Funktionen  werden  jetzt  ab  hier  genauer  be-
schrieben.  Dabei  steht  die Zahl in der Klammer fÅr  den  Zeitpunkts
(Version)  des  Einzugs in Let 'em Fly!.  Will man  auf  entsprechende
Teile zugreifen,  so muû man vorher die Version prÅfen, ansonsten kann
es zu öberraschungseffekten kommen. Ausnahme: Dier Version ist kleiner
oder gleich 1.02. Das ist nÑmlich die erste offizielle Release.

1.) Die Variablen (bzw. Konstanten)
-----------------------------------

version
-------
Hier  ist  die Version von Let 'em Fly!  im  BCD-Format  (0x0114  ent-
spricht 1.14) zu finden.

light (1.00)
------------
Zeigt  an  welche Version geladen wurde (light  oder  normal).  Dieses
Flag darf nicht verÑndert werden!

jumpin (1.15)
-------------
Schaltet die Jumpin' Dials ein.

flyswi (1.13)
-------------
Ist  dieses  Flag  gesetzt,  so  wird die  rechte  Maustaste  fÅr  den
Flugmodus (Ghost-Flights) umgeschaltet bzw. invertiert.

vscr (1.10)
-----------
Zeigt an, ob der VSCR-Cookie ausgewertet und benutzt werden soll.

center (1.03)
-------------
Bestimmt  den Center-Mode.  Dabei gilt 1 fÅr nicht centern und  0  fÅr
centern.

keys (1.00)
-----------
Schaltet die Key Dials ein.

edit (1.00)
-----------
öber dieses Flag wird der Extended Editor eingeschaltet.

redraw (1.02)
-------------
Zeigt  an,  ob  nach  dem Lîschen der Dialogbox  ein  Redraw  gesendet
werden soll.

flytyp (1.00)
-------------
Bestimmt den Flugmodus (0: Solid, 1: Hollow).

fly (1.00)
----------
Schaltet die fliegenden Dialoge aus.

alert (1.00)
------------
Konfiguriert die neuen Alert-Boxen.

v_mem
-----
Nicht benutzt und reserviert.

f_grow (1.00)
-------------
Ist dieses Flag gelîscht,  so werden die FMD_GROW/SHRINK-Aufrufe igno-
riert.

g_grow (1.00)
-------------
Genauso  wie  `f_grow',  jedoch  gilt die  ganze  Geschichte  fÅr  die
graf_grow/shrinkbox()-Aufrufe.

bypass (1.00)
-------------
Hier  ist  das  Master-Flag.  Ist es  gesetzt,  so  wird  Let 'em Fly!
deaktiviert.

*vpath (1.00)
-------------
Unbenutzt. Zeigt auf einen String der LÑnge Null.

ucol (1.13)
-----------
Bestimmt die Farbe und die Form der Underscores.  Ist Bit 0 vom oberen
Byte  gesetzt,  so  werden  anstelle der  Underscores  die  Buchstaben
eingefÑrbt (natÅrlich ohne dabei zu tropfen).

aicol (1.13)
------------
ReprÑsentiert die Farbe der Alert-Icons.

aframe (1.13)
-------------
Bistimmt die Rahmendicke der Alert-Boxen.

flydelay (1.15)
---------------
Gibt  die  Zeit  (ohne  Einheit im  Bereich  von  0-10)  zwischen  dem
Mausklick und dem Flug an.

2.) Die Funktionen
------------------

Let 'em Fly!  stellt  auch  einige Funktionen  zur  VerfÅgung,  welche
besonders fÅr eigene form_do()-Routinen nÅtzlich sein kînnten.  Um die
Funktionen  zu benutzen sollte man das Bindings `LTMF_LIB'  verwenden,
da  hier  u.a.  auch die  unterschiedlichen  Versionen  berÅcksichtigt
werden.  Die jetzt folgende Beschreibung bezieht sich auf das Binding.
Weiterhin verweise ich auch auf das form_do()-Beispiel, welches einige
Let 'em Fly! Funktionen benutzt.

int di_fly(OBJECT *tree) (1.00)
-------------------------------
öber diese Funktion kann man Dialoge fliegen lassen.  Der  Bildschirm-
ausschnitt muû vorher mit FMD_START korrekt gesichert worden sein. Die
genaue Verwendung ist aus dem form_do()-Sample zu entnehmen.

int di_moveto(OBJECT *tree, int x, int y) (1.15)
------------------------------------------------
Diese  Funktion  wird  von den Jumpin' Dials  benutzt.  Sie  lÑût  den
Dialog (maus)zentriert an die angugebende Position springen.
öber diese Funktion kann man jetzt auch testen ob ein Dialog flugfÑhig
ist bzw.  ob der Hintergrund gesichert werden konnte.  Dazu wurden  in
LTMF_LIB.H zwei Macros definiert.

int di_center(OBJECT *tree) (1.17)
----------------------------------
Hiermit kann ein Dialog re-centered werden.

int obj_clsize(OBJECT *tree, int obj, int *x, *y, *w, *h) (1.10)
----------------------------------------------------------------
Diese  Funktion berechnet die wahren Ausmaûe eines  Objekts.  Es  wird
auch  der  SHADOWED-Status korrekt behandelt.  Eigentlich  sollte  sie
fester Bestandteil des AES sein.

int init_keys(OBJECT *tree) (1.13)
----------------------------------
Benutzt  man eine eigene form_do()-Routine,  will aber trotzdem  nicht
auf  die  Tastaturbedienbarkeit verzichten,  so kann  man  mit  dieser
Funktion  die Tastenvergabe von Let 'em Fly!  aufrufen.  Dabei  werden
dann auch die Strichlein gemalt, d.h. sie darf erst aufgerufen werden,
wenn sich der Dialog auf dem Bildschirm befindet.

int lookup_key(int key, int kbshift) (1.13)
-------------------------------------------
Hat  man  vorher  init_keys()  aufgerufen und  einen  Wert  !=  0  zu-
rÅckbekommen,  dann kann man die eingehenden Keyboard-Events von  die-
ser Funktion checken lassen,  um zu gucken,  ob ein Objekt Åber  einen
Shortcut  angewÑhlt  wurde.  Diese Funktion muû VOR  form_keybd()  und
objc_edit() aufgerufen werden!

int set_do_key(void (*key_handler)()) (1.12)
--------------------------------------------
Oft  ist  es so,  daû man eigene Tasten  mit  einbinden  mîchte,  aber
denoch  nicht  auf  den Let 'em Fly!  Support  verzichten  zu  wollen.
Let 'em Fly!  erlaubt  es daher einen benutzerdefinierten  Key-Handler
zu  installieren (do_key() im Cookie).  Hier erstmal ein kleines  Bei-
spiel:


[...]

#include <ltmf_lib.h>

[...]

int cdecl my_keys(int key, int kshift)
{
     printf("%04x %04x\n\r", key, kshift);
     return(0);
}

[...]

int do_dialog(OBJECT *tree)
{
     int  what;

     draw_dialog(tree);
     set_do_key(my_keys);          /* Routine einklinken */
     what = form_do(tree, 0);
     set_do_key(0l);               /* und wieder ausklinken. */
     undraw_dialog(tree);
     return(what);
}

[...]

Dieses kleine Beispielprogramm macht nichts anderes,  als einen Dialog
darzustellen und abzuarbeiten,  jedoch werden die TastendrÅcke  inner-
halb von form_do() mit printf() auf dem Bildschirm ausgegeben.

Die Funktion zur Tastenbearbeitung muû folgenden Regeln folgen:

int cdecl do_key(int key, int kshift);

Eingabe:  key       EnthÑlt  den  Tastencode.  Er stimmt mit  dem  von
                    evnt_keybd() zurÅckgegebenen  Åberein,  d.h.  Bits
                    0..7  enthalten den ASCII-Code und Bits 8..15  den
                    Scancode.
          kshift    EnthÑlt  den Shiftstatus,  der  von  evnt_button()
                    geliefert wurde.

Return:   0         Taste  konnte  nicht  verarbeitet   werden,   bzw.
                    Let 'em Fly!  sieht  den Tastencode als gÅltig  an
                    und versucht ihn selbst zu verarbeiten.
          1         Taste  konnte  verarbeitet  werden.   Let 'em Fly!
                    ignoriert die Taste nun.
          2         Wie  `1',   jedoch  wird  der  Dialog   zusÑtzlich
                    abgebrochen  und als Ergebnis (bei form_do())  `0'
                    zurÅckgeliefert.

Wird innerhalb dieser Routinen ein Dialog dargestellt,  so wird dieser
nicht   von  Let 'em Fly!   unterstÅtzt,   da  der  TRAP-Handler   von
Let 'em Fly! nicht reentrant ist.

Weiterhin muû der Programmierer dafÅr Sorge tragen, daû der Funktions-
Pointer  nach Beendigung des Dialogs auf `0L' zurÅckgesetzt  wird.  Es
kînnten  sonst Åberraschende Effekte  (z.B.  Bomben)  auftreten.  Aus-
nahme:  Man  will nur mal kurz eine Alert-Box  darstellen.  In  diesem
Fall wird die neue Tastenroutine von Let 'em Fly! nicht aufgerufen.

int ins_spcchar(void) (1.15)
----------------------------
Let 'em Fly!  besitzt ab Version 1.15 eine Box, in der man die `Åblen'
Zeichen  eingeben kann.  Diese Box kann man Åber diese Funktion  nicht
nur innerhalb, sondern auch auûerhalb von Dialogen benutzen.

int hist_insert(char *string) (1.16)
------------------------------------
Manchmal  ist es sinnvoll Strings manuell in die  Let 'em Fly!-History
einzufÅgen. Diese Funktion macht den Weg frei ...

int init_flyobj(OBJECT *tree)
-----------------------------
Let 'em Fly!  unterstÅtzt ab Version 1.17 explizit  sog.  Flugobjekte.
Diese  Objekte  werden  mit bestimmten  Eigenschaften  versehen  (s.a.
ExObTypes).  Kann ein Dialog nicht fliegen (z.B. Speicherplatzmangel),
so  wird  dieses Objekt gelîscht.  Da sich die  Flugecke  von  Julians
FlyDials  irgendwie eingebÅrgert hat,  kann man Åber diese  (externe!)
Funktion  eine  eben  solche als  installieren.  Das  zu  verwandelnde
Objekt  muû  natÅrlich die richtige Kennung  und  vernÅnftige  Ausmaûe
besitzen.  Am besten ist es,  wenn man eine G_BOX mit  OUTLINED-Status
benutzt.  Diese Funktion wird z.B.  von Selectricø, Take-Off 2 und der
FuzzyClock ab Version 1.06 benutzt.
Bemerkung: Es wird hier natÅrlich ein USERDEF installiert. Um auch mit
Accessories  und  TSRs (Terminate & Stay Resident)  ohne  Probleme  zu
funktionieren,  wird die Workstation vom AES benutzt.  Die  Attribute,
die verÑndert werden, werden natÅrlich gesichert.


              Third Flight (Tips & Tricks & Guidelines)
              =========================================

Das mit dem Redraw einzelner Objekte ...
----------------------------------------
...  machen  viele  noch falsch.  Wird ein Dialog  durch  Let 'em Fly!
flugfÑhig,  so  kann sich ja die Position der Box und somit  auch  der
einzelnen  Objekte  Ñndern.  Da objc_draw() und  objc_change()  jedoch
Clipping-Koordinaten  benîtigen,  mÅssen diese vor *JEDEM* Aufruf  neu
berechnet  werden.   Viele  benutzen  nur  die,   die  am  Anfang  von
form_dial() zurÅckgeliefert wurden,  was natÅrlich zu Problemen in der
Bidlschirmdarstellung fÅhrt.  Das TOS berÅcksichtigt es ja auch, sonst
wÅrde Let 'em Fly!  Åberhaupt nicht funktionieren.  Um diesen Miûstand
zu beheben,  folgen nun entsprechende Funktionen,  die a)  komfortabel
und b) Let 'em Fly!-fest sind. Sie sollten sich selbst erklÑren ...

----- cut here ------------------------------------------------------

/* ---------------------------------------------------------------- */
/*   Berechne die _absoluten_ Koordinaten eines Objekts             */
/* ---------------------------------------------------------------- */

void obj_xywh(OBJECT *tree, int obj, GRECT *p)
{
        objc_offset(tree, obj, &p->g_x, &p->g_y);
        p->g_w = tree[obj].ob_width;
        p->g_h = tree[obj].ob_height;
}

/* ---------------------------------------------------------------- */
/*   Redraw eines einzelnen Objekts unter BerÅcksichtigung der      */
/*   _aktuellen_ Position.                                          */
/* ---------------------------------------------------------------- */

void obj_update(OBJECT *tree, int obj)
{
        GRECT   p;

        obj_xywh(tree, obj, &p);
        objc_draw(tree, obj, MAX_DEPTH, p.g_x, p.g_y, p.g_w, p.g_h);
}

/* ---------------------------------------------------------------- */
/*   Objekt-Status eines Objekts verÑndern. Dabei gilt ~STATUS fÅr  */
/*   Status lîschen.                                                */
/* ---------------------------------------------------------------- */

void obj_stchange(OBJECT *tree, int obj, int state, int update)
{
        if(state < 0)
                tree[obj].ob_state &= state;
        else
                tree[obj].ob_state |= state;
        if(update)
                obj_update(tree, obj);
}

/* ---------------------------------------------------------------- */
/*   Objekt-Flags eines Objekts verÑndern. Dabei gilt ~FLAG fÅr     */
/*   Flag lîschen.                                                  */
/* ---------------------------------------------------------------- */

void obj_flchange(OBJECT *tree, int obj, int flag, int update)
{
        if(flag < 0)
                tree[obj].ob_flags &= flag;
        else
                tree[obj].ob_flags |= flag;
        if(update)
                obj_update(tree, obj);
}

----- cut here again ------------------------------------------------

Bei  den  beiden letzten Funktionen ist zu  beachten,  daû  diese  nur
Flags/Stati  bis  zur  Nummer  14  korrekt  behandeln,  da  sonst  ein
Vorzeichenfehler auftritt.  FÅr den normalen Hausgebrauch reichen  sie
aber vîllig aus.
Nochwas:  Wenn  man mit VDI-Funktionen in die Box malt  (z.B.  Edison-
Utilities),   dann  muû  man  ebenfalls  vorher  ein  obj_xywh()  bzw.
objc_offset()  aufrufen,  um den Offset und das Clipping-Rectangle  zu
erhalten!

Senden von Redraws
------------------
In  manchen  Situationen muû man sich selbst  (also  der  Applikation)
einen Redraw senden,  um z.B.  einen Desktop-Redraw auszulîsen. Hierzu
gibt es zwei Verfahren: 1.) Das Senden einer Message Åber appl_write()
und   2.)  ein  form_dial(FMD_FINISH, ...)  mit   den   entsprechenden
Koordinaten (dabei vorher *KEIN* form_dial(FMD_START, ...) machen,  da
es  a) nicht notwendig und vîllig ÅberflÅssig ist und b) die  jetzigen
Let 'em Fly!  Versionen  in diesem Fall keinen Redraw  senden).  Beide
Mîglichkeiten sind von Atari offiziell dokumentiert.

RedrawunterdrÅckung beim Lîschen von Info-`Dialogen'
----------------------------------------------------
Will  man nur mal eine Dialogbox auf den Bildschirm zaubern,  um  eine
kleine Info anzuzeigen (z.B.  `Sortiere ...'),  ohne daû eine  Eingabe
vom Benutzer erwartet wird,  so wird von Let 'em Fly! immer ein Redraw
beim Lîschen der Box gesendet,  da einige Programme das brauchen. Dies
ist  dann hinderlich,  wenn man Let 'em Fly!  das Buffern des  Hinter-
grundes Åberlassen will.  Man kann es aber unterdrÅcken, indem man vor
dem FMD_FINISH ein Dummy-objc_find() macht. Der Aufruf sieht wie folgt
aus:
          objc_find(tree, ROOT, MAX_DEPTH, 0, 0);


Tastenvergabe in nicht-modalen Dialogen (die in den Fenstern)
-------------------------------------------------------------
Vergibt  man bei diesen Dialogen die Tasten Åber init_keys(),  so  ist
darauf  zu achten,  daû sich der Dialog im obersten Fenster  befindet.
Ansonsten sollte man auf einen Aufruf bei einem Redraw verzichten,  da
es in diesem Fall zu BildschirmmÅll kommt.

Der Aufbau der RSCs fÅr die Icons der Alertboxen
------------------------------------------------
Let 'em Fly!  erwartet  in  der Datei LET_ICON.RSC drei  Icons  welche
sinnvollerweise in einer G_BOX abgelegt sein sollten.  Die drei  Icons
mÅssen von links nach rechts sortiert sein,  da sonst die  Zuweisungen
nicht stimmen.  Die Grîûe der Icons betrÑgt 32x32 Pixel. Zum Editieren
wird ein Resource-Construction-Set und u.U. ein Icon-Editor benîtigt.


                              Nachschlag
                              ==========

Hmm,  ich weiû garnicht was ich hier schreiben soll. Na auf jeden Fall
bedanke  ich  mich mal an dieser Stelle fÅr die  vielen  Hinweise  und
Problemanfragen  einiger Programmierer,  die somit `Three Flights  Up'
zu  dieser  Form verholfen haben (und natÅrlich auch  bei  denen,  die
dazu   beigetragen  haben,   daû  die   Programmierschnittstelle   in-
zwischen  diesen Umfang erreicht hat).  Falls noch  irgendwelche  Ver-
besserungsvorschlÑge etc. da sind, hier ...


meine Adresse ...

Oliver Scheel
Rothehausstr. 28
W-5000 Kîln 30

MausNet:  Oliver Scheel @ K
InterNet: Oliver_Scheel@k.maus.de


Let 'em Fly!     Man fliegt nicht mehr ohne ...




----
RÑchzschreipfÑler (c) 1991-92 by Oliver Scheel
