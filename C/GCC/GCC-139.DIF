*** /home/bammi/etc/src/gcc-1.39/cccp.c	Sun Jan 20 16:00:46 1991
--- cccp.c	Sun Jan 20 16:29:25 1991
***************
*** 21,30 ****
--- 21,31 ----
   You are forbidden to forbid anyone else to use, share and improve
   what you give them.   Help stamp out software-hoarding!  */
  
  typedef unsigned char U_CHAR;
  
+ 
  #ifdef EMACS
  #define NO_SHORTNAMES
  #include "../src/config.h"
  #ifdef open
  #undef open
***************
*** 44,72 ****
  /* In case config.h defines these.  */
  #undef bcopy
  #undef bzero
  #undef bcmp
  
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <ctype.h>
  #include <stdio.h>
  #include <signal.h>
  
  #ifndef VMS
  #include <sys/file.h>
! #ifndef USG
  #include <sys/time.h>		/* for __DATE__ and __TIME__ */
  #include <sys/resource.h>
  #else
  #define index strchr
  #define rindex strrchr
  #include <time.h>
  #include <fcntl.h>
! #endif /* USG */
  #endif /* not VMS */
!   
  /* VMS-specific definitions */
  #ifdef VMS
  #include <time.h>
  #include <errno.h>		/* This defines "errno" properly */
  #include <perror.h>		/* This defines sys_errlist/sys_nerr properly */
--- 45,94 ----
  /* In case config.h defines these.  */
  #undef bcopy
  #undef bzero
  #undef bcmp
  
+ #ifndef atarist
+ 
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <ctype.h>
  #include <stdio.h>
  #include <signal.h>
  
  #ifndef VMS
  #include <sys/file.h>
! #if (!(defined(USG) || defined(atariminix)))
  #include <sys/time.h>		/* for __DATE__ and __TIME__ */
  #include <sys/resource.h>
  #else
+ #ifndef atariminix
  #define index strchr
  #define rindex strrchr
+ #endif
  #include <time.h>
  #include <fcntl.h>
! #endif /* USG or atariminix */
  #endif /* not VMS */
! 
! #else		/* atarist */
! 
! #include <ctype.h>
! #include <stdio.h>
! #include <types.h>
! #include <stat.h>
! #include <file.h>
! #include <time.h>
! #include "stddef.h"
! 
! long _stksize = -1L;	/* want big stack cause include files
! 				   get alloca'ed there */
! 
! #endif		/* atarist */
! 
! 
!  
  /* VMS-specific definitions */
  #ifdef VMS
  #include <time.h>
  #include <errno.h>		/* This defines "errno" properly */
  #include <perror.h>		/* This defines sys_errlist/sys_nerr properly */
***************
*** 263,302 ****
--- 285,368 ----
    };
  
  /* #include "file" looks in source file dir, then stack. */
  /* #include <file> just looks in the stack. */
  /* -I directories are added to the end, then the defaults are added. */
+ #ifdef atarist
+ 
+ struct file_name_list include_canned_defaults[] =
+   {
+     { &include_canned_defaults[1], "\\gnu\\lib" },
+     { 0, "\\gnu\\include" }
+   };
+ 
+ struct file_name_list * include_defaults = &include_canned_defaults[0];
+ 
+ #else
+ 
  struct file_name_list include_defaults[] =
    {
  #ifndef VMS
+ #ifdef CROSSATARI
+     { 0, CROSSINC }
+ #else
+ #ifdef atariminix
+     { 0, "/usr/local/gcc-include" }
+ #else
      { &include_defaults[1], GCC_INCLUDE_DIR },
      { &include_defaults[2], "/usr/include" },
      { 0, "/usr/local/include" }
+ #endif
+ #endif
  #else
      { &include_defaults[1], "GNU_CC_INCLUDE:" },       /* GNU includes */
      { &include_defaults[2], "SYS$SYSROOT:[SYSLIB.]" }, /* VAX-11 "C" includes */
      { 0, "" },	/* This makes normal VMS filespecs work OK */
  #endif /* VMS */
    };
+ #endif /* atarist */
  
  /* These are used instead of the above, for C++.  */
+ #ifdef atarist
+ 
+ struct file_name_list include_canned_cplusplus_defaults[] =
+   {
+     { &include_canned_defaults[1], "\\gnu\\lib" },
+     { 0, "\\gnu\\include" }
+   };
+ 
+ struct file_name_list * cplusplus_include_defaults =
+ 					&include_canned_cplusplus_defaults[0];
+ 
+ #else
+ 
+ #ifdef atariminix
+ #define GPLUSPLUS_INCLUDE_DIR "/usr/local/g++-include"
+ #define GCC_INCLUDE_DIR "/usr/local/gcc-include"
+ #endif
+ 
  struct file_name_list cplusplus_include_defaults[] =
    {
  #ifndef VMS
      /* Pick up GNU C++ specific include files.  */
      { &cplusplus_include_defaults[1], GPLUSPLUS_INCLUDE_DIR },
      /* Use GNU CC specific header files.  */
      { &cplusplus_include_defaults[2], GCC_INCLUDE_DIR },
+ #ifdef CROSSATARI
+     { 0, CROSSINC }
+ #else
      { 0, "/usr/include" }
+ #endif
  #else
      { &cplusplus_include_defaults[1], "GNU_GXX_INCLUDE:" },
      { &cplusplus_include_defaults[2], "GNU_CC_INCLUDE:" },
      /* VAX-11 C includes */
      { &cplusplus_include_defaults[3], "SYS$SYSROOT:[SYSLIB.]" },
      { 0, "" },	/* This makes normal VMS filespecs work OK */
  #endif /* VMS */
    };
+ #endif /* atarist */
  
  struct file_name_list *include = 0;	/* First dir to search */
  	/* First dir to search for <file> */
  struct file_name_list *first_bracket_include = 0;
  struct file_name_list *last_include = 0;	/* Last in chain */
***************
*** 521,538 ****
--- 587,659 ----
  int deps_column;
  
  /* Nonzero means -I- has been seen,
     so don't look for #include "foo" the source-file directory.  */
  int ignore_srcdir;
+  
+ #ifdef atarist
+ /* a little frobule to filter incoming file data */
+ int eunuchs_read(f, buf, size)
+ int f;
+ char * buf;
+ int size;
+ {
+   char local_buf[1024];
+   register int result_size;
+   register char * local_bufp, * target_bufp;
+   register int buf_size, size_read;
+ 
+   for (result_size = 0, target_bufp = buf ; size > 0 ; size -= 1024)
+ /* do a buffer */
+   	{
+ 	if (size > 1024)
+ 		buf_size = 1024;
+ 	    else
+ 	    	buf_size = size;
+ 	size_read = read(f, &local_buf, buf_size);
+ 	for (local_bufp = (char * ) &local_buf; size_read > 0 ; size_read--)
+ 		if (*local_bufp == '\r')
+ 			local_bufp++;
+ 		    else
+ 		    	{
+ 			*target_bufp++ = *local_bufp++;
+ 			result_size++;
+ 			}
+ 	}
+   return(result_size);
+ }
+ 
+ /* the following dingus is used in place of some calls to bcopy,
+    to ensure that backslashes get properly slashified when getting
+    shoved into strings.  Note that it returns the new pointer!!
+    There ought to be a better way... */
+ 
+ U_CHAR * slashifying_bcopy(from_buf, to_buf, nbytes)
+ U_CHAR * from_buf, * to_buf;
+ int nbytes;
+ {
+   for ( ; nbytes > 0 ; )
+ 	{
+ 	if(*from_buf == '\\')
+ 		*to_buf++ = '\\';
+ 	*to_buf++ = *from_buf++;
+ 	nbytes--;
+ 	}
+   return(to_buf);
+ }
+ 
+ #endif		/* atarist */
  
+ #ifndef atarist
  /* Handler for SIGPIPE.  */
  
  static void
  pipe_closed ()
  {
    fatal ("output pipe has been closed");
  }
+ #endif
  
  int
  main (argc, argv)
       int argc;
       char **argv;
***************
*** 554,563 ****
--- 675,689 ----
    /* Stream on which to print the dependency information.  */
    FILE *deps_stream = 0;
    /* Target-name to write with the dependency information.  */
    char *deps_target = 0;
  
+ #ifdef atarist
+ /* turn this on if you are going to set the TOS 1.4 dont clear heap flag */
+ /*  _malloczero(1); */ 	/* zero mallocs by default */
+ #endif  
+ 
  #ifdef RLIMIT_STACK
    /* Get rid of any avoidable limit on stack size.  */
    {
      struct rlimit rlim;
  
***************
*** 602,627 ****
--- 728,799 ----
    cplusplus = 0;
  #ifdef CPLUSPLUS
    cplusplus = 1;
  #endif
  
+ #ifndef atarist
    signal (SIGPIPE, pipe_closed);
+ #endif  
  
  #ifndef VMS
    max_include_len
+ #ifdef atarist
+     =    sizeof ("d:\\12345678\\12345678\\12345678.xxx");
+ #else
      = max (max (sizeof (GCC_INCLUDE_DIR),
  		sizeof (GPLUSPLUS_INCLUDE_DIR)),
  	   sizeof ("/usr/include/CC"));
+ #endif
  #else /* VMS */
    max_include_len
      = sizeof("SYS$SYSROOT:[SYSLIB.]");
  #endif /* VMS */
  
    bzero (pend_files, argc * sizeof (char *));
    bzero (pend_defs, argc * sizeof (char *));
    bzero (pend_undefs, argc * sizeof (char *));
  
+ #ifdef atarist
+ /* see if we have an indication of where the GNU library directory is */
+   {
+     char * gnulib = (char * ) getenv("GNUINC");
+     struct file_name_list *first, *last, *g;
+ 
+     if(!gnulib) gnulib = (char *) getenv("GNULIB"); /* try GNULIB */
+     if (gnulib)
+ 	{
+ 	  char *glib = alloca(strlen(gnulib)+1), *cp, *cpp;
+ 
+ 	  strcpy(glib, gnulib);
+           cp = cpp = glib; last = (struct file_name_list *)NULL;
+ 	  while( *cpp != '\0' )
+ 	  {
+ 	     while( (*cp != ';') && (*cp != ',') && (*cp != '\0') )
+ 		 cp++;
+ 	     if( *cp != '\0' )
+ 		 *cp++ = '\0';	/* terminate string and advance to next	*/
+ 				 /* else  "*(cpp = cp) = '\0'"  =>> end */
+ 	     g = (struct file_name_list *) 
+ 		xmalloc(sizeof(struct  file_name_list));
+ 	     g->fname = xmalloc(strlen(cpp)+1);
+ 	     strcpy(g->fname, cpp);
+ 	     g->next = (struct file_name_list *)NULL;
+ 	     if(last)
+ 		last->next = g;
+ 	     else
+ 		first = g;
+ 	     last = g;
+ 	     cpp = cp;		/* ptr to next entry or '\0' (see above) */
+ 	  }
+ 
+ /* cons it onto the front of the defaults. */
+ 	last->next = include_defaults;
+ 	include_defaults = first;
+ 	}
+   }
+ #endif
+ 
    /* Process switches and find input file name.  */
  
    for (i = 1; i < argc; i++) {
      if (argv[i][0] != '-') {
        if (out_fname != NULL)
***************
*** 987,997 ****
--- 1159,1173 ----
      bsize = 2000;
      size = 0;
      fp->buf = (U_CHAR *) xmalloc (bsize + 2);
      bufp = fp->buf;
      for (;;) {
+ #ifdef atarist
+       cnt = eunuchs_read (f, bufp, bsize - size);
+ #else
        cnt = read (f, bufp, bsize - size);
+ #endif
        if (cnt < 0) goto perror;	/* error! */
        if (cnt == 0) break;	/* End of file */
        size += cnt;
        bufp += cnt;
        if (bsize == size) {	/* Buffer is full! */
***************
*** 1007,1017 ****
--- 1183,1197 ----
      long i;
      fp->length = 0;
      fp->buf = (U_CHAR *) xmalloc (st_size + 2);
  
      while (st_size > 0) {
+ #ifdef atarist
+       i = eunuchs_read (f, fp->buf + fp->length, st_size);
+ #else
        i = read (f, fp->buf + fp->length, st_size);
+ #endif
        if (i <= 0) {
          if (i == 0) break;
  	goto perror;
        }
        fp->length += i;
***************
*** 1067,1076 ****
--- 1247,1259 ----
    }
  
    if (ferror (stdout))
      fatal ("I/O error on output");
  
+ #ifdef atarist
+ /*  close(fileno(stdout)); */		/* this shouldn't be necessary */
+ #endif
    if (errors)
      exit (FATAL_EXIT_CODE);
    exit (SUCCESS_EXIT_CODE);
  
   perror:
***************
*** 2387,2398 ****
--- 2570,2590 ----
        else
  	string = instack[0].fname;
  
        if (string)
  	{
+ #ifndef atarist
  	  buf = (char *) alloca (3 + strlen (string));
  	  sprintf (buf, "\"%s\"", string);
+ #else
+     	  buf = (char *) alloca (16 + strlen (string));
+           {
+ 	      char *tbuf = (char *) alloca (16 + strlen (string));
+ 	      (void) slashifying_bcopy(string, tbuf, strlen(string)+1);
+ 	      sprintf (buf, "\"%s\"", tbuf);
+           }
+ #endif /* atarist */
  	}
        else
  	buf = "\"\"";
  
        break;
***************
*** 2539,2556 ****
--- 2731,2753 ----
  	  if ((nam = fp->fname) != NULL) {
  	    /* Found a named file.  Figure out dir of the file,
  	       and put it in front of the search list.  */
  	    dsp[0].next = stackp;
  	    stackp = dsp;
+ #ifdef atarist
+ 	      if((ep = rindex (nam, '\\')) == NULL)
+ 		  ep = rindex(nam, '/');	/* allow both */
+ #else
  #ifndef VMS
  	    ep = rindex (nam, '/');
  #else				/* VMS */
  	    ep = rindex (nam, ']');
  	    if (ep == NULL) ep = rindex (nam, '>');
  	    if (ep == NULL) ep = rindex (nam, ':');
  	    if (ep != NULL) ep++;
  #endif				/* VMS */
+ #endif /* atarist */
  	    if (ep != NULL) {
  	      n = ep - nam;
  	      dsp[0].fname = (char *) alloca (n + 1);
  	      strncpy (dsp[0].fname, nam, n);
  	      dsp[0].fname[n] = '\0';
***************
*** 2597,2607 ****
--- 2794,2808 ----
    fname = (char *) alloca (max_include_len + flen + 2);
    /* + 2 above for slash and terminating null.  */
  
    /* If specified file name is absolute, just open it.  */
  
+ #ifdef atarist
+   if ((*fbeg == '\\') || (*fbeg == '/')) {
+ #else
    if (*fbeg == '/') {
+ #endif
      strncpy (fname, fbeg, flen);
      fname[flen] = 0;
      f = open (fname, O_RDONLY, 0666);
    } else {
      /* Search directory path, trying to open the file.
***************
*** 2608,2618 ****
--- 2809,2823 ----
         Copy each filename tried into FNAME.  */
  
      for (; stackp; stackp = stackp->next) {
        if (stackp->fname) {
  	strcpy (fname, stackp->fname);
+ #ifdef atarist
+ 	strcat (fname, "\\");
+ #else
  	strcat (fname, "/");
+ #endif
  	fname[strlen (fname) + flen] = 0;
        } else {
  	fname[0] = 0;
        }
        strncat (fname, fbeg, flen);
***************
*** 2728,2738 ****
      fp->bufp = fp->buf;
  
      /* Read the file contents, knowing that st_size is an upper bound
         on the number of bytes we can read.  */
      while (st_size > 0) {
!       i = read (f, fp->buf + fp->length, st_size);
        if (i <= 0) {
  	if (i == 0) break;
  	goto nope;
        }
        fp->length += i;
--- 2933,2947 ----
      fp->bufp = fp->buf;
  
      /* Read the file contents, knowing that st_size is an upper bound
         on the number of bytes we can read.  */
      while (st_size > 0) {
! #ifdef atarist
!     i = eunuchs_read (f, fp->buf + fp->length, st_size);
! #else
!     i = read (f, fp->buf + fp->length, st_size);
! #endif
        if (i <= 0) {
  	if (i == 0) break;
  	goto nope;
        }
        fp->length += i;
***************
*** 2751,2761 ****
--- 2960,2974 ----
      st_size = 0;
      basep = (U_CHAR *) xmalloc (bsize + 2);
      bufp = basep;
  
      for (;;) {
+ #ifdef atarist
+     i = eunuchs_read (f, bufp, bsize - st_size);
+ #else
        i = read (f, bufp, bsize - st_size);
+ #endif
        if (i < 0)
  	goto nope;      /* error! */
        if (i == 0)
  	break;	/* End of file */
        st_size += i;
***************
*** 4153,4164 ****
--- 4366,4381 ----
    len = strlen (line_cmd_buf);
    line_cmd_buf[len++] = '\n';
    check_expand (op, len + 1);
    if (op->bufp > op->buf && op->bufp[-1] != '\n')
      *op->bufp++ = '\n';
+ #ifdef atarist
+   op->bufp = slashifying_bcopy (line_cmd_buf, op->bufp, len);
+ #else
    bcopy (line_cmd_buf, op->bufp, len);
    op->bufp += len;
+ #endif
    op->lineno = ip->lineno;
  }
  
  /* This structure represents one parsed argument in a macro call.
     `raw' points to the argument text as written (`raw_length' is its length).
***************
*** 5397,5406 ****
--- 5614,5624 ----
    deps_size += size;
    deps_column += size;
    deps_buffer[deps_size] = 0;
  }
  
+ #if (!(defined(atarist) || defined(atariminix) || defined(CROSSATARI)))
  #ifndef BSD
  #ifndef BSTRING
  
  void
  bzero (b, length)
***************
*** 5464,5474 ****
     return 0;
  #endif /* not VMS */
  }
  #endif /* not BSTRING */
  #endif /* not BSD */
! 
  
  void
  fatal (str, arg)
       char *str, *arg;
  {
--- 5682,5692 ----
     return 0;
  #endif /* not VMS */
  }
  #endif /* not BSTRING */
  #endif /* not BSD */
! #endif /* not ATARI */
  
  void
  fatal (str, arg)
       char *str, *arg;
  {
*** /home/bammi/etc/src/gcc-1.39/gcc.c	Mon Dec  3 15:18:57 1990
--- gcc.c	Sun Jan 20 16:29:27 1991
***************
*** 119,147 ****
  be treated as compiler output files, and passed to the linker in their proper
  position among the other output files.
  
  */
  
  #include <stdio.h>
  #include <sys/types.h>
  #include <signal.h>
  #include <sys/file.h>
  
  #include "config.h"
  #include "obstack.h"
  #include "gvarargs.h"
  
! #ifdef USG
  #ifndef R_OK
  #define R_OK 4
  #define W_OK 2
  #define X_OK 1
  #endif
  
  #define vfork fork
  #endif /* USG */
  
  #define obstack_chunk_alloc xmalloc
  #define obstack_chunk_free free
  extern int xmalloc ();
  extern void free ();
  
--- 119,163 ----
  be treated as compiler output files, and passed to the linker in their proper
  position among the other output files.
  
  */
  
+ #ifdef CROSSATARI
+ #ifdef atarist
+ #undef atarist
+ #endif
+ #ifdef atariminix
+ #undef atariminix
+ #endif
+ #endif
+   
  #include <stdio.h>
  #include <sys/types.h>
  #include <signal.h>
  #include <sys/file.h>
  
  #include "config.h"
  #include "obstack.h"
  #include "gvarargs.h"
  
! #if (defined(USG) || defined(atariminix))
  #ifndef R_OK
  #define R_OK 4
  #define W_OK 2
  #define X_OK 1
  #endif
  
  #define vfork fork
  #endif /* USG */
  
+ #ifdef atarist
+ #include <osbind.h>
+ #include <ctype.h>
+ long _stksize = 8192;
+ extern char *getenv();
+ #endif
+ 
  #define obstack_chunk_alloc xmalloc
  #define obstack_chunk_free free
  extern int xmalloc ();
  extern void free ();
  
***************
*** 243,253 ****
  struct compiler compilers[] =
  {
    {".c",
     "cpp %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{i*} %{trigraphs} -undef \
          -D__GNUC__ %{ansi:-trigraphs -$ -D__STRICT_ANSI__} %{!ansi:%p} %P\
!         %c %{O:-D__OPTIMIZE__} %{traditional} %{pedantic} %{P}\
  	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\
          %i %{!M*:%{!E:%{!pipe:%g.cpp}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\
      %{!M*:%{!E:cc1 %{!pipe:%g.cpp} %1 \
  		   %{!Q:-quiet} -dumpbase %i %{Y*} %{d*} %{m*} %{f*} %{a}\
  		   %{g} %{O} %{W*} %{w} %{pedantic} %{ansi} %{traditional}\
--- 259,270 ----
  struct compiler compilers[] =
  {
    {".c",
     "cpp %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{i*} %{trigraphs} -undef \
          -D__GNUC__ %{ansi:-trigraphs -$ -D__STRICT_ANSI__} %{!ansi:%p} %P\
!         %c %{O:-D__OPTIMIZE__} %{mshort:-D__MSHORT__} %{mint:-D__MINT__}\
!         %{traditional} %{pedantic} %{P}\
  	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\
          %i %{!M*:%{!E:%{!pipe:%g.cpp}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\
      %{!M*:%{!E:cc1 %{!pipe:%g.cpp} %1 \
  		   %{!Q:-quiet} -dumpbase %i %{Y*} %{d*} %{m*} %{f*} %{a}\
  		   %{g} %{O} %{W*} %{w} %{pedantic} %{ansi} %{traditional}\
***************
*** 258,268 ****
  		      %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o}\
                        %{!pipe:%g.s}\n }}}"},
    {".cc",
     "cpp -+ %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{i*} \
          -undef -D__GNUC__ -D__GNUG__ %p %P\
!         %c %{O:-D__OPTIMIZE__} %{traditional} %{pedantic} %{P}\
  	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\
          %i %{!M*:%{!E:%{!pipe:%g.cpp}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\
      %{!M*:%{!E:cc1plus %{!pipe:%g.cpp} %1\
  		   %{!Q:-quiet} -dumpbase %i %{Y*} %{d*} %{m*} %{f*} %{a}\
  		   %{g} %{O} %{W*} %{w} %{pedantic} %{traditional}\
--- 275,286 ----
  		      %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o}\
                        %{!pipe:%g.s}\n }}}"},
    {".cc",
     "cpp -+ %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{i*} \
          -undef -D__GNUC__ -D__GNUG__ %p %P\
!         %c %{O:-D__OPTIMIZE__} %{mshort:-D__MSHORT__} %{mint:-D__MINT__}\
!         %{traditional} %{pedantic} %{P}\
  	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\
          %i %{!M*:%{!E:%{!pipe:%g.cpp}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\
      %{!M*:%{!E:cc1plus %{!pipe:%g.cpp} %1\
  		   %{!Q:-quiet} -dumpbase %i %{Y*} %{d*} %{m*} %{f*} %{a}\
  		   %{g} %{O} %{W*} %{w} %{pedantic} %{traditional}\
***************
*** 282,291 ****
--- 300,312 ----
    {".s",
     "%{!S:as %{R} %{j} %{J} %{h} %{d2} %a \
              %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o} %i\n }"},
    {".S",
     "cpp %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{trigraphs} \
+         -undef -D__GNUC__ -$ %p\
+         %c %{O:-D__OPTIMIZE__} %{mshort:-D__MSHORT__} %{mint:-D__MINT__}\
+         %{traditional} %{pedantic}\
          -undef -D__GNUC__ -$ %p %P\
          %c %{O:-D__OPTIMIZE__} %{traditional} %{pedantic} %{P}\
  	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\
          %i %{!M*:%{!E:%{!pipe:%g.s}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\
      %{!M*:%{!E:%{!S:as %{R} %{j} %{J} %{h} %{d2} %a \
***************
*** 294,307 ****
--- 315,340 ----
    /* Mark end of table */
    {0, 0}
  };
  
  /* Here is the spec for running the linker, after compiling all files.  */
+ 
+ #if (defined(CROSSATARI) || defined(atarist) || defined(atariminix))
+  
+  char *link_spec = "%{!c:%{!M*:%{!E:%{!S:ld %{o*} %l\
+  %{A} %{d} %{e*} %{N} %{n} %{r} %{s} %{S} %{T*} %{t} %{u*} %{X} %{x} %{z}\
+  %{y*} %{!nostdlib:%S} \
+  %{L*} %o %{!nostdlib:%s %L}\n }}}}";
+ 
+ #else
+ 
  char *link_spec = "%{!c:%{!M*:%{!E:%{!S:ld %{o*} %l\
   %{A} %{d} %{e*} %{N} %{n} %{r} %{s} %{S} %{T*} %{t} %{u*} %{X} %{x} %{z}\
   %{y*} %{!A:%{!nostdlib:%S}} \
   %{L*} %o %{!nostdlib:gnulib%s %{g:-lg} %L gnulib%s %{!A:%E}}\n }}}}";
+ 
+ #endif /* not atari */
  
  /* Accumulate a command (program name and args), and run it.  */
  
  /* Vector of pointers to arguments in the current line of specifications.  */
  
***************
*** 337,362 ****
  
  char *env_exec_prefix = 0;
  
  /* Suffix to attach to directories searched for commands.  */
  
! char *machine_suffix = 0;
  
  /* Default prefixes to attach to command names.  */
  
  #ifndef STANDARD_EXEC_PREFIX
! #define STANDARD_EXEC_PREFIX "/usr/local/lib/gcc-"
  #endif /* !defined STANDARD_EXEC_PREFIX */
  
  char *standard_exec_prefix = STANDARD_EXEC_PREFIX;
  char *standard_exec_prefix_1 = "/usr/lib/gcc-";
  
! #ifndef STANDARD_STARTFILE_PREFIX
! #define STANDARD_STARTFILE_PREFIX "/usr/local/lib/"
! #endif /* !defined STANDARD_STARTFILE_PREFIX */
  
- char *standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
  char *standard_startfile_prefix_1 = "/lib/";
  char *standard_startfile_prefix_2 = "/usr/lib/";
  
  /* Clear out the vector of arguments (after a command is executed).  */
  
--- 370,419 ----
  
  char *env_exec_prefix = 0;
  
  /* Suffix to attach to directories searched for commands.  */
  
! #ifndef atarist
!   char *machine_suffix = 0;
! #else
!   char *machine_suffix = ".ttp";
! #endif
  
  /* Default prefixes to attach to command names.  */
  
  #ifndef STANDARD_EXEC_PREFIX
! #  ifdef CROSSATARI
! #    ifdef MINIX
! #      define STANDARD_EXEC_PREFIX "/dsrg/bammi/cross-minix/lib/gcc-"
! #    else
! #      define STANDARD_EXEC_PREFIX "/dsrg/bammi/cross-gcc/lib/gcc-"
! #    endif /* MINIX */
! #  else /* not cross compiler */
! #    define STANDARD_EXEC_PREFIX "/usr/local/lib/gcc-"
! #  endif /* CROSSATARI */
  #endif /* !defined STANDARD_EXEC_PREFIX */
  
  char *standard_exec_prefix = STANDARD_EXEC_PREFIX;
  char *standard_exec_prefix_1 = "/usr/lib/gcc-";
  
! #ifdef CROSSATARI
! #  ifdef MINIX
!     char *standard_startfile_prefix = "/dsrg/bammi/cross-minix/lib/";
! #  else
!     char *standard_startfile_prefix = "/dsrg/bammi/cross-gcc/lib/";
! #  endif
! #else
! #  ifdef atariminix
!     char *standard_startfile_prefix = "/usr/local/lib/";
! #  else
! #    ifndef STANDARD_STARTFILE_PREFIX
! #      define STANDARD_STARTFILE_PREFIX "/usr/local/lib/"
! #    endif /* !defined STANDARD_STARTFILE_PREFIX */
!      char *standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
! #  endif
! #endif
  
  char *standard_startfile_prefix_1 = "/lib/";
  char *standard_startfile_prefix_2 = "/usr/lib/";
  
  /* Clear out the vector of arguments (after a command is executed).  */
  
***************
*** 530,541 ****
  
  void
  choose_temp_base ()
  {
    extern char *getenv ();
-   char *base = getenv ("TMPDIR");
    int len;
  
    if (base == (char *)0)
      {
  #ifdef P_tmpdir
        if (access (P_tmpdir, R_OK | W_OK) == 0)
--- 587,604 ----
  
  void
  choose_temp_base ()
  {
    extern char *getenv ();
    int len;
+ #if (!(defined(atarist) || defined(atariminix)))
+   char *base = getenv ("TMPDIR");
+ #else
+   char *base = getenv ("TEMP");
+   if(base == (char *)0)
+       base = getenv("TMPDIR");
+ #endif
  
    if (base == (char *)0)
      {
  #ifdef P_tmpdir
        if (access (P_tmpdir, R_OK | W_OK) == 0)
***************
*** 589,600 ****
    if (user_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, user_exec_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, prog);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, user_exec_prefix);
--- 652,663 ----
    if (user_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, user_exec_prefix);
  	  strcat (temp, prog);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, user_exec_prefix);
***************
*** 606,617 ****
    if (!win && env_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, env_exec_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, prog);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, env_exec_prefix);
--- 669,680 ----
    if (!win && env_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, env_exec_prefix);
  	  strcat (temp, prog);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, env_exec_prefix);
***************
*** 623,634 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, prog);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix);
--- 686,697 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix);
  	  strcat (temp, prog);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix);
***************
*** 640,651 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, prog);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
--- 703,714 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
  	  strcat (temp, prog);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, X_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
***************
*** 681,690 ****
--- 744,754 ----
  /* Fork one piped subcommand.  FUNC is the system call to use
     (either execv or execvp).  ARGV is the arg vector to use.
     NOT_LAST is nonzero if this is not the last subcommand
     (i.e. its output should be piped to the next one.)  */
  
+ #ifndef atarist
  static int
  pexecute (func, program, argv, not_last)
       char *program;
       int (*func)();
       char *argv[];
***************
*** 751,760 ****
--- 815,825 ----
  
        /* Return child's process number.  */
        return pid;
      }
  }
+ #endif /* atarist */
  
  /* Execute the command specified by the arguments on the current line of spec.
     When using pipes, this includes several piped-together commands
     with `|' between them.
  
***************
*** 768,787 ****
    char *string;
    struct command
      {
        char *prog;		/* program name.  */
        char **argv;		/* vector of args.  */
        int pid;			/* pid of process for this command.  */
      };
  
    struct command *commands;	/* each command buffer with above info.  */
  
    /* Count # of piped commands.  */
    for (n_commands = 1, i = 0; i < argbuf_index; i++)
      if (strcmp (argbuf[i], "|") == 0)
!       n_commands++;
! 
    /* Get storage for each command.  */
    commands
      = (struct command *) alloca (n_commands * sizeof (struct command));
  
    /* Split argbuf into its separate piped processes,
--- 833,858 ----
    char *string;
    struct command
      {
        char *prog;		/* program name.  */
        char **argv;		/* vector of args.  */
+ #ifndef atarist
        int pid;			/* pid of process for this command.  */
+ #endif
      };
  
    struct command *commands;	/* each command buffer with above info.  */
  
+ #ifndef atarist
    /* Count # of piped commands.  */
    for (n_commands = 1, i = 0; i < argbuf_index; i++)
      if (strcmp (argbuf[i], "|") == 0)
!      n_commands++;
! #else
!   n_commands = 1;
! #endif
!   
    /* Get storage for each command.  */
    commands
      = (struct command *) alloca (n_commands * sizeof (struct command));
  
    /* Split argbuf into its separate piped processes,
***************
*** 792,801 ****
--- 863,873 ----
    commands[0].argv = &argbuf[0];
    string = find_exec_file (commands[0].prog);
    if (string)
      commands[0].argv[0] = string;
  
+ #ifndef atarist
    for (n_commands = 1, i = 0; i < argbuf_index; i++)
      if (strcmp (argbuf[i], "|") == 0)
        {				/* each command.  */
  	argbuf[i] = 0;	/* termination of command args.  */
  	commands[n_commands].prog = argbuf[i + 1];
***************
*** 803,813 ****
  	string = find_exec_file (commands[n_commands].prog);
  	if (string)
  	  commands[n_commands].argv[0] = string;
  	n_commands++;
        }
! 
    argbuf[argbuf_index] = 0;
  
    /* If -v, print what we are about to do, and maybe query.  */
  
    if (vflag)
--- 875,888 ----
  	string = find_exec_file (commands[n_commands].prog);
  	if (string)
  	  commands[n_commands].argv[0] = string;
  	n_commands++;
        }
! #else
!   n_commands = 1;
! #endif
!   
    argbuf[argbuf_index] = 0;
  
    /* If -v, print what we are about to do, and maybe query.  */
  
    if (vflag)
***************
*** 818,832 ****
  	  char **j;
  
  	  for (j = commands[i].argv; *j; j++)
  	    fprintf (stderr, " %s", *j);
  
  	  /* Print a pipe symbol after all but the last command.  */
  	  if (i + 1 != n_commands)
  	    fprintf (stderr, " |");
  	  fprintf (stderr, "\n");
! 	}
        fflush (stderr);
  #ifdef DEBUG
        fprintf (stderr, "\nGo ahead? (y or n) ");
        fflush (stderr);
        j = getchar ();
--- 893,909 ----
  	  char **j;
  
  	  for (j = commands[i].argv; *j; j++)
  	    fprintf (stderr, " %s", *j);
  
+ #ifndef atarist
  	  /* Print a pipe symbol after all but the last command.  */
  	  if (i + 1 != n_commands)
  	    fprintf (stderr, " |");
+ #endif
  	  fprintf (stderr, "\n");
!       }
        fflush (stderr);
  #ifdef DEBUG
        fprintf (stderr, "\nGo ahead? (y or n) ");
        fflush (stderr);
        j = getchar ();
***************
*** 835,856 ****
--- 912,942 ----
        if (j != 'y' && j != 'Y')
  	return 0;
  #endif /* DEBUG */
      }
  
+ #ifndef atarist
    /* Run each piped subprocess.  */
  
    last_pipe_input = STDIN_FILE_NO;
    for (i = 0; i < n_commands; i++)
      {
+ #ifndef atariminix
        extern int execv(), execvp();
        char *string = commands[i].argv[0];
  
        commands[i].pid = pexecute ((string != commands[i].prog ? execv : execvp),
  				  string, commands[i].argv,
  				  i + 1 < n_commands);
+ #else
+       extern int execv();
+       char *string = commands[i].argv[0];
  
+       commands[i].pid = pexecute (execv,
+ 				  string, commands[i].argv,
+ 				  i + 1 < n_commands);
+ #endif
        if (string != commands[i].prog)
  	free (string);
      }
  
    execution_count++;
***************
*** 885,895 ****
--- 971,998 ----
  	      ret_code = -1;
  	  }
        }
      return ret_code;
    }
+ #else  /* atarist */
+  {
+      register int iii;
+      char **j;
+ 
+      execution_count++;
+      for (i = 0; i < n_commands ; i++)
+      {
+ 	 j = commands[i].argv;
+          iii = spawnve(0, j[0], j, NULL);
+ 	 if(iii != 0)
+ 	     return -1;
+      }
+      return 0;
+  }
+ #endif /* atarist */  
  }
+ 
  
  /* Find all the switches given to us
     and make a vector describing them.
     The elements of the vector a strings, one per switch given.
     If a switch uses the following argument, then the `part1' field
***************
*** 1048,1057 ****
--- 1151,1170 ----
  /* Nonzero means %s has been seen; the next arg to be terminated
     is the name of a library file and we should try the standard
     search dirs for it.  */
  int this_is_library_file;
  
+ #ifdef atarist
+ /* I don't know why this is necessary.  Recursive calls to do_spec_1
+    end up ignoring the error code from calls to execute().  That causes
+    do_spec to get a 0 return value, and do_spec_1("\n"), which causes the
+    command to get executed again.
+ */
+ int execute_return_error = 0;
+ #endif
+ 
+ 
  /* Process the spec SPEC and run the commands specified therein.
     Returns 0 if the spec is successfully processed; -1 if failed.  */
  
  int
  do_spec (spec)
***************
*** 1067,1080 ****
--- 1180,1202 ----
  
    value = do_spec_1 (spec, 0);
  
    /* Force out any unfinished command.
       If -pipe, this forces out the last command if it ended in `|'.  */
+ #ifdef atarist
+   if (!value && execute_return_error)
+ 	{
+ 	value = execute_return_error;
+ 	execute_return_error = 0;
+ 	}
+ #endif
    if (value == 0)
      {
+ #ifndef atarist
        if (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], "|"))
  	argbuf_index--;
+ #endif
  
        if (argbuf_index > 0)
  	value = execute ();
      }
  
***************
*** 1099,1114 ****
--- 1221,1284 ----
       int inswitch;
  {
    register char *p = spec;
    register int c;
    char *string;
+   extern char *find_file();	/* ++jrb */
  
    while (c = *p++)
      /* If substituting a switch, treat all chars like letters.
         Otherwise, NL, SPC, TAB and % are special.  */
      switch (inswitch ? 'a' : c)
        {
+ #ifdef atarist
+ /* this stuff added by jrd.  if see '$', expect name of env var, delimited
+    by '$'.  Find it's value, and subst it in.
+ 
+    modified by ERS to only collect things that look like names; this
+    saves e.g. the -$ arg. to cpp from getting munged */
+ 
+       case '$':
+       {
+ 	char varname[32];		/* should be enough */
+ 	char * value;			/* deciphered value string */
+ 	char *temp;
+ 	int i;
+ 	extern char *getenv(), *index();
+ 	
+ 	for (i = 0 ; ((c = *p) != '$') && isalnum(c) && i < 31 ; i++, p++)
+ 		varname[i] = c;
+ 	varname[i] = '\0';
+ 	if (strlen(varname) > 0) /* ++jrb fix */
+ 	{
+              	++p;    /* skip trailing '$' */
+ 		value = getenv(varname); /* ++jrb fix */
+ 		if (value)
+ 		{ /* if value is a path, only consider 1'st component */
+ 			if((temp = index(value, ',')) == NULL)
+ 			    temp = index(value, ';');
+ 			if(temp != NULL)
+ 			{
+ 			    char *t = alloca(strlen(value) + 1);
+ 			    strcpy(t, value);
+ 			    t[temp-value] = '\0';
+ 			    do_spec_1(t, 0);
+ 			}
+ 			else
+ 			    do_spec_1(value, 0);
+ 		}
+ 		    else
+ 			do_spec_1(".", 0);	/* a compleat kludge... */
+ 	}
+         else
+         {
+              obstack_1grow(&obstack, '$');
+              arg_going = 1;
+         }
+       }
+      break;
+ #endif /* atarist */
        case '\n':
  	/* End of line: finish any pending argument,
  	   then run the pending command if one has been started.  */
  	if (arg_going)
  	  {
***************
*** 1142,1151 ****
--- 1312,1325 ----
  	  }
  
  	if (argbuf_index > 0)
  	  {
  	    int value = execute ();
+ #ifdef atarist
+ 		if (!execute_return_error)
+ 			execute_return_error = value;
+ #endif
  	    if (value)
  	      return value;
  	  }
  	/* Reinitialize for a new command, and for a new argument.  */
  	clear_args ();
***************
*** 1349,1358 ****
--- 1523,1536 ----
  	  case 'E':
  	    do_spec_1 (ENDFILE_SPEC, 0);
  	    break;
  
  	  default:
+ #ifdef atarist
+ 	    fprintf(stderr, "Bogus char '%c' found at pos %d of spec '%s'\n",
+ 		c, (p - spec - 1), spec);
+ #endif
  	    abort ();
  	  }
  	break;
  
        default:
***************
*** 1379,1396 ****
      /* A `|' after the open-brace means,
         if the test fails, output a single minus sign rather than nothing.
         This is used in %{|!pipe:...}.  */
      pipe = 1, ++p;
  
!   if (*p == '!')
      /* A `!' after the open-brace negates the condition:
         succeed if the specified switch is not present.  */
      negate = 1, ++p;
  
!   filter = p;
!   while (*p != ':' && *p != '}') p++;
!   if (*p != '}')
      {
        register int count = 1;
        q = p + 1;
        while (count > 0)
  	{
--- 1557,1574 ----
      /* A `|' after the open-brace means,
         if the test fails, output a single minus sign rather than nothing.
         This is used in %{|!pipe:...}.  */
      pipe = 1, ++p;
  
!    if (*p == '!')
      /* A `!' after the open-brace negates the condition:
         succeed if the specified switch is not present.  */
      negate = 1, ++p;
  
!     filter = p;
!     while (*p != ':' && *p != '}') p++;
!     if (*p != '}')
      {
        register int count = 1;
        q = p + 1;
        while (count > 0)
  	{
***************
*** 1462,1472 ****
  	    {
  	      if (do_spec_1 (save_string (p + 1, q - p - 2), 0) < 0)
  		return 0;
  	    }
  	}
!       else if (pipe)
  	{
  	  /* Here if a %{|...} conditional fails: output a minus sign,
  	     which means "standard output" or "standard input".  */
  	  do_spec_1 ("-", 0);
  	}
--- 1640,1650 ----
  	    {
  	      if (do_spec_1 (save_string (p + 1, q - p - 2), 0) < 0)
  		return 0;
  	    }
  	}
!         else if (pipe)
  	{
  	  /* Here if a %{|...} conditional fails: output a minus sign,
  	     which means "standard output" or "standard input".  */
  	  do_spec_1 ("-", 0);
  	}
***************
*** 1533,1544 ****
    if (user_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, user_exec_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, user_exec_prefix);
--- 1711,1722 ----
    if (user_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, user_exec_prefix);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, user_exec_prefix);
***************
*** 1550,1561 ****
    if (!win && env_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, env_exec_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, env_exec_prefix);
--- 1728,1739 ----
    if (!win && env_exec_prefix)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, env_exec_prefix);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, env_exec_prefix);
***************
*** 1567,1578 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix);
--- 1745,1756 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix);
***************
*** 1584,1595 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
--- 1762,1773 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_exec_prefix_1);
***************
*** 1601,1612 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_startfile_prefix);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_startfile_prefix);
--- 1779,1790 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_startfile_prefix);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_startfile_prefix);
***************
*** 1618,1629 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_startfile_prefix_1);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_startfile_prefix_1);
--- 1796,1807 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_startfile_prefix_1);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_startfile_prefix_1);
***************
*** 1635,1646 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_startfile_prefix_2);
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_startfile_prefix_2);
--- 1813,1824 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, standard_startfile_prefix_2);
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, standard_startfile_prefix_2);
***************
*** 1652,1663 ****
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, "./");
- 	  strcat (temp, machine_suffix);
  	  strcat (temp, name);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, "./");
--- 1830,1841 ----
    if (!win)
      {
        if (machine_suffix)
  	{
  	  strcpy (temp, "./");
  	  strcat (temp, name);
+ 	  strcat (temp, machine_suffix);
  	  win = (access (temp, R_OK) == 0);
  	}
        if (!win)
  	{
  	  strcpy (temp, "./");
***************
*** 1671,1680 ****
--- 1849,1859 ----
    return name;
  }
  
  /* On fatal signals, delete all the temporary files.  */
  
+ #ifndef atarist
  void
  fatal_error (signum)
       int signum;
  {
    signal (signum, SIG_DFL);
***************
*** 1682,1691 ****
--- 1861,1871 ----
    delete_temp_files ();
    /* Get the same signal again, this time not handled,
       so its normal effect occurs.  */
    kill (getpid (), signum);
  }
+ #endif /* atarist */
  
  int
  main (argc, argv)
       int argc;
       char **argv;
***************
*** 1694,1703 ****
--- 1874,1888 ----
    int value;
    int error_count = 0;
    int linker_was_run = 0;
    char *explicit_link_files;
  
+ #ifdef atarist
+ /* turn this on if you are going to set the TOS 1.4 dont clear heap flag */
+ /*  _malloczero(1); */ 	/* zero mallocs by default */
+   programname = "gcc";
+ #else  
    programname = argv[0];
  
    if (signal (SIGINT, SIG_IGN) != SIG_IGN)
      signal (SIGINT, fatal_error);
    if (signal (SIGHUP, SIG_IGN) != SIG_IGN)
***************
*** 1704,1713 ****
--- 1889,1899 ----
      signal (SIGHUP, fatal_error);
    if (signal (SIGTERM, SIG_IGN) != SIG_IGN)
      signal (SIGTERM, fatal_error);
    if (signal (SIGPIPE, SIG_IGN) != SIG_IGN)
      signal (SIGPIPE, fatal_error);
+ #endif /* atarist */
  
    argbuf_length = 10;
    argbuf = (char **) xmalloc (argbuf_length * sizeof (char *));
  
    obstack_init (&obstack);
***************
*** 1717,1726 ****
--- 1903,1922 ----
    /* Make a table of what switches there are (switches, n_switches).
       Make a table of specified input files (infiles, n_infiles).  */
  
    process_command (argc, argv);
  
+ #ifdef atarist
+ /* if no default dir specified for executables, look for an env var
+    called 'GCCEXEC' and use that */
+ 
+   if (!user_exec_prefix)
+   	{
+ 	user_exec_prefix = getenv("GCCEXEC");
+ 	}
+ #endif /* atarist */
+ 
    if (vflag)
      {
        extern char *version_string;
        fprintf (stderr, "gcc version %s\n", version_string);
        if (n_infiles == 0)
***************
*** 1769,1779 ****
--- 1965,1980 ----
  	      /* First say how much of input_filename to substitute for %b  */
  	      register char *p;
  
  	      input_basename = input_filename;
  	      for (p = input_filename; *p; p++)
+ #ifdef atarist
+ 		if (((*p == '/') || (*p == '\\')) && (*(p-1) != ':'))
+ 		    /* allow both '\' and '/' with  our new lib */
+ #else
  		if (*p == '/')
+ #endif
  		  input_basename = p + 1;
  	      basename_length = (input_filename_length - strlen (cp->suffix)
  				 - (input_basename - input_filename));
  	      value = do_spec (cp->spec);
  	      if (value < 0)
*** /home/bammi/etc/src/gcc-1.39/toplev.c	Sun Sep 16 23:11:55 1990
--- toplev.c	Sun Jan 20 16:29:28 1991
***************
*** 39,59 ****
--- 39,72 ----
  #include <sys/times.h>
  #include <time.h>   /* Correct for hpux at least.  Is it good on other USG?  */
  #undef FFS  /* Some systems define this in param.h.  */
  #else
  #ifndef VMS
+ #if (!(defined(atarist) || defined(atariminix)))
  #include <sys/time.h>
  #include <sys/resource.h>
+ #endif /* !(atarist || atariminix) */
  #endif
  #endif
  
+ #ifdef atariminix
+ #include <sys/times.h>
+ /* #include <minix/const.h>, avoid dragging this in */
+ #define HZ 60	/* this is the only thing needed from minix/const.h */
+ #endif
+ 
  #include "input.h"
  #include "tree.h"
  #include "c-tree.h"
  #include "rtl.h"
  #include "flags.h"
  
+ #ifdef atarist
+ long _stksize = -1L;	/* for all sizes of ST's */
+ 	/* -1 means malloc from own heap and keep all  of memory */
+ #endif /* atarist */
+ 
  extern int yydebug;
  
  extern FILE *finput;
  
  extern int reload_completed;
***************
*** 374,384 ****
  /* Return time used so far, in microseconds.  */
  
  int
  gettime ()
  {
! #ifdef USG
    struct tms tms;
  #else
  #ifndef VMS
    struct rusage rusage;
  #else /* VMS */
--- 387,400 ----
  /* Return time used so far, in microseconds.  */
  
  int
  gettime ()
  {
! #ifdef atarist
!   long now;
! #else
! #if (defined(USG) || defined(atariminix))
    struct tms tms;
  #else
  #ifndef VMS
    struct rusage rusage;
  #else /* VMS */
***************
*** 389,403 ****
        int child_user_time;
        int child_system_time;
      } vms_times;
  #endif
  #endif
  
    if (quiet_flag)
      return 0;
  
! #ifdef USG
    times (&tms);
    return (tms.tms_utime + tms.tms_stime) * (1000000 / HZ);
  #else
  #ifndef VMS
    getrusage (0, &rusage);
--- 405,423 ----
        int child_user_time;
        int child_system_time;
      } vms_times;
  #endif
  #endif
+ #endif
  
    if (quiet_flag)
      return 0;
  
! #ifdef atarist
!   return(time(NULL) * 1000000);
! #else
! #if (defined(USG) || defined(atariminix))
    times (&tms);
    return (tms.tms_utime + tms.tms_stime) * (1000000 / HZ);
  #else
  #ifndef VMS
    getrusage (0, &rusage);
***************
*** 406,415 ****
--- 426,436 ----
  #else /* VMS */
    times (&vms_times);
    return (vms_times.proc_user_time + vms_times.proc_system_time) * 10000;
  #endif
  #endif
+ #endif		/* atarist */
  }
  
  #define TIMEVAR(VAR, BODY)    \
  do { int otime = gettime (); BODY; VAR += gettime () - otime; } while (0)
  
***************
*** 848,864 ****
--- 869,887 ----
      abort ();
    float_handled = 0;
    longjmp (float_handler, 1);
  }
  
+ #ifndef atarist
  /* Handler for SIGPIPE.  */
  
  static void
  pipe_closed ()
  {
    fatal ("output pipe has been closed");
  }
+ #endif
  
  /* Compile an entire file of output from cpp, named NAME.
     Write a file of assembly output and various debugging dumps.  */
  
  static void
***************
*** 1738,1754 ****
  {
    register int i;
    char *filename = 0;
    int print_mem_flag = 0;
    char *p;
! 
    /* save in case md file wants to emit args as a comment.  */
    save_argc = argc;
    save_argv = argv;
  
    p = argv[0] + strlen (argv[0]);
    while (p != argv[0] && p[-1] != '/') --p;
    progname = p;
  
  #ifdef RLIMIT_STACK
    /* Get rid of any avoidable limit on stack size.  */
    {
--- 1761,1785 ----
  {
    register int i;
    char *filename = 0;
    int print_mem_flag = 0;
    char *p;
! #ifdef atarist
! /* turn this on if you are going to set the TOS 1.4 dont clear heap flag */
! /*  _malloczero(1); */ 	/* zero mallocs by default */
! #endif  
    /* save in case md file wants to emit args as a comment.  */
    save_argc = argc;
    save_argv = argv;
  
    p = argv[0] + strlen (argv[0]);
+ #ifndef atarist
    while (p != argv[0] && p[-1] != '/') --p;
+ #else
+   while (p != argv[0] && ( ((p[-1] != '/') || (p[-1] != '\\')) &&
+ 			  (p[-2] != ':') ) ) --p;
+ #endif
    progname = p;
  
  #ifdef RLIMIT_STACK
    /* Get rid of any avoidable limit on stack size.  */
    {
***************
*** 1761,1771 ****
--- 1792,1804 ----
    }
  #endif /* RLIMIT_STACK */
  
    signal (SIGFPE, float_signal);
  
+ #ifndef atarist
    signal (SIGPIPE, pipe_closed);
+ #endif
  
    /* Initialize whether `char' is signed.  */
    flag_signed_char = DEFAULT_SIGNED_CHAR;
  #ifdef DEFAULT_SHORT_ENUMS
    /* Initialize how much space enums occupy, by default.  */
***************
*** 1791,1800 ****
--- 1824,1843 ----
  	if (str[0] == 'm')
  	  set_target_switch (&str[1]);
  	else if (!strcmp (str, "dumpbase"))
  	  {
  	    dump_base_name = argv[++i];
+ #ifdef atarist
+ /* dump_base_name will typically be 'foo.c' here.  Need to truncate at the '.',
+    cause dots mean something here */
+ 	    {
+ 	      char * n = dump_base_name;
+ 	      for ( ; ((*n) && (*n != '.')) ; )
+ 		n++;
+ 	      *n = '\0';
+ 	    }
+ #endif
  	  }
  	else if (str[0] == 'd')
  	  {
  	    register char *p = &str[1];
  	    while (*p)
***************
*** 1993,2002 ****
--- 2036,2046 ----
    /* Now that register usage is specified, convert it to HARD_REG_SETs.  */
    init_reg_sets_1 ();
  
    compile_file (filename);
  
+ #if (!(defined(atarist) || defined(atariminix)))
  #ifndef USG
  #ifndef VMS
    if (print_mem_flag)
      {
        extern char **environ;
***************
*** 2008,2018 ****
  
        system ("ps v");
      }
  #endif /* not VMS */
  #endif /* not USG */
! 
    if (errorcount)
      exit (FATAL_EXIT_CODE);
    if (sorrycount)
      exit (FATAL_EXIT_CODE);
    exit (SUCCESS_EXIT_CODE);
--- 2052,2062 ----
  
        system ("ps v");
      }
  #endif /* not VMS */
  #endif /* not USG */
! #endif /* atarist or atariminix */
    if (errorcount)
      exit (FATAL_EXIT_CODE);
    if (sorrycount)
      exit (FATAL_EXIT_CODE);
    exit (SUCCESS_EXIT_CODE);
*** /home/bammi/etc/src/gcc-1.39/math-68881.h	Thu Nov 15 21:56:57 1990
--- math-68881.h	Sun Jan 20 16:29:29 1991
***************
*** 260,269 ****
--- 260,275 ----
  	 : "=f" (value)
  	 : "f" (x));
    return value;
  }
  
+ __inline static const double hypot (const double x, const double y)
+ {
+     return sqrt(x*x + y*y);
+ }
+ 
+ 
  __inline static const double pow (const double x, const double y)
  {
    if (x > 0)
      return exp (y * log (x));
    else if (x == 0)
